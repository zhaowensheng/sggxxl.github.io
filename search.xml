<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>震惊！原来自适应和响应式有这样的区别</title>
      <link href="/2019/01/11/zhen-liang-yuan-lai-zi-gua-ying-he-xiang-ying-shi-you-zhe-yang-de-qu-bie/"/>
      <url>/2019/01/11/zhen-liang-yuan-lai-zi-gua-ying-he-xiang-ying-shi-you-zhe-yang-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>很多人对于响应式网站的定义是：能够适应不同屏幕大小终端设备的网站称之为响应式网站。所以很多人都会把自适应网站当做响应式网站，但是其实响应式网站和自适应网站是有区别的，它们两者从形式上看，都是可以实现自动适应不同屏幕大小的终端设备，但是这两者是有根本的区别的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDyg5C88qp1YJrWcyspKqLrWiaia6icyc30HCp6n6LXFDQhV5UldmoqXH07gSeAl8UoJFcdaRs7F9iaAg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>很多人对响应式网站和自适应网站都存在误解，会以为这两者都是同一类型的网站，只是叫法不一样。但是如果通过实际的浏览体验，就能分辨出它们的区别。可以说自适应只是响应式当中的一个子集，也就是说响应式的开始形态是自适应。要完全区别于它们两者，首先你要了解，什么是响应式布局？什么是自适应布局？</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDyg5C88qp1YJrWcyspKqLrgOByHCk8mxLjPrS1CqMjNpiaow4bXo1Y5aLiaDTzE0LlJquSPwnibSQLQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>什么是响应式布局？</p><p>响应式网页布局设计就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。打个比方来说：现在社会有很多响应产品，例如折叠沙发，折叠床等等，当我们需要把沙发放到一个角落的时候，此刻沙发就好比div吧，而角落里的某个地方就好比父元素，由于父元素空间的改变，我们不得不调整div,让它能够依然放在角落里。在项目中你会遇到不同的终端，由于终端分辨率不同，所以你要想让用户体验更好，就必要让你的页面能够兼容多个终端。</p><p>什么是自适应布局？</p><p>自适应网页布局设计指网页能够在不同大小的终端设备上自行适应显示。简单来说：就是让一个网站在不同大小的设备上呈现显示同一样的页面，让同一个页面适应不同大小屏幕，根据屏幕的大小，自动缩放。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDyg5C88qp1YJrWcyspKqLrZjpjkazrQBwWKlyUiaOcY4G35TyicATKB4qOo7rrVk3ETlStCQ9chIAw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>总的来说响应式与自适应的原理是相似的，都是检测设备，根据不同的设备采用不同的css，而且css都是采用的百分比的，而不是固定的宽度，不同点是响应式网站在不同的设备上看上去是不一样的，会随着设备的改变而改变模板样式、模块排版、展示样式。而自适应不会，所有的设备看起来都是一样的网站，不过是长度或者图片变小了，不会根据设备采用不同的展示样式。可能说的那么多，大家会觉得响应式网站做起来肯定很难，但是其实不然，不管懂不懂技术，懂不懂代码都可以利用建站宝盒响应式建站系统来建设响应式网站。响应式网站不单止变得易于优化，更多的是提高了用户的一个浏览体验度。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDyg5C88qp1YJrWcyspKqLrZUiamg6ZZjzDNXQyXXRpHPXcsYzeXvC5CmialibhKVN4mqgiblGJc9ykrQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p><strong>结论：</strong></p><p>所以说看一个网站是不是响应式网站，不能单单看它能不能自动适应不同大小设备，还要看适应以后的展现样式，更为重要的是你自己要多了解，不然就很容易混淆。希望本文能帮到你分清响应式网站和自适应网站的不同之处。</p><p>最后还分享下网页布局的几种类型→</p><p><strong>网站布局的五种方式</strong></p><ol><li>静态布局（static layout）</li><li>流式布局（Liquid Layout）</li><li>自适应布局（Adaptive Layout）</li><li>响应式布局（Responsive Layout）</li><li>弹性布局（rem/em布局）</li></ol><p><strong>稍微总结下</strong></p><p>1.如果只做pc端，那么静态布局（定宽度）是最好的选择；</p><p>2.如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份css+一份js调节font-size搞定；</p><p>3.如果pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。</p>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网站 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>μC/OS-Ⅲ系统中的任务种类及基本状态</title>
      <link href="/2018/12/27/mc-os-iiixi-tong-zhong-de-ren-wu-chong-lei-ji-ji-ben-zhuang-tai/"/>
      <url>/2018/12/27/mc-os-iiixi-tong-zhong-de-ren-wu-chong-lei-ji-ji-ben-zhuang-tai/</url>
      
        <content type="html"><![CDATA[<h1 id="μC-OS-Ⅲ系统中的任务种类及基本状态"><a href="#μC-OS-Ⅲ系统中的任务种类及基本状态" class="headerlink" title="μC/OS-Ⅲ系统中的任务种类及基本状态"></a>μC/OS-Ⅲ系统中的任务种类及基本状态</h1><h2 id="在μC-OS-Ⅲ系统中，任务自身一共有五种状态。"><a href="#在μC-OS-Ⅲ系统中，任务自身一共有五种状态。" class="headerlink" title="在μC/OS-Ⅲ系统中，任务自身一共有五种状态。"></a>在μC/OS-Ⅲ系统中，任务自身一共有五种状态。</h2><h3 id="1、休眠态"><a href="#1、休眠态" class="headerlink" title="1、休眠态"></a>1、休眠态</h3><p>​       调用函数OSTaskCreate()创建任务后，任务就可以接受μC/OS-Ⅲ的管理。处于休眠态的任务代码实际上已经写入代码空间中了，但是μC/OS-Ⅲ还不知道它的存在。当不在需要μC/OS-Ⅲ管理某个任务时，用户可以调用任务删除函数OSTaskDel()来删除它。OSTaskDel()实际上并不会删除一个任务的代码，只是使该任务无法再获得CPU的使用权。</p><h3 id="2、就绪态"><a href="#2、就绪态" class="headerlink" title="2、就绪态"></a>2、就绪态</h3><p>​       当一个任务准备运行时，它就进入就绪态。在μC/OS-Ⅲ中可以有任意多个任务处于就绪态。</p><h3 id="3、运行态"><a href="#3、运行态" class="headerlink" title="3、运行态"></a>3、运行态</h3><p>​        最重要的就绪任务会进入运行态。对于单核CPU，在任意时刻只能有一个任务运行。</p><h3 id="4、等待态"><a href="#4、等待态" class="headerlink" title="4、等待态"></a>4、等待态</h3><p>​       当任务等待一个事件发生才能继续运行时，任务进入等待态。处于等待态的任务会被放入一个与该任务所等待的事件相对应的等代表。当任务等待的事件发生时，任务被重新放回就续表中，成为就绪态。</p><h3 id="5、中断服务态："><a href="#5、中断服务态：" class="headerlink" title="5、中断服务态："></a>5、中断服务态：</h3><p>​    如果允许CPU被中断，那么中断发生时，正在运行的任务会被挂起，CPU开始执行中断服务子程序ISR。此时处于中断服务态。注意，ISR程序应该尽可能的短，中断处理的大部分工作应该在μC/OS-Ⅲ系统中可管理的任务级完成。</p><hr><p>​         在μC/OS-Ⅲ系统的任务中，均含有一个任务控制块TCB(Task Control Block)。这是内核使用的一种数据结构，用来维护任务相关的信息。在μC/OS-Ⅲ中，每个任务都要有自己的TCB。任务的TCB由用户在用户的存储空间中分配。当调用任务相关的函数时，要把任务TCB的地址传递给所调用的函数。需要特别注意的是，即便用户了解OS_TCB中各个成员的功能，在应用程序的代码中也不能直接访问这些成员，更不允许对其做任何改动。</p><h2 id="μC-OS-Ⅲ共有5个系统内部任务"><a href="#μC-OS-Ⅲ共有5个系统内部任务" class="headerlink" title="μC/OS-Ⅲ共有5个系统内部任务"></a>μC/OS-Ⅲ共有5个系统内部任务</h2><p>​       在5个系统任务中，空闲任务和时钟节拍任务是必须的，其他任务是可选的。</p><h3 id="1、空闲任务：OS-IdleTask-—-os-core-c"><a href="#1、空闲任务：OS-IdleTask-—-os-core-c" class="headerlink" title="1、空闲任务：OS_IdleTask()—-os_core.c"></a>1、空闲任务：OS_IdleTask()—-os_core.c</h3><p>​       OS_IdleTask()是μC/OS-Ⅲ创建的第一个任务，也是μC/OS-Ⅲ必须创建的一个任务。空闲任务的优先级总是设置为OS_CFG_PRIO_MAX-1。实际上空闲任务是唯一一个可以使用该优先级的任务（该优先级为最低优先级）。在该任务中，可以调用一些特殊的处理器控制函数，比如设置处理器处于低功耗状态等等。</p><h3 id="2、时钟节拍任务：OS-TickTask-—os-tick-c"><a href="#2、时钟节拍任务：OS-TickTask-—os-tick-c" class="headerlink" title="2、时钟节拍任务：OS_TickTask()—os_tick.c"></a>2、时钟节拍任务：OS_TickTask()—os_tick.c</h3><p>​       几乎每个实时操作系统都需要一个周期性的时钟源，称为时钟节拍(Clock Tick)或系统节拍(System Tick),用来跟踪任务延时和任务等待超时。μC/OS-Ⅲ的时钟节拍处理函数封装在os_tick.c文件中。</p><p>​       OS_TickTask()是μC/OS-Ⅲ必须创建的一个系统任务。用户可以设置该任务优先级，通常该任务设置为一个相对较高的优先级。该任务的功能是跟踪正在演示的任务，以及在指定的时间内等待某个内核对象任务。OS_TickTask()是一个周期执行的任务，它等待时钟节拍ISR发送的信号。</p><h3 id="3、统计任务：OS-StatTask-—os-stat-c"><a href="#3、统计任务：OS-StatTask-—os-stat-c" class="headerlink" title="3、统计任务：OS_StatTask()—os_stat.c"></a>3、统计任务：OS_StatTask()—os_stat.c</h3><p>​       μC/OS-Ⅲ中的统计任务是一个可选系统任务，可以在系统运行时做一些统计工作，例如统计总的CPU利用率、各任务的CPU利用率一级各任务的堆栈使用量。</p><p>​       如果需要使用统计任务，必须在main()函数创建第一个也是唯一一个应用任务中调用OSStatTaskCPUUsageInt()函数(例程见本书第一版5.6.3节，P83)。</p><h3 id="4、定时任务：OS-TmrTask-—os-tmr-c"><a href="#4、定时任务：OS-TmrTask-—os-tmr-c" class="headerlink" title="4、定时任务：OS_TmrTask()—os_tmr.c"></a>4、定时任务：OS_TmrTask()—os_tmr.c</h3><p>​       μC/OS-Ⅲ可以向用户提供定时服务。定时服务可以周期性的执行一些用户自定义的操作。在μC/OS-Ⅲ中定时任务是可选的，用户可以创建任意数据的定时器。</p><h3 id="5、中断服务管理任务：OS-IntQTask-—os-int-c"><a href="#5、中断服务管理任务：OS-IntQTask-—os-int-c" class="headerlink" title="5、中断服务管理任务：OS_IntQTask()—os_int.c"></a>5、中断服务管理任务：OS_IntQTask()—os_int.c</h3><p>​       当把os_cfg.h文件中的配置常量OS_CFG_ISR_POST_DEFERRED_EN设置为1时，μC/OS-Ⅲ会创建一个名为OS_IntQTask()的任务，该任务负责“延迟”(deferring)在ISR中调用的系统post服务函数(OS post service)的行为。</p><p>​       一个任务就是一段可以认为CPU为其独享的程序。对于单CPU系统，任何时刻都只有一个任务在运行。μC/OS-Ⅲ支持多任务管理，允许在一个应用中有任务数目的任务。任务最大数目实际只受限于处理器可用的存储量。</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> STM32 </tag>
            
            <tag> μC/OS-Ⅲ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STM32输入输出理解</title>
      <link href="/2018/12/18/stm32-shu-ru-shu-chu-li-jie/"/>
      <url>/2018/12/18/stm32-shu-ru-shu-chu-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="STM32输入输出理解"><a href="#STM32输入输出理解" class="headerlink" title="STM32输入输出理解"></a>STM32输入输出理解</h1><p>最近在看数据手册的时候，发现在Cortex-M3里，对于GPIO的配置种类有8种之多：<br>（1）GPIO_Mode_AIN 模拟输入<br>（2）GPIO_Mode_IN_FLOATING 浮空输入<br>（3）GPIO_Mode_IPD 下拉输入<br>（4）GPIO_Mode_IPU 上拉输入<br>（5）GPIO_Mode_Out_OD 开漏输出<br>（6）GPIO_Mode_Out_PP 推挽输出<br>（7）GPIO_Mode_AF_OD 复用开漏输出<br>（8）GPIO_Mode_AF_PP 复用推挽输出</p><p>对于刚入门的新手，我想这几个概念是必须得搞清楚的，平时接触的最多的也就是推挽输出、开漏输出、上拉输入这三种，但一直未曾对这些做过归纳。因此，在这里做一个总结：<br>推挽输出:可以输出高,低电平,连接数字器件; 推挽结构一般是指两个三极管分别受两互补信号的控制,总是在一个三极管导通的时候另一个截止。高低电平由IC的电源低定。<br>推挽电路是两个参数相同的三极管或MOSFET,以推挽方式存在于电路中,各负责正负半周的波形放大任务,电路工作时，两只对称的功率开关管每次只有一个导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载抽取电流。推拉式输出级既提高电路的负载能力，又提高开关速度。<br>详细理解：</p><p>推挽放大器的输出级有两个“臂”（两组放大元件），一个“臂”的电流增加时，另一个“臂”的电流则减小，二者的状态轮流转换。对负载而言，好像是一个“臂”在推，一个“臂”在拉，共同完成电流输出任务。当输出高电平时，也就是下级负载门输入高电平时，输出端的电流将是下级门从本级电源经VT3拉出。这样一来，输出高低电平时，VT3 一路和 VT5 一路将交替工作，从而减低了功耗，提高了每个管的承受能力。又由于不论走哪一路，管子导通电阻都很小，使RC常数很小，转变速度很快。因此，推拉式输出级既提高电路的负载能力，又提高开关速度。<br>开漏输出:输出端相当于三极管的集电极. 要得到高电平状态需要上拉电阻才行. 适合于做电流型的驱动,其吸收电流的能力相对强(一般20ma以内).<br>开漏形式的电路有以下几个特点：</p><p>1.利用外部电路的驱动能力，减少IC内部的驱动。当IC内部MOSFET导通时，驱动电流是从外部的VCC流经R pull-up ，MOSFET到GND。IC内部仅需很下的栅极驱动电流。</p><p>2.一般来说，开漏是用来连接不同电平的器件，匹配电平用的，因为开漏引脚不连接外部的上拉电阻时，只能输出低电平，如果需要同时具备输出高电平的功能，则需要接上拉电阻，很好的一个优点是通过改变上拉电源的电压，便可以改变传输电平。比如加上上拉电阻就可以提供TTL/CMOS电平输出等。（上拉电阻的阻值决定了逻辑电平转换的沿的速度。阻值越大，速度越低功耗越小，所以负载电阻的选择要兼顾功耗和速度。）</p><p>3.OPEN-DRAIN提供了灵活的输出方式，但是也有其弱点，就是带来上升沿的延时。因为上升沿是通过外接上拉无源电阻对负载充电，所以当电阻选择小时延时就小，但功耗大；反之延时大功耗小。所以如果对延时有要求，则建议用下降沿输出。</p><p>4.可以将多个开漏输出的Pin，连接到一条线上。通过一只上拉电阻，在不增加任何器件的情况下，形成“与逻辑”关系。这也是I2C，SMBus等总线判断总线占用状态的原理。补充：什么是“线与”？：<br>在一个结点(线)上,连接一个上拉电阻到电源VCC或VDD和n个NPN或NMOS晶体管的集电极C或漏极D,这些晶体管的发射极E或源极S都接到地线上,只要有一个晶体管饱和,这个结点(线)就被拉到地线电平上.因为这些晶体管的基极注入电流(NPN)或栅极加上高电平(NMOS),晶体管就会饱和,所以这些基极或栅极对这个结点(线)的关系是或非NOR逻辑.如果这个结点后面加一个反相器,就是或OR逻辑.<br>其实可以简单的理解为：在所有引脚连在一起时，外接一上拉电阻，如果有一个引脚输出为逻辑0，相当于接地，与之并联的回路“相当于被一根导线短路”，所以外电路逻辑电平便为0，只有都为高电平时，与的结果才为逻辑1。<br>关于推挽输出和开漏输出，最后用一幅最简单的图形来概括：</p><p>该图中左边的便是推挽输出模式，其中比较器输出高电平时下面的PNP三极管截止，而上面NPN三极管导通，输出电平VS+；当比较器输出低电平时则恰恰相反，PNP三极管导通，输出和地相连，为低电平。右边的则可以理解为开漏输出形式，需要接上拉。</p><p>浮空输入：对于浮空输入，一直没找到很权威的解释，只好从以下图中去理解了</p><p>由于浮空输入一般多用于外部按键输入，结合图上的输入部分电路，我理解为浮空输入状态下，IO的电平状态是不确定的，完全由外部输入决定，如果在该引脚悬空的情况下，读取该端口的电平是不确定的。<br>上拉输入/下拉输入/模拟输入：这几个概念很好理解，从字面便能轻易读懂。<br>复用开漏输出、复用推挽输出：可以理解为GPIO口被用作第二功能时的配置情况（即并非作为通用IO口使用）<br>最后总结下使用情况：<br>在STM32中选用IO模式<br>（1） 浮空输入_IN_FLOATING ——浮空输入，可以做KEY识别，RX1<br>（2）带上拉输入_IPU——IO内部上拉电阻输入<br>（3）带下拉输入_IPD—— IO内部下拉电阻输入<br>（4） 模拟输入_AIN ——应用ADC模拟输入，或者低功耗下省电<br>（5）开漏输出_OUT_OD ——IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51的IO双向功能<br>（6）推挽输出_OUT_PP ——IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的<br>（7）复用功能的推挽输出_AF_PP ——片内外设功能（I2C的SCL,SDA）<br>（8）复用功能的开漏输出_AF_OD——片内外设功能（TX1,MOSI,MISO.SCK.SS）</p><p>STM32设置实例：</p><p>（1）模拟I2C使用开漏输出_OUT_OD，接上拉电阻，能够正确输出0和1；读值时先GPIO_SetBits(GPIOB, GPIO_Pin_0)；拉高，然后可以读IO的值；使用GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_0)；</p><p>（2）如果是无上拉电阻，IO默认是高电平；需要读取IO的值，可以使用带上拉输入_IPU和浮空输入_IN_FLOATING和开漏输出_OUT_OD；<br>通常有5种方式使用某个引脚功能，它们的配置方式如下：<br>1）作为普通GPIO输入：根据需要配置该引脚为浮空输入、带弱上拉输入或带弱下拉输入，同时不要使能该引脚对应的所有复用功能模块。<br>2）作为普通GPIO输出：根据需要配置该引脚为推挽输出或开漏输出，同时不要使能该引脚对应的所有复用功能模块。<br>3）作为普通模拟输入：配置该引脚为模拟输入模式，同时不要使能该引脚对应的所有复用功能模块。<br>4）作为内置外设的输入：根据需要配置该引脚为浮空输入、带弱上拉输入或带弱下拉输入，同时使能该引脚对应的某个复用功能模块。<br>5）作为内置外设的输出：根据需要配置该引脚为复用推挽输出或复用开漏输出，同时使能该引脚对应的所有复用功能模块。</p><p>注意如果有多个复用功能模块对应同一个引脚，只能使能其中之一，其它模块保持非使能状态。</p><p>比如要使用STM32F103VBT6的47、48脚的USART3功能，则需要配置47脚为复用推挽输出或复用开漏输出，配置48脚为某种输入模式，同时使能USART3并保持I2C2的非使能状态。<br>如果要使用STM32F103VBT6的47脚作为TIM2_CH3，则需要对TIM2进行重映射，然后再按复用功能的方式配置对应引脚。</p><hr><h2 id="一、GPIO模式配置"><a href="#一、GPIO模式配置" class="headerlink" title="一、GPIO模式配置"></a>一、GPIO模式配置</h2><p>1、输入/输出模式（参考stm32手册）<br>2、GPIO输出模式下，几种速度的区别：<br>(1). GPIO 引脚速度： GPIO_Speed_2MHz (10MHz, 50MHz) ;<br>又称输出驱动电路的响应速度：（芯片内部在I/O口的输出部分安排了多个响应速度不同的输出驱动电路，用户可以根据自己的需要选择合适的驱动电路，通过选择速度来选择不同的输出驱动模块，达到最佳的噪声控制和降低功耗的目的。）<br>可理解为: 输出驱动电路的带宽：即一个驱动电路可以不失真地通过信号的最大频率。<br>(如果一个信号的频率超过了驱动电路的响应速度，就有可能信号失真。失真因素？)<br>如果信号频率为10MHz，而你配置了2MHz的带宽，则10MHz的方波很可能就变成了正弦波。就好比是公路的设计时速，汽车速度低于设计时速时，可以平稳地运行，如果超过设计时速就会颠簸，甚至翻车。<br>关键是： GPIO的引脚速度跟应用相匹配，速度配置越高，噪声越大，功耗越大。<br>带宽速度高的驱动器耗电大、噪声也大，带宽低的驱动器耗电小、噪声也小。使用合适的驱动器可以降低功耗和噪声<br>比如：高频的驱动电路，噪声也高，当不需要高的输出频率时，请选用低频驱动电路，这样非常有利于提高系统的EMI性能。当然如果要输出较高频率的信号，但却选用了较低频率的驱动模块，很可能会得到失真的输出信号。关键是GPIO的引脚速度跟应用匹配（推荐10倍以上？）。<br>比如：<br>①　USART串口，若最大波特率只需115.2k，那用2M的速度就够了，既省电也噪声小。<br>②　I2C接口，若使用400k波特率，若想把余量留大些，可以选用10M的GPIO引脚速度。<br>③　SPI接口，若使用18M或9M波特率，需要选用50M的GPIO的引脚速度。<br>(2). GPIO的翻转速度指：输入/输出寄存器的0 ，1 值反映到外部引脚(APB2上)高低电平的速度.手册上指出GPIO最大翻转速度可达18MHz。<br>@通过简单的程序测试，用示波器观察到的翻转时间: 是综合的时间，包括取指令的时间、指令执行的时间、指令执行后信号传递到寄存器的时间(这其中可能经过很多环节，比如AHB、APB、总线仲裁等)，最后才是信号从寄存器传输到引脚所经历的时间。<br>如：有上拉电阻，其阻值越大，RC延时越大，即逻辑电平转换的速度越慢，功耗越大。<br>(3).GPIO 输出速度：与程序有关，(程序中写的多久输出一个信号)。<br>2、GPIO口设为输入时，输出驱动电路与端口是断开，所以输出速度配置无意义。<br>3、在复位期间和刚复位后，复用功能未开启，I/O端口被配置成浮空输入模式。<br>4、所有端口都有外部中断能力。为了使用外部中断线，端口必须配置成输入模式。<br>5、GPIO口的配置具有上锁功能，当配置好GPIO口后，可以通过程序锁住配置组合，直到下次芯片复位才能解锁。<br>一般应用：<br>模拟输入_AIN ——应用ADC模拟输入，或者低功耗下省电。<br>浮空输入_IN_FLOATING ——可以做KEY识别，RX1<br>开漏输出_Out_OD——应用于I2C总线； （STM32开漏输出若外部不接上拉电阻只能输出0）</p><h2 id="二-管脚的复用功能-重映射"><a href="#二-管脚的复用功能-重映射" class="headerlink" title="二. 管脚的复用功能 重映射"></a>二. 管脚的复用功能 重映射</h2><p>1、复用功能：内置外设是与I/O口共用引出管脚（不同的功能对应同一管脚）<br>STM32 所有内置外设的外部引脚都是与标准GPIO引脚复用的，如果有多个复用功能模块对应同一个引脚，只能使能其中之一，其它模块保持非使能状态。<br>2、重映射功能：复用功能的引出脚可以通过重映射，从不同的I/O管脚引出，即复用功 能的引出脚位是可通过程序改变到其他的引脚上！<br>直接好处：PCB电路板的设计人员可以在需要的情况下，不必把某些信号在板上绕一大圈完成联接，方便了PCB的设计同时潜在地减少了信号的交叉干扰。<br>如：USART1： 0: 没有重映像(TX/PA9，RX/PA10)； 1: 重映像(TX/PB6，RX/PB7)。<br>（参考AFIO_MAPR寄存器介绍）[0,1为一寄存器的bit值]<br>【注】 下述复用功能的引出脚具有重映射功能：</p><ul><li><p>晶体振荡器的引脚在不接晶体时，可以作为普通I/O口</p></li><li><p>CAN模块； - JTAG调试接口；- 大部分定时器的引出接口； - 大部分USART引出接口</p></li><li><p>I2C1的引出接口； - SPI1的引出接口；<br>举例：对于STM32F103VBT6，47引脚为PB10，它的复用功能是I2C2_SCL和 USART3_TX，表示在上电之后它的默认功能为PB10，而I2C2的SCL和USART3的TX为它的复用功能；另外在TIM2的引脚重映射后，TIM2_CH3也成为这个引脚的复用功能。<br>(1)要使用STM32F103VBT6的47、48脚的USART3功能，则需要配置47脚为复用推挽输出或复用开漏输出，配置48脚为某种输入模式，同时使能USART3并保持I2C2的非使能状态。<br>(2)使用STM32F103VBT6的47脚作为TIM2_CH3，则需要对TIM2进行重映射，然后再按复用功能的方式配置对应引脚. </p></li></ul><p>  输入输出快速切换</p><p>  #define HD7279_DAT_OUT GPIOB-&gt;CRH=(GPIOB-&gt;CRH&amp;(~(0x0000000F&lt;&lt;20)))|0x00000003&lt;&lt;20 //推挽输出</p><p>  #define HD7279_DAT_IN GPIOB-&gt;CRH=(GPIOB-&gt;CRH&amp;(~(0x0000000F&lt;&lt;20)))|0x00000004&lt;&lt;20 //浮空输入</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STM32基础知识</title>
      <link href="/2018/12/17/stm32-ji-chu-zhi-shi/"/>
      <url>/2018/12/17/stm32-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="1-GPIO口"><a href="#1-GPIO口" class="headerlink" title="1)  GPIO口"></a>1)  GPIO口</h2><h3 id="a-工程的建立："><a href="#a-工程的建立：" class="headerlink" title="a)      工程的建立："></a>a)      工程的建立：</h3><p>1）  stdPeiph_Driver,下面存放的是ST官方提供的固件库函数，里面内容不需要用户修改。</p><p>2）  Startup下面存放的是固件库必须的启动文件。不需用户修改。</p><p>3）  Cmsis下面存放的是固件库必须的启动文件。不需用户修改。</p><p>4）  APP下面存放的是外设的驱动代码。比如说LED.c里面需要调用stm32f10x_gpio.c里面的函数对其进行初始化。</p><p>5）  User下面存放的主要是用户代码。</p><h3 id="b-IO口模式配置"><a href="#b-IO口模式配置" class="headerlink" title="b)      IO口模式配置"></a>b)      IO口模式配置</h3><p><a href="https://imgchr.com/i/F08vCj" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/12/17/F08vCj.png" alt="F08vCj.png"></a></p><h3 id="c-应用相关引脚需要开启相应的时钟，为了降低功耗。"><a href="#c-应用相关引脚需要开启相应的时钟，为了降低功耗。" class="headerlink" title="c)  应用相关引脚需要开启相应的时钟，为了降低功耗。"></a>c)  应用相关引脚需要开启相应的时钟，为了降低功耗。</h3><h2 id="2）STM32系统内部时钟——SysTick时钟（滴答时钟）"><a href="#2）STM32系统内部时钟——SysTick时钟（滴答时钟）" class="headerlink" title="2）STM32系统内部时钟——SysTick时钟（滴答时钟）"></a>2）STM32系统内部时钟——SysTick时钟（滴答时钟）</h2><p>a) SysTick定时器包含在M3内核里，捆绑在NVIC 中。</p><p>b) 它是一款24位倒计数定时器，计数到0时可产生中断。</p><p>c) 时钟来源可以直接来源于系统时钟，还可以经过8分频之后付给SysTick</p><h2 id="3-RCC系统时钟"><a href="#3-RCC系统时钟" class="headerlink" title="3)RCC系统时钟"></a>3)RCC系统时钟</h2><p>a)STM32时钟比较复杂，它可以选择多种时钟源，也可以选择不同的时钟频率，。</p><p>b) 从RCC输出的时钟，首先经过AHB总线，分别分配给其他外设时钟，不同的外设挂在不同的桥上。比如ADC,GPIO挂在APB2（最高72MHz）上，而IIC挂在APB1（最高36MHz)上，因此不同的外设所具有不同的时钟频率。</p><p>c)芯片默认上电使用系统内部时钟(8MHz)。经本函数库，默认使用系统外部时钟（72MHz）。</p><p>d)STM32一共可以有4个晶振源。内部自带高速时钟，外部高速时钟，内部低速时钟，外部高速时钟。</p><p>e)系统时钟来源，可来自：内部高速时钟（HIS），外部高速时钟（HSE），HIS或HSE倍频之后的PLL时钟。</p><h2 id="4）外部中断"><a href="#4）外部中断" class="headerlink" title="4）外部中断"></a>4）外部中断</h2><p>a)中断嵌套：中断能够被其他高优先级的中断而中断。</p><p>b)优先级：抢占优先级，响应优先级。抢占优先级高的可中断抢占优先级低的，响应优先级高的不可中断响应优先级低的（如果抢占优先级相同，中断同时到达，优先使用响应优先级高的）。</p><p>C）EXTI外部中断，每个IO口都可用来作外部中断。16个外部中断组，所以同时独立使用的外部中断IO口只有16个。</p><h2 id="5）定时器"><a href="#5）定时器" class="headerlink" title="5）定时器"></a>5）定时器</h2><p>(a) stm32的定时器功能十分强大，它共有11个定时器。其中二个高级定时器，4个通用定时，2个基本定时器，以及2个看门狗定时器，1个系统滴答定时器。</p><p><a href="https://imgchr.com/i/F08X5Q" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/12/17/F08X5Q.png" alt="F08X5Q.png"></a></p><p>(b)通用定时器的功能：16位向上，向下，向上/向下自动装载计数器。</p><p>16位可编程预分频器，计数器的时钟频率的预分频系数为1~65536之间的任意值。</p><p>4个独立通道，输入捕获，输出比较，PWM生成，单脉冲模式输出。</p><p>(c)计数器时钟可以由下列时钟源提供: 内部时钟，外部时钟1，外部时钟2，内壁触发输入。</p><h2 id="6）PWM"><a href="#6）PWM" class="headerlink" title="6）PWM"></a>6）PWM</h2><p>(a)，TIM1.TIM8最多能同时产生7路PWM的输出，TIM2~TIM5等通用定时器能同时产生4路PWM。TIM6和TIM7不能产生PWM。因此STM32最多能同时产生30路的PWM。</p><p>（b），具有重映射功能。</p><h2 id="7）串口通信——USART"><a href="#7）串口通信——USART" class="headerlink" title="7）串口通信——USART"></a>7）串口通信——USART</h2><p>a) stm32f103zet6有五路串口。</p><p>b)232串口通信，出现较早，全双工</p><p>c)485串口通信，出现较晚，半双工。</p><p><a href="https://imgchr.com/i/F08OUg" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/12/17/F08OUg.png" alt="F08OUg.png"></a></p><p>d)通用同步异步收发器（URART）利用分数波特率发生器提供宽泛的波特率选择，它支持单向通信，和全，半双工通信。双向通信至少需要两个引脚（RX，TX）。</p><h2 id="8）IIC和24CO2双向通信"><a href="#8）IIC和24CO2双向通信" class="headerlink" title="8）IIC和24CO2双向通信"></a>8）IIC和24CO2双向通信</h2><p>a)IIC总线是PHILIPS公司推出的一种串行总线，它只需要两根双向的信号线（SDA,SCL）。</p><p>每个器件都有自己相应的I2C地址，所以在通信的时候，首先你需要呼叫所需通信器件的地址，然后等待从器件应答之后才能开始通信，</p><p>b）应用时需注意两点，空闲时，SDA,SCL必需为高电平，SCL为高电平期间，SDA必须保持稳定，也就是说SDA需要改变时，最好将SCL拉低。否则就会被误判（错误的将信号当成起始信号，或者终止信号处理）。</p><h2 id="9-ADC-模拟-数字转换"><a href="#9-ADC-模拟-数字转换" class="headerlink" title="9)ADC(模拟/数字转换)"></a>9)ADC(模拟/数字转换)</h2><p>a)12位ADC是一种逐次逼近型的模拟数字转换器，它有多达18个通道，可同时测量16个外部通道，两个内部通道信号源。各通道可以单次，连续，扫描，间断扫描模式执行。ADC的输入时钟不得超过14MHz.</p><p>b)16个多路通道，分成规则组，注入组。（类似中断）</p><p>c）单次转换（ADC只转换一次），连续转换（ADC转化完成以后，马上进行另一次转换）。</p><p>d)模拟看门狗，如果ADC转换的模拟电压低于或者高于阈值,AWD模拟看门狗将会被置位。</p><p>e)扫描模式，扫描一组模拟通道。</p><p>g)间断模拟。</p><h2 id="10）stm32内部RTC时钟"><a href="#10）stm32内部RTC时钟" class="headerlink" title="10）stm32内部RTC时钟"></a>10）stm32内部RTC时钟</h2><p>a)具有42个16位备份储存器，可以用来储存84个字节的用户应用程序数据。</p><p>b)当电源VDD被截断，他们仍然由VBAT维持供电。</p><p>c)系统复位或电源复位，待机模式下被唤醒。他们也不会被复位。</p><p>d)STM32内部RTC时钟就在备份寄存器中，因此需要操作RTC时钟，就要操作备份寄存器。</p><p>e)RCT用来储存时钟的只是一个32位的寄存器，可以记录4294967296s,合计136年。</p><h2 id="11）待机唤醒实验"><a href="#11）待机唤醒实验" class="headerlink" title="11）待机唤醒实验"></a>11）待机唤醒实验</h2><p>a)STM32低功耗模式一共有三种模式：睡眠模式（Cortex-M3内核停止），停止模式（所有时钟停止），待机模式（1.8v电源关闭）。它们功耗依次降低。</p><h2 id="12）独立看门狗"><a href="#12）独立看门狗" class="headerlink" title="12）独立看门狗"></a>12）独立看门狗</h2><p>a)独立看门狗内部专门的40KHZ,低速时钟驱动，即使主时钟发生故障，它也仍然有效。</p><p>b)单片机在外界的干扰下，会出现程序跑飞的现象导致出现死循环，看门狗电路就是避免这种情况发现的。</p><p>c)看门狗的作用就是在一定时间内没有接收喂狗信号（表示MCU已经跑飞了），便实现处理器自动复位重启（发送复位信号）。</p><h2 id="13窗口看门狗"><a href="#13窗口看门狗" class="headerlink" title="13窗口看门狗"></a>13窗口看门狗</h2><p>a)窗口看门狗（WWDG）通常被用来监测外部干扰或者不可预见的逻辑条件造成的应用程序背离正常运行序列而产生的软件故障。</p><h2 id="14）输入捕获"><a href="#14）输入捕获" class="headerlink" title="14）输入捕获"></a>14）输入捕获</h2><p>a)输入捕获模式可以用来测量脉冲宽度或者频率。</p><p>b)STM32定时器除了TIM6和TIM7，其它定时器都具有输入捕获的功能。</p><p>c)完成一次捕获还能配置捕获是否触发中断/DMA等。</p><h2 id="15）FLASH-模拟EEPROM"><a href="#15）FLASH-模拟EEPROM" class="headerlink" title="15）FLASH 模拟EEPROM"></a>15）FLASH 模拟EEPROM</h2><p>a)STM32内部没有自带EEPROM，但STM32具有IAP(在应用编程)功能，所以我们能把FLASH当作EEPROM使用。</p><p>b)不同型号的FLASH内存大小也有所不同，最小的有16K，最大的有1024K，STM32F103ZET6这款有512K，属于大容量FLASH (另外还有中，小型FLASH)。</p><p>C) STM32的闪存模块由：主储存器，信息块，闪存储存器构成。</p><h2 id="16-SPI——FLASH"><a href="#16-SPI——FLASH" class="headerlink" title="16)SPI——FLASH"></a>16)SPI——FLASH</h2><p>a)      EN25Q64是华邦公司推出的大容量SPIFLASH 产品，容量为64比特，也就是8M。</p><p>b)      EN25Q64支持标准的SPI,还支持双/四输出的SPI。</p><p>c)      SPI(serial peripheralinterface),顾明思义就是串行外围设备接口。主要用四根线进行通信，MISO， MOSI， SCLK， CS。</p><p>d)      SPI传输的过程通过移位寄存器来完成。</p><h2 id="17）外部SRAM"><a href="#17）外部SRAM" class="headerlink" title="17）外部SRAM"></a>17）外部SRAM</h2><p>a) IS62WV51216是ISSI公司生产的一颗位宽512K容量的CMOS静态内存芯片。它具有高速访问（45ns/55ns访问速度），低功耗，兼容TTL电平接口。全静态操作，字节访问功能。</p><h2 id="18-）can-通信"><a href="#18-）can-通信" class="headerlink" title="18 ）can 通信"></a>18 ）can 通信</h2><p>a)      can是一种ISO国际标准化的串行通信协议，是1996年德州电气商博世公司开发出面向汽车开发出来的，现在在欧洲已是汽车网络标准协议。广泛用于工业自动化，船舶，医疗设备，工业设备等方面。</p><p>b)      CAN传输数据只需两根线就可以了。CAN控制器根据两根线上的电位差来判断总线电平。总线电平分为显性电平和隐形电平，二者必居其一。发送方通过使总线电平发生变化，将消息发送给接收方。</p><p>c)      CAN通行特点：多主控制（在总线空闲时，所有的单元都可以发送消息），系统的柔软性（与总线相连的单元没有类似于“地址”的信息，不像I2C总线上面每个单元都有自己的地址），通信速度（最高1Mnps,最远可达10KM）,远程数据请求，错误监测功能，错误通知功能，错误恢复功能，故障封闭，连接（CAN总线是可同时连接多个单元的总线）。</p><p>d)      CAN的传输主要通过5种类型的帧来进行的。</p><h2 id="19）ADXL345加速度传感器"><a href="#19）ADXL345加速度传感器" class="headerlink" title="19）ADXL345加速度传感器"></a>19）ADXL345加速度传感器</h2><p>a) ADX345是一款完整的3轴加速度测量系统，可选择测量范围有±2g, ±4g, ±8g,或±16g。</p><p>既能测量运动或冲击导致的动态加速度，也能测量静止加速度。例如重力加速度，使得器件可以作为倾斜传感器使用。</p><p>c)      它的分辨率为13位，测量范围达±16g。可以通过SPI或者I2C数字接口访问。</p><h2 id="20-SD卡"><a href="#20-SD卡" class="headerlink" title="20)SD卡"></a>20)SD卡</h2><p>a)SD卡是由MMC卡的基础上发展而来的，它是一种基于半导体快闪记忆器的新一代记忆设备，被广泛用于各种便携设备，如手机，数码相机多媒体播放器。</p><p>b)SD卡有两种操作方式，一种是SDIO,还有一种是SPI。</p><p>作者：陌上烟雨遥407<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/DMC111qwf/article/details/79434647" target="_blank" rel="noopener">https://blog.csdn.net/DMC111qwf/article/details/79434647</a> </p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS入门详解(二)</title>
      <link href="/2018/11/28/css-ru-men-xiang-jie-er/"/>
      <url>/2018/11/28/css-ru-men-xiang-jie-er/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS详解-二"><a href="#CSS详解-二" class="headerlink" title="CSS详解(二)"></a>CSS详解(二)</h1><h2 id="11-动画"><a href="#11-动画" class="headerlink" title="11. 动画"></a>11. 动画</h2><blockquote><p>动画是<code>CSS3</code>中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p></blockquote><h3 id="11-1-如何实现动画"><a href="#11-1-如何实现动画" class="headerlink" title="11.1 如何实现动画"></a>11.1 如何实现动画</h3><p><strong>必要元素：</strong></p><ul><li>a、通过<code>@keyframes</code>指定动画序列；</li><li>b、通过百分比将动画序列分割成多个节点；</li><li>c、在各节点中分别定义各属性</li><li>d、通过<code>animation</code>将动画应用于相应元素；</li></ul><p><strong>示例代码：</strong> 两种定义动画的方式</p><pre><code>&lt;style&gt;    /* move 是定义的动画名 */    @keyframes move {        0% {            transform: translateX(0px);            width: 200px;            height: 200px;        }        40% {            width: 300px;            height: 300px;        }        80% {            width: 200px;            height: 200px;            transform: translateX(100px);        }        100% {            transform: translateX(0px);            width: 200px;            height: 200px;        }    }    /* 定义动画集 */    @keyframes  move1 {        from {            /* 动画的开始状态 */            /* 位置开始状态 */            transform: translateX(0px);        }        to {            /* 动画的结束状态 */            /* 位置结束状态 */            transform: translateX(300px);        }    }    .box {        width: 200px;        height: 200px;        background-color: pink;        /* 调用动画集 动画名 持续时间 执行速度 */        animation: move 5s linear;    }&lt;/style&gt;</code></pre><h3 id="11-2-动画关键属性"><a href="#11-2-动画关键属性" class="headerlink" title="11.2 动画关键属性"></a>11.2 动画关键属性</h3><p><strong>关键属性</strong></p><ul><li>a、<code>animation-name</code>设置动画序列名称</li><li>b、<code>animation-duration</code>动画持续时间</li><li>c、<code>animation-delay</code>动画延时时间</li><li>d、<code>animation-timing-function</code>动画执行速度，<code>linear</code>、<code>ease</code>等</li><li>e、<code>animation-play-state</code>动画播放状态，<code>running</code>、<code>paused</code>等</li><li>f、<code>animation-direction</code>动画逆播，<code>alternate</code>等</li><li>g、<code>animation-fill-mode</code>动画执行完毕后状态，<code>forwards</code>、<code>backwards</code>等</li><li>h、<code>animation-iteration-count</code>动画执行次数，<code>inifinate</code>等</li><li>i、<code>steps(60)</code>表示动画分成<code>60</code>步完成</li></ul><p><strong>参数值的顺序：</strong></p><p><em>关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意。</em></p><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 200px;        height: 200px;        background-color: pink;        /* 调用动画集 */        animation: move 5s linear;    }    /* 定义动画集 */    @keyframes move {        0% {            /* 位置开始状态 */            transform: translateX(0px);            /* 动画的开始状态 */            width: 100px;            height: 100px;        }        40% {            width: 150px;            height: 150px;            background: orange；        }        80% {            width: 200px;            height: 200px;            background: cyan;            transform: translateX(100px);        }        100% {            /* 位置结束状态 */            transform: translateX(0px);            /* 动画的结束状态 */            width: 100px;            height: 100px;            background: pink;        }    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwhvpd1f2dg309d06imx9.gif" alt="image"></p><h3 id="11-3-动画案例"><a href="#11-3-动画案例" class="headerlink" title="11.3 动画案例"></a>11.3 动画案例</h3><p><strong>1、全屏切换</strong></p><blockquote><p>定义三个动画集，当点击<code>a</code>标签的时候，通过他的锚点触发对应的动画集。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {         margin: 0;         padding: 0;    }    html,body {         width: 100%;         height: 100%;    }    .box {         width: 100%;         height: 100%;         position: relative;         overflow: hidden;    }    .box&gt;div{         width: 100%;         height: 100%;         position: absolute;         background-size: cover;    }    .one {         background: url(img/bg6.jpg) no-repeat;    }    .two {        background: url(img/bg7.jpg) no-repeat;    }    .three {         background: url(img/bg8.jpg) no-repeat;    }    .box .numbers {         width: 150px;         height: 40px;         left: 50%;         margin-left: -75px;         bottom: 30px;         z-index: 4;    }    .box .numbers a {          width: 40px;          height: 40px;          display: block;          line-height: 40px;          text-align: center;          text-decoration: none;          color: #777;          background-color: rgba(255,255,255,.8);          border-radius: 50%;          float: left;          margin: 0 5px;    }    .one:target {         animation: move 1s linear;         z-index: 1;    }    .two:target {         animation: rotate 1s linear;         z-index: 1;    }    .three:target {         animation: scale 1s linear;         z-index: 1;    }    @keyframes move {         from {              transform: translateX(-100%);         }         to {             transform: translateX(0px);         }    }    @keyframes rotate {         from {              transform: scale(0) rotateZ(0deg);         }         to {            transform: scale(1) rotateZ(360deg);         }    }    @keyframes scale {        from {            transform: scale(0);        }        to {            transform: scale(1);        }    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;   &lt;div class=&quot;one&quot; id=&quot;one&quot;&gt;&lt;/div&gt;   &lt;div class=&quot;two&quot; id=&quot;two&quot;&gt;&lt;/div&gt;   &lt;div class=&quot;three&quot; id=&quot;three&quot;&gt;&lt;/div&gt;   &lt;div class=&quot;numbers&quot;&gt;        &lt;a href=&quot;#one&quot;&gt;1&lt;/a&gt;        &lt;a href=&quot;#two&quot;&gt;2&lt;/a&gt;        &lt;a href=&quot;#three&quot;&gt;3&lt;/a&gt;   &lt;/div&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwi0rlemozg30la0by4qp.gif" alt="image"></p><p><strong>2、大海波涛</strong></p><blockquote><p>波浪其实是两张图片，执行的是同一组动画，只需要在第二张图片执行动画的时候，让它延迟<code>1s</code>执行，就可以出现“波动”的感觉。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {        margin: 0;        padding: 0;    }    html,body {        width: 100%;        height: 100%;    }    .box {         width: 100%;         height: 100%;         background-color: #0EA9B1;         position: relative;         overflow: hidden;    }    .box img {         position: absolute;         width: 100%;         bottom: 0;    }    .sun {         width: 80px;         height: 80px;         background-color: #fff;         border-radius: 50%;         position: absolute;         left: 100px;         top: 50px;    }    .sun:after {         content: &quot;&quot;;         display: block;         width: 100px;         height: 100px;         border-radius: 50%;         background-color: rgba(255,255,255,.6);         position: absolute;         left: 50%;         top: 50%;         margin-left: -50px;         margin-top: -50px;         animation: scale 1s linear infinite alternate;    }    .sun:before {        content: &quot;&quot;;        display: block;        width: 120px;        height: 120px;        border-radius: 50%;        background-color: rgba(255,255,255,.4);        position: absolute;        left: 50%;        top: 50%;        margin-left: -60px;        margin-top: -60px;        animation: scale 2s 1s linear infinite alternate;    }    @keyframes scale {        from {            transform: scale(1);        }        to {            transform: scale(1.2);        }    }    @keyframes move{         from {              bottom: 0px;         }         to {              bottom: -60px;         }    }    img:nth-child(2){         animation: move 1s linear infinite alternate;    }    img:nth-child(3) {         animation: move 2s 1s linear infinite alternate;    }&lt;/style&gt; &lt;div class=&quot;box&quot;&gt;       &lt;div class=&quot;sun&quot;&gt;&lt;/div&gt;       &lt;img src=&quot;img/1.png&quot; alt=&quot;&quot;&gt;       &lt;img src=&quot;img/2.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwi3ufwheig30la0byjul.gif" alt="image"></p><p><strong>3、宇宙</strong></p><blockquote><p>通过定位确定各“星球”的位置，再对每个星球设定单独的动画，形成联动的各大星球。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {        margin: 0;        padding: 0;    }    html,body {         width: 100%;         height: 100%;         background: url(img/bg.jpg) no-repeat;         background-size: cover;         position: relative;    }    .box {        width: 600px;        height: 600px;        border: 1px solid #ccc;        border-radius: 50%;        position: absolute;         left: 50%;        margin-left: -300px;        top: 50%;        margin-top: -300px;    }    .sun {         position: absolute;         width: 50px;         height: 50px;         background-color: orange;         border-radius: 50%;         margin-left: -25px;         left: 50%;         margin-top: -25px;         top: 50%;         box-shadow: 0px 0px 50px orange;    }    .lin1 {         width: 100px;         height: 100px;         border: 1px solid #ccc;         border-radius: 50%;         margin-left: -50px;         margin-top: -50px;         animation: rotate 10s linear infinite;    }    .lin1:after {         content: &quot;&quot;;         width: 20px;         height: 20px;         display: block;         border-radius: 50%;         background-color: orange;         position: absolute;         left: -2px;         top: 10px;    }    .public {         position: absolute;         left: 50%;         top: 50%;    }    @keyframes rotate {         from {            transform: rotateZ(0deg);         }         to {              transform: rotateZ(360deg);         }    }    .lin2 {         width: 150px;         height: 150px;         border: 1px solid #ccc;         border-radius: 50%;         margin-left: -75px;         margin-top: -75px;         animation: rotate 5s linear infinite;    }    .lin2:after {        content: &quot;&quot;;        width: 10px;        height: 10px;        background-color: blue;        display: block;        border-radius: 50%;        position: absolute;        left: 25px;        top: 10px;    }    .lin3 {         width: 230px;         height: 230px;         border: 1px solid #ccc;         border-radius: 50%;         margin-left: -115px;         margin-top: -115px;         animation:  rotate 10s linear infinite;    }    .lin3 span {         width: 20px;         height: 20px;         display: block;         background-color: green;         border-radius: 50%;         position: absolute;         left: 50px;         animation: rotate 5s linear infinite;    }    .lin3 span b {         width: 10px;         height: 10px;         background-color: pink;         display: block;         border-radius: 50%;         position: absolute;         left: 25px;    }    .lin4  {         width: 332px;         height: 332px;         border: 1px solid #ccc;         background: url(img/asteroids_meteorids.png) no-repeat;         border-radius: 50%;         margin-left: -161px;         margin-top: -161px;         animation: rotate 15s linear infinite;    }    .lin4:after {         content: &quot;&quot;;         display: block;         width: 10px;         height: 10px;         background-color: red;         border-radius: 50%;         position: absolute;         left: 120px;    }    .line5 {         width: 450px;         height: 450px;         border: 1px solid #ccc;         border-radius: 50%;         margin-left: -220px;         margin-top: -220px;         animation: rotate 10s linear infinite;    }    .line5 span {         width: 30px;         height: 30px;         background-color: blue;         border-radius: 50%;         display: block;         position: absolute;         left: 120px;    }    .line5 span  b {         display: block;         width: 40px;         height: 40px;         border: 5px solid #ccc;         border-radius: 50%;         transform: skew(45deg);         position: absolute;         left: -6px;         top: -10px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;sun&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;lin1 public&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;lin2 public&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;lin3 public&quot;&gt;            &lt;span&gt;                  &lt;b&gt;&lt;/b&gt;            &lt;/span&gt;      &lt;/div&gt;      &lt;div class=&quot;lin4 public&quot;&gt;&lt;/div&gt;      &lt;div class=&quot;line5 public&quot;&gt;             &lt;span&gt;                   &lt;b&gt;&lt;/b&gt;             &lt;/span&gt;      &lt;/div&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwi49thu86g30i10ho7wh.gif" alt="image"></p><p><strong>4、无缝滚动轮播</strong></p><blockquote><p>结构上与普通的轮播图没有什么区别，定义一个盒子的宽度，宽度为八张图片的总宽度，定义一个动画集，<code>10s</code>内将<code>ul</code>从<code>0</code>的位置移动到盒子的宽度，此时动画集结束，应该是跳到<code>0</code>的位置，循环此动画就会形成无缝滚动。之所以<code>ul</code>下的<code>li</code>定义的是十四张图片，是因为，一开始的时候图片从零的位置向右移动时，如果只有七张图片的时候，右边是空白的，只有完全到达盒子宽的时候，整个图片才会显示完整，用户体验很差，所以需要用到障眼法，就是用<code>14</code>张图片。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;     * {         margin: 0;         padding: 0;         list-style: none;     }     .box {          width: 882px;          height: 84px;          border: 1px solid #ccc;          margin: 50px auto;          overflow: hidden;     }     ul {          width: 1764px;          height: 84px;          float: right;          animation: move 10s linear infinite;     }     li {         float: left;     }     ul:hover {          animation-play-state: paused;     }     @keyframes move {          from {              transform: translateX(0px);          }          to {              transform: translateX(882px);          }     }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;   &lt;ul&gt;       &lt;li&gt;&lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/5.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/6.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;       &lt;li&gt;&lt;img src=&quot;img/7.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;   &lt;/ul&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwi7ohqb7xg30ow02z4j0.gif" alt="image"></p><p><strong>5、进度条</strong></p><blockquote><p>前面已经接触了一个<code>demo</code>，只不过是一个静态的进度条，现在我们通过动画，让他动起来。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;     * {          margin: 0;          padding: 0;     }     html,body {          width: 100%;          height: 100%;          background-color: #ccc;     }     .line {          width: 980px;          height: 40px;          margin: 50px auto;          border-radius: 10px;         background-image: linear-gradient(              135deg,              #fff 25%,              #000 25%,              #000 50%,              #fff 50%,              #fff 75%,              #000 75%,              #000          );         background-size: 40px 40px;         animation: move 2s linear infinite;     }     @keyframes move {          from {              background-position: 0px;          }          to {             background-position: 40px;          }     }&lt;/style&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwi81bla36g30eq02074p.gif" alt="image"></p><p><strong>6、时钟案例</strong></p><blockquote><p>本时钟案例，主要是依赖CSS3中动画以及旋转的概念实现的。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;     * {          margin: 0;          padding: 0;     }     body{         background: #ccc;     }     .box {          width: 300px;          height: 300px;          border: 1px solid #fff;          margin: 100px auto;          border-radius: 50%;          position: relative;     }     .line {          position: absolute;          left: 50%;          margin-left: -1px;          height: 100%;          width: 2px;          background-color: #fff;     }     .line:nth-child(1){     }     /* 设置时刻位置的刻度线 */     .line:nth-child(2) {          transform: rotateZ(30deg);     }     .line:nth-child(3) {          transform: rotateZ(60deg);     }     .line:nth-child(4) {          transform: rotateZ(90deg);     }     .line:nth-child(5) {          transform: rotateZ(120deg);     }     .line:nth-child(6) {          transform: rotateZ(-30deg);     }     .cover {          position: absolute;          left: 50%;          top: 50%;          margin-left: -140px;          margin-top: -140px;          width: 280px;          height: 280px;          background-color: #fff;          border-radius: 50%;     }     /* 设置时针转完一圈所要用的时间为 43200s  */     .h{          width: 6px;          height: 100px;          background-color: #000;          position: absolute;          left: 50%;          top: 40px;          margin-left: -3px;          animation: rotate 43200s linear infinite;     }     /* 设置分针转完一圈所要用的时间为 3600s  */     .m {          width: 4px;          height: 120px;          background-color: #000;          position: absolute;          left: 50%;          top: 20px;          margin-left: -2px;          transform-origin: bottom;          animation: rotate 3600s linear infinite;     }     /* 设置秒针转完一圈所要用的时间为 60s   */     /* steps(60) 表示该动画需要60步完成 */     .s {          width: 2px;          height: 130px;          background-color: orange;          position: absolute;          left: 50%;          top: 10px;          margin-left: -1px;         transform-origin: bottom;          animation: rotate 60s steps(60) infinite;     }     .dotted {          width: 10px;          height: 10px;          background-color: #000;          border-radius: 50%;          position: absolute;          left: 50%;          top: 50%;          margin-left: -5px;          margin-top: -5px;     }     /* 定义旋转角度动画，从0 度旋转到 360度 */     @keyframes rotate {          from {              transform: rotateZ(0deg);          }          to {              transform: rotateZ(360deg);          }     }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;line&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;cover&quot;&gt;        &lt;div class=&quot;h&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;m&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;s&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;dotted&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwi8i1pjs1g308u091weq.gif" alt="image"></p><p><strong>7、魔方案例</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {       margin: 0;       padding: 0;       list-style: none;    }    .box {       width: 400px;       height: 400px;       margin: 150px auto;       /* perspective: 1000px; */       transform-style: preserve-3d;       animation: rotate  5s linear infinite alternate;    }    .box&gt;div {       position: absolute;       width: 100%;       height: 100%;    }    .left {       background-color: transparent;       transform: rotateY(-90deg) translateZ(200px);    }    .right {       background-color: transparent;       transform: rotateY(90deg) translateZ(200px);    }    .top {       background-color: transparent;       transform:  rotateX(90deg)  translateZ(200px);    }    .bottom {       background-color: transparent;       transform: rotateX(-90deg) translateZ(200px);    }    .before {      background-color: transparent;        transform: translateZ(200px);    }    .back {       transform: translateZ(-200px);       background-color: transparent;    }    @keyframes rotate {       0% {       transform: rotateY(0deg)  rotateX(0deg) rotateZ(0deg);       }       50% {        transform: rotateY(30deg)  rotateX(60deg) rotateZ(45deg);       }       75% {           transform: rotateY(80deg)  rotateX(-60deg) rotateZ(-45deg);       }       100% {        transform: rotateY(-45deg)  rotateX(50deg) rotateZ(-35deg);       }    }    li {       width: 120px;       height: 120px;       background-color: green;       float: left;       margin-left: 10px;       margin-top: 10px;       text-align: center;       line-height: 120px;       font-size: 50px;       border-radius: 10px;    }    .left li {       background-color: orange;    }    .right li {       background-color: pink;    }    .top li {       background-color: red;    }    .bottom li {       background-color: yellow;    }    .back li {       background-color: orangered;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;left&quot;&gt;        &lt;ul&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;        &lt;ul&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;        &lt;ul&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;bottom&quot;&gt;        &lt;ul&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;before&quot;&gt;        &lt;ul&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;back&quot;&gt;        &lt;ul&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwib3q819pg30ah0ayn90.gif" alt="image"></p><h2 id="12-伸缩布局"><a href="#12-伸缩布局" class="headerlink" title="12. 伸缩布局"></a>12. 伸缩布局</h2><p><strong>本章节摘自阮一峰老师的《Flex 布局教程》</strong></p><blockquote><p><code>CSS3</code>在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。伸缩布局也叫弹性布局或者<code>flex</code>布局。</p></blockquote><h3 id="12-1-什么是伸缩布局"><a href="#12-1-什么是伸缩布局" class="headerlink" title="12.1 什么是伸缩布局"></a>12.1 什么是伸缩布局</h3><blockquote><p><code>Flex</code>是<code>Flexible Box</code>的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p></blockquote><p><strong>任何一个容器都可以指定为Flex布局。</strong></p><pre><code>.box{  display: flex;}</code></pre><p><strong>行内元素也可以使用Flex布局。</strong></p><pre><code>.box{  display: inline-flex;}</code></pre><p><strong>Webkit内核的浏览器，必须加上-webkit前缀。</strong></p><pre><code>.box{  display: -webkit-flex; /* Safari */  display: flex;}</code></pre><p><em>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</em></p><h3 id="12-2-基本概念"><a href="#12-2-基本概念" class="headerlink" title="12.2 基本概念"></a>12.2 基本概念</h3><p><strong>浏览器兼容性：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwj8tx1l1mj30i704sq4o.jpg" alt="image"></p><p><strong>学习几个新概念：</strong></p><ul><li>主轴：<code>Flex</code>容器的主轴主要用来配置<code>Flex</code>项目，默认是水平方向</li><li>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的</li><li>方向：默认主轴从左向右，侧轴默认从上到下</li><li>主轴和侧轴并不是固定不变的，通过<code>flex-direction</code>可以互换。</li></ul><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwj9c645s3j30g909rjs0.jpg" alt="image"></p><h3 id="12-3-flex-direction属性"><a href="#12-3-flex-direction属性" class="headerlink" title="12.3 flex-direction属性"></a>12.3 flex-direction属性</h3><blockquote><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p></blockquote><pre><code>.box { flex-direction: row | row-reverse | column | column-reverse; }</code></pre><p><strong>参数说明：</strong></p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .block{        width: 100%;        border-radius: 15px;        background: rgba(158,158,158,0.15);        padding: 20px;        box-sizing: border-box;        margin-bottom: 20px;    }    .box{        background: #fff;        display: flex;        margin: 0 0 55px;    }    .box-item {        width: 150px;        height: 150px;        line-height: 150px;        vertical-align: middle;        margin: 5px;        background-color: #ffd200;        font-size: 100px;        color: white;        text-align: center;    }    .box-1-1 {        flex-direction: row;    }    .box-1-2 {        flex-direction: row-reverse;    }    .box-1-3 {        flex-direction: column;    }    .box-1-4 {        flex-direction: column-reverse;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-direction: row 水平向右&lt;/h4&gt;    &lt;div class=&quot;box box-1-1&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-direction: row-reverse 水平向左&lt;/h4&gt;    &lt;div class=&quot;box box-1-2&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-direction: column 垂直向下&lt;/h4&gt;    &lt;div class=&quot;box box-1-3&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-direction: column-reverse 垂直向上&lt;/h4&gt;    &lt;div class=&quot;box box-1-4&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwjb2ni07gj30s51ya76v.jpg" alt="image"></p><h3 id="12-4-flex-wrap-属性"><a href="#12-4-flex-wrap-属性" class="headerlink" title="12.4 flex-wrap 属性"></a>12.4 flex-wrap 属性</h3><blockquote><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p></blockquote><pre><code>.box{    flex-wrap: nowrap | wrap | wrap-reverse; }</code></pre><p><strong>参数说明：</strong></p><ul><li><code>nowrap</code>（默认）：不换行，宽度自动适应；</li><li><code>wrap</code>：换行，第一行在上方；</li><li><code>wrap-reverse</code>：换行，第一行在下方</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .block{        width: 100%;        border-radius: 15px;        background: rgba(158,158,158,0.15);        padding: 20px;        box-sizing: border-box;        margin-bottom: 20px;    }    .box{        background: #fff;        display: flex;        margin: 0 0 55px;    }    .box-item {        width: 150px;        height: 150px;        line-height: 150px;        vertical-align: middle;        margin: 5px;        background-color: #ffd200;        font-size: 100px;        color: white;        text-align: center;    }    .box-2-1 {        flex-wrap: nowrap;    }    .box-2-2 {        flex-wrap: wrap;    }    .box-2-3 {        flex-wrap: wrap-reverse;    }    &lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;nowrap（默认）：不换行。&lt;/h4&gt;    &lt;div class=&quot;box box-2-1&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;wrap：换行，第一行在上方。&lt;/h4&gt;    &lt;div class=&quot;box box-2-2&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;wrap-reverse：换行，第一行在下方。&lt;/h4&gt;    &lt;div class=&quot;box box-2-3&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwjbchnj1oj30s816sq5a.jpg" alt="image"></p><h3 id="12-5-flex-flow-属性"><a href="#12-5-flex-flow-属性" class="headerlink" title="12.5 flex-flow 属性"></a>12.5 flex-flow 属性</h3><blockquote><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p></blockquote><pre><code>.box {  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .block{        width: 100%;        border-radius: 15px;        background: rgba(158,158,158,0.15);        padding: 20px;        box-sizing: border-box;        margin-bottom: 20px;    }    .box{        background: #fff;        display: flex;        margin: 0 0 55px;    }    .box-item {        width: 150px;        height: 150px;        line-height: 150px;        vertical-align: middle;        margin: 5px;        background-color: #ffd200;        font-size: 100px;        color: white;        text-align: center;    }    .box-3{        flex-flow: row wrap;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;row nowrap（默认）：不换行。&lt;/h4&gt;    &lt;div class=&quot;box box-3&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwjbry9b0ij30s80eq3z9.jpg" alt="image"></p><h3 id="12-6-justify-content-属性"><a href="#12-6-justify-content-属性" class="headerlink" title="12.6 justify-content 属性"></a>12.6 justify-content 属性</h3><blockquote><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p></blockquote><pre><code>.box {  justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre><p><strong>参数说明：</strong></p><ul><li><code>flex-start</code>：（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .block{        width: 100%;        border-radius: 15px;        background: rgba(158,158,158,0.15);        padding: 20px;        box-sizing: border-box;        margin-bottom: 20px;    }    .box{        background: #fff;        display: flex;        margin: 0 0 55px;    }    .box-item {        width: 150px;        height: 150px;        line-height: 150px;        vertical-align: middle;        margin: 5px;        background-color: #ffd200;        font-size: 100px;        color: white;        text-align: center;    }    .box-4-1{        justify-content:flex-start;    }    .box-4-2{        justify-content:flex-end;    }    .box-4-3{        justify-content:center;    }    .box-4-4{        justify-content:space-between;    }    .box-4-5{        justify-content:space-around;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-start（默认值）：左对齐&lt;/h4&gt;    &lt;div class=&quot;box box-4-1&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-end：右对齐&lt;/h4&gt;    &lt;div class=&quot;box box-4-2&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;center： 居中&lt;/h4&gt;    &lt;div class=&quot;box box-4-3&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;space-between：两端对齐，项目之间的间隔都相等。&lt;/h4&gt;    &lt;div class=&quot;box box-4-4&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;/h4&gt;    &lt;div class=&quot;box box-4-5&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwjc4l0vafj30s41gnwh6.jpg" alt="image"></p><h3 id="12-7-align-items-属性"><a href="#12-7-align-items-属性" class="headerlink" title="12.7 align-items 属性"></a>12.7 align-items 属性</h3><blockquote><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p></blockquote><pre><code>.box {  align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre><p><strong>参数说明：</strong></p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .block{        width: 100%;        border-radius: 15px;        background: rgba(158,158,158,0.15);        padding: 20px;        box-sizing: border-box;        margin-bottom: 20px;    }    .box{        background: #fff;        display: flex;        margin: 0 0 55px;    }    .box-item {        width: 150px;        height: 150px;        line-height: 150px;        vertical-align: middle;        margin: 5px;        background-color: #ffd200;        font-size: 100px;        color: white;        text-align: center;    }    .item-tall {        height: 400px;        line-height: 400px;    }    .box-5-1 {        align-items: flex-start;    }    .box-5-2 {        align-items: flex-end;    }    .box-5-3 {        align-items: center;    }    .box-5-4{        align-items: baseline;    }    .box-5-4 .box-item{        font-size: 88px;        line-height: initial;        text-decoration: underline;    }    .box-5-4 .item-tall{        font-size: 122px;        line-height: initial;    }    .box-5-5 {        align-items: stretch;    }    .box-5-5 .box-item {        height: auto;}&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-start：交叉轴的起点对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-5-1&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-end：交叉轴的终点对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-5-2&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;center：交叉轴的中点对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-5-3&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;baseline: 项目的第一行文字的基线对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-5-4 line&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。&lt;/h4&gt;    &lt;div class=&quot;box box-5-5&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item item-tall&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwjdlh9i4ij30sa2ey0wv.jpg" alt="image"></p><h3 id="12-8-align-content-属性"><a href="#12-8-align-content-属性" class="headerlink" title="12.8 align-content 属性"></a>12.8 align-content 属性</h3><blockquote><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p></blockquote><pre><code>.box {    align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre><p><strong>参数说明：</strong></p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box-tall {        height: 800px;    }    .box-6-1 {        flex-wrap: wrap;        align-content: flex-start;    }    .box-6-2 {        flex-wrap: wrap;        align-content: flex-end;    }    .box-6-3 {        flex-wrap: wrap;        align-content: center;    }    .box-6-4 {        flex-wrap: wrap;        align-content: space-between    }    .box-6-5 {        flex-wrap: wrap;        align-content: space-around;    }    .box-6-6 {        flex-wrap: wrap;        align-content: stretch;    }    .box-6-6 .box-item {        height: auto;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-start：交叉轴的起点对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-tall box-6-1&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;11&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;12&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;flex-end：与交叉轴的终点对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-tall box-6-2&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;11&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;12&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;center：与交叉轴的中点对齐。&lt;/h4&gt;    &lt;div class=&quot;box box-tall box-6-3&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;11&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;12&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。&lt;/h4&gt;    &lt;div class=&quot;box box-tall box-6-4&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;11&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;12&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。&lt;/h4&gt;    &lt;div class=&quot;box box-tall box-6-5&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;11&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;12&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;stretch（默认值）：轴线占满整个交叉轴。&lt;/h4&gt;    &lt;div class=&quot;box box-tall box-6-6&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;5&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;6&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;7&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;8&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;9&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;10&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;11&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;12&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwjg1n2989j30sa4n2aj2.jpg" alt="image"></p><h3 id="12-9-Order-属性"><a href="#12-9-Order-属性" class="headerlink" title="12.9 Order 属性"></a>12.9 Order 属性</h3><blockquote><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为<code>0</code>。</p></blockquote><pre><code>.item {    order: &lt;integer&gt;; }</code></pre><p><strong>参数说明：</strong></p><ul><li>order属性值是一个数值，可以是正数，也可以是负数，在当前项目里，数值越小，排列越靠前。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box-7 .order {        order: -1;    }    .box-7 .box-item div{        font-size: 14px;        position: relative;        bottom: 90px;        color: #9236f4;    }&lt;/style&gt;&lt;div class=&quot;box box-7&quot;&gt;    &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;    &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;    &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;    &lt;div class=&quot;box-item order&quot;&gt;4 &lt;div&gt;(order:-1)&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwk6pplrb4j30s30acaa8.jpg" alt="image"></p><h3 id="12-10-flex-grow-属性"><a href="#12-10-flex-grow-属性" class="headerlink" title="12.10 flex-grow 属性"></a>12.10 flex-grow 属性</h3><blockquote><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p></blockquote><pre><code>.item {     flex-grow: &lt;number&gt;; /* default 0 */ }</code></pre><p><strong>参数说明：</strong></p><ul><li>如果所有项目的<code>flex-grow</code>属性都为<code>1</code>，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为<code>2</code>，其他项目都为<code>1</code>，则前者占据的剩余空间将比其他项多一倍。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box-8 .box-item div{        font-size: 14px;        position: relative;        bottom: 90px;        color: #9236f4;    }    .box-8 .grow{        flex-grow: 1;        width: auto;    }    .box-8    .grow-2 {        flex-grow: 2;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;div class=&quot;box box-8&quot;&gt;        &lt;div class=&quot;box-item grow&quot;&gt;1 &lt;div&gt;flex-grow: 1&lt;/div&gt;&lt;/div&gt;        &lt;div class=&quot;box-item grow grow-2&quot;&gt;2 &lt;div&gt;flex-grow: 2&lt;/div&gt;&lt;/div&gt;        &lt;div class=&quot;box-item grow&quot;&gt;3 &lt;div&gt;flex-grow: 1&lt;/div&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwk78wnc64j30s10gzwf0.jpg" alt="image"></p><h3 id="12-11-flex-shrink-属性"><a href="#12-11-flex-shrink-属性" class="headerlink" title="12.11 flex-shrink 属性"></a>12.11 flex-shrink 属性</h3><blockquote><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为<code>1</code>，即如果空间不足，该项目将缩小。</p></blockquote><pre><code>.item {    flex-shrink: &lt;number&gt;; /* default 1 */ }</code></pre><p><strong>参数说明：</strong></p><ul><li>如果所有项目的<code>flex-shrink</code>属性都为<code>1</code>，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为<code>0</code>，其他项目都为<code>1</code>，则空间不足时，前者不缩小。</li><li>负值对该属性无效。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box-9 .box-item div{        font-size: 14px;        position: relative;        bottom: 90px;        color: #9236f4;    }    .box-9 .box-item {        width: 400px;    }    .box-9 .shrink{        flex-shrink: 0;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;div class=&quot;box box-9&quot;&gt;        &lt;div class=&quot;box-item shrink&quot;&gt;1 &lt;div&gt;flex-shrink: 0&lt;/div&gt;&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwk7m98a1aj30s50ht0t8.jpg" alt="image"></p><h3 id="12-12-flex-basis-属性"><a href="#12-12-flex-basis-属性" class="headerlink" title="12.12 flex-basis 属性"></a>12.12 flex-basis 属性</h3><blockquote><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（<code>main-size</code>）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p></blockquote><pre><code>.item {     flex-basis: &lt;length&gt;; | auto; /* default auto */ }</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box-10 .box-item {        flex-basis: 200px;        width: 400px; /* width 将失去作用*/    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;&lt;/h4&gt;    &lt;div class=&quot;box box-10&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;3&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwk7s3khnkj30s70f9weu.jpg" alt="image"></p><h3 id="12-13-flex-属性"><a href="#12-13-flex-属性" class="headerlink" title="12.13 flex 属性"></a>12.13 flex 属性</h3><blockquote><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p></blockquote><p>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</p><pre><code>.item {     flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] }</code></pre><h3 id="12-14-align-self-属性"><a href="#12-14-align-self-属性" class="headerlink" title="12.14 align-self 属性"></a>12.14 align-self 属性</h3><blockquote><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p></blockquote><pre><code>.item {    align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre><p><strong>参数说明：</strong></p><ul><li><code>auto</code>：表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</li><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为<code>auto</code>，将占满整个容器的高度。</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box-11 {        height: 400px;    }    .box-11 .box-item {        align-self: flex-start;    }    .box-11 .box-item div{        font-size: 14px;        position: relative;        bottom: 90px;        color: #9236f4;    }    .box-11 .end {        align-self: flex-end;    }&lt;/style&gt;&lt;div class=&quot;block&quot;&gt;    &lt;h4&gt;stretch（默认值）：轴线占满整个交叉轴。&lt;/h4&gt;    &lt;div class=&quot;box box-11&quot;&gt;        &lt;div class=&quot;box-item&quot;&gt;1&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;2&lt;/div&gt;        &lt;div class=&quot;box-item end&quot;&gt;3&lt;div&gt;flex-end&lt;/div&gt;&lt;/div&gt;        &lt;div class=&quot;box-item&quot;&gt;4&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fwk8ceh394j30s90mcgm8.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5入门详解</title>
      <link href="/2018/11/28/html5-ru-men-xiang-jie/"/>
      <url>/2018/11/28/html5-ru-men-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="1-认识HTML5"><a href="#1-认识HTML5" class="headerlink" title="1. 认识HTML5"></a>1. 认识HTML5</h2><blockquote><p><code>HTML5</code>并不仅仅只是作为<code>HTML</code>标记语言的一个最新版本，更重要的是它制定了<code>Web</code>应用开发的一系列标准，成为第一个将<code>Web</code>做为应用开发平台的<code>HTML</code>语言。</p></blockquote><p><code>HTML5</code>定义了一系列新元素，如新语义标签、智能表单、多媒体标签等，可以帮助开发者创建富互联网应用，还提供了一系列<code>Javascript API</code>，如地理定位、重力感应、硬件访问等，可以在浏览器内实现类原生应用，甚至结合<code>Canvas</code>我们可开发网页版游戏，同时结合<code>CSS3</code>的过渡、转换、动画等特性，可以极大的增强用户体验，提升开发功能的可应用性。</p><p><em>我们日常讨论的H5其实是一个泛称，它指的是由HTML5 + CSS3 + Javascript等技术组合而成的一个应用开发平台。</em></p><h2 id="2-语法规范"><a href="#2-语法规范" class="headerlink" title="2. 语法规范"></a>2. 语法规范</h2><blockquote><p>随着<code>Web</code>技术的更新，<code>HTML</code>也先后经历了<code>HTML4.01</code>、<code>XHTML1.0</code>、<code>HTML5</code>几个重要的版本，在版本的演变过程中新增或废弃了一些属性，同时对语法规范也做了一些调整，为了能够保证浏览器可以兼容不同版本语法规范的，我们可以使用<code>&lt;!DOCTYPE&gt;</code>指示浏览器应该如何处理我们的<code>HTML</code>。</p></blockquote><p><strong>常用的DOCTYPE声明：</strong></p><p><strong>1、HTML5</strong></p><pre><code>&lt;!DOCTYPE html&gt;</code></pre><p><strong>2、HTML 4.01 Strict</strong></p><blockquote><p>4.01的严格版本，该<code>DTD</code>包含所有<code>HTML</code>元素和属性，但不包括展示性的和弃用的元素（比如<code>font</code>）。<code>不允许</code>框架集（<code>Framesets</code>）。</p></blockquote><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</code></pre><p><strong>3、HTML 4.01 Transitional</strong></p><blockquote><p>该<code>DTD</code>包含所有<code>HTML</code>元素和属性，包括展示性的和弃用的元素（比如<code>font</code>）。不允许框架集（<code>Framesets</code>）。</p></blockquote><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</code></pre><p><strong>4、HTML 4.01 Frameset</strong></p><blockquote><p>该<code>DTD</code>等同于<code>HTML 4.01 Transitional</code>，但允许框架集内容。</p></blockquote><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</code></pre><p><strong>5、XHTML 1.0 Strict</strong></p><blockquote><p>该<code>DTD</code>包含所有<code>HTML</code>元素和属性，但不包括展示性的和弃用的元素（比如<code>font</code>）。不允许框架集（<code>Framesets</code>）。必须以格式正确的<code>XML</code>来编写标记。</p></blockquote><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</code></pre><p><strong>6、XHTML 1.0 Transitional</strong></p><blockquote><p>该<code>DTD</code>包含所有<code>HTML</code>元素和属性，包括展示性的和弃用的元素（比如<code>font</code>）。不允许框架集（<code>Framesets</code>）。必须以格式正确的<code>XML</code>来编写标记。</p></blockquote><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></pre><p><strong>7、XHTML 1.0 Frameset</strong></p><blockquote><p>该<code>DTD</code>等同于<code>XHTML 1.0 Transitional</code>，但允许框架集内容。</p></blockquote><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</code></pre><p><strong>8、XHTML 1.1</strong></p><blockquote><p>该<code>DTD</code>等同于<code>XHTML 1.0 Strict</code>，但允许添加模型（例如提供对东亚语系的<code>ruby</code>支持）。</p></blockquote><pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;</code></pre><h2 id="3-语义化标签"><a href="#3-语义化标签" class="headerlink" title="3. 语义化标签"></a>3. 语义化标签</h2><blockquote><p><code>HTML5</code>提供了新的元素来创建更好的页面结构：</p></blockquote><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;article&gt;</code></td><td>定义页面独立的内容区域（文章）。</td></tr><tr><td><code>&lt;aside&gt;</code></td><td>定义页面的侧边栏内容（侧边栏）。</td></tr><tr><td><code>&lt;bdi&gt;</code></td><td>允许您设置一段文本，使其脱离其父元素的文本方向设置。</td></tr><tr><td><code>&lt;command&gt;</code></td><td>定义命令按钮，比如单选按钮、复选框或按钮</td></tr><tr><td><code>&lt;details&gt;</code></td><td>用于描述文档或文档某个部分的细节</td></tr><tr><td><code>&lt;dialog&gt;</code></td><td>定义对话框，比如提示框</td></tr><tr><td><code>&lt;summary&gt;</code></td><td>标签包含<code>details</code>元素的标题</td></tr><tr><td><code>&lt;figure&gt;</code></td><td>规定独立的流内容（图像、图表、照片、代码等等）。</td></tr><tr><td><code>&lt;figcaption&gt;</code></td><td>定义<code>&lt;figure&gt;</code>元素的标题</td></tr><tr><td><code>&lt;footer&gt;</code></td><td>定义<code>section</code>或<code>document</code>的页脚。</td></tr><tr><td><code>&lt;header&gt;</code></td><td>定义了文档的头部区域</td></tr><tr><td><code>&lt;mark&gt;</code></td><td>定义带有记号的文本。</td></tr><tr><td><code>&lt;meter&gt;</code></td><td>定义度量衡。仅用于已知最大和最小值的度量。</td></tr><tr><td><code>&lt;nav&gt;</code></td><td>定义导航链接的部分。</td></tr><tr><td><code>&lt;progress&gt;</code></td><td>定义任何类型的任务的进度。</td></tr><tr><td><code>&lt;ruby&gt;</code></td><td>定义<code>ruby</code>注释（中文注音或字符）。</td></tr><tr><td><code>&lt;rt&gt;</code></td><td>定义字符（中文注音或字符）的解释或发音。</td></tr><tr><td><code>&lt;rp&gt;</code></td><td>在<code>ruby</code>注释中使用，定义不支持<code>ruby</code>元素的浏览器所显示的内容。</td></tr><tr><td><code>&lt;section&gt;</code></td><td>定义文档中的节（<code>section</code>、区段）。</td></tr><tr><td><code>&lt;time&gt;</code></td><td>定义日期或时间。</td></tr><tr><td><code>&lt;wbr&gt;</code></td><td>规定在文本中的何处适合添加换行符。</td></tr></tbody></table><p>本质上新语义标签与<code>&lt;div&gt;</code>、<code>&lt;span&gt;</code>没有区别，只是其具有语义性，使用时除了在<code>HTML</code>结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成<code>&lt;div class=&quot;nav&quot;&gt;</code>相当于<code>&lt;nav&gt;</code>。不要好奇，它只是一个标签！</p><p><em>尽量避免全局使用header、footer、aside等语义标签。</em></p><h2 id="4-HTML5-浏览器支持"><a href="#4-HTML5-浏览器支持" class="headerlink" title="4. HTML5 浏览器支持"></a>4. HTML5 浏览器支持</h2><blockquote><p>对于目前主流的浏览器来说，都已经支持<code>HTML5</code>了，但是到了<code>Internet Explorer 9</code>，<code>IE</code>才开始支持<code>HTML5</code>，对于之前的旧版本，我们就需要考虑到兼容性问题。</p></blockquote><p><strong>1、将 HTML5 元素定义为块元素</strong></p><blockquote><p><code>HTML5</code> 新增了几个具有语义化的标签，这些标签都是块级元素，在不支持<code>HTML5</code>新标签的浏览器里，会将这些新的标签解析成行内元素(<code>inline</code>)对待，所以我们只需要在初始化的时候将其转换成块元素(<code>block</code>)即可使用。</p></blockquote><pre><code>header, section, footer, aside, nav, main, article, figure {    display: block; }</code></pre><p><strong>2、通过 js 动态创建标签</strong></p><blockquote><p>在<code>IE9</code>版本以下，并不能正常解析这些新标签，但是却可以识别通过<code>document.createElement(&#39;tagName&#39;)</code>创建的自定义标签，于是我们的解决方案就是将<code>HTML5</code>的新标签全部通过<code>document.createElement(&#39;tagName&#39;)</code>来创建一遍，这样<code>IE</code>低版本也能正常解析<code>HTML5</code>新标签了。</p></blockquote><pre><code>&lt;style&gt;    header,section,nav...{        display:block;    }&lt;/style&gt;&lt;script type=&quot;text/javascript&quot;&gt;      document.createElement(&quot;header&quot;);      document.createElement(&quot;section&quot;);      document.createElement(&quot;nav&quot;);                 .                 .                 .&lt;/script&gt;</code></pre><p><em>注意：通过document.createElement创建出来的标签时行内元素，所以同样的需要将它们转换成块级元素。</em></p><p><strong>3、Shiv 解决方案</strong></p><blockquote><p>在实际开发中我们更多采用的是通过检测<code>IE</code>浏览器的版本来加载第三方的一个<code>JS</code>库来解决兼容问题，这个库文件会帮自动通过<code>document.createElement(&#39;tagName&#39;)</code>创建所有<code>HTML5</code>的新标签。针对<code>IE</code>浏览器<code>html5shiv</code>是比较好的解决方案。<code>html5shiv</code>主要解决<code>HTML5</code>提出的新的元素不被<code>IE6-8</code>识别，这些新元素不能作为父节点包裹子元素，并且不能应用<code>CSS</code>样式的问题。</p></blockquote><p><strong>引入本地html5shiv.min.js文件：</strong></p><pre><code>&lt;!--[if lte IE 8]&gt;     &lt;script type=&quot;text/javascript&quot; src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</code></pre><p><code>lte</code>：表示小于等于；当浏览器版本小于等于<code>IE8</code>的时候，引用<code>html5shiv.min.js</code>文件。</p><p><strong>引入远程静态资源库：</strong></p><pre><code>&lt;!--[if lte IE 8]&gt;  &lt;script src=&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;</code></pre><p><em>以上的注释代码只有在IE浏览器下次才会识别里面的内容，其他浏览器直接当注释识别。</em></p><p><strong>完整示例代码：</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;兼容性处理&lt;/title&gt;&lt;!--[if lte IE 8]&gt;  &lt;script src=&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我正在处理兼容性&lt;/h1&gt;&lt;article&gt;我在IE下也能显示&lt;/article&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><em>注意：html5shiv.js引用代码必须放在<head><meta name="generator" content="Hexo 3.8.0">元素中，因为IE浏览器在解析HTML5新元素时需要先加载该文件。<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></em></p><h2 id="5-表单"><a href="#5-表单" class="headerlink" title="5. 表单"></a>5. 表单</h2><blockquote><p>伴随着互联网富应用以及移动开发的兴起，传统的<code>Web</code>表单已经越来越不能满足开发的需求，所以<code>HTML5</code>在<code>Web</code>表单方向也做了很大的改进，如拾色器、日期/时间组件等，使表单处理变的更加高效。</p></blockquote><h3 id="5-1-表单控件"><a href="#5-1-表单控件" class="headerlink" title="5.1 表单控件"></a>5.1 表单控件</h3><blockquote><p><code>html5</code>中新增的一些表单控件，例如<code>email</code>属性的输入框，它可以检测你的输入内容是否符合一个邮箱的格式，自动进行表单校验。</p></blockquote><p><strong>1、表单域：form</strong></p><blockquote><p>我们都知道<code>&lt;form&gt;</code>标签用于为用户输入创建<code>HTML</code>表单。表单能够包含<code>input</code>元素，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含<code>menus</code>、<code>textarea</code>、<code>fieldset</code>、<code>legend</code>和<code>label</code>元素。</p></blockquote><p><em>表单用于向服务器传输数据。</em></p><p>在<code>html5</code>中<code>&lt;form&gt;</code>表单域添加了两个新的属性：”<code>autocomplete: no/yes</code>“、”<code>novalidate</code>“：</p><ul><li><code>autocomplete</code>：规定是否启用表单的自动完成功能，默认<code>on</code>。（<em>自动完成允许浏览器预测对字段的输入。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。</em>）。</li><li><code>novalidate</code>：如果使用该属性，则提交表单时不进行验证（关闭控件自动校验功能）。</li></ul><p><strong>2、邮箱：email</strong></p><pre><code>&lt;form&gt;    邮箱：&lt;input type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47gpivj20a4028dfo.jpg" alt="image"></p><p><strong>3、网址：url</strong></p><blockquote><p>协议、域名都要输入进去（<code>https://www.baidu.com</code>，如果直接<code>www.baidu.com</code>会提示输入错误的），否则触发表单校验。</p></blockquote><pre><code>&lt;form&gt;    网址：&lt;input type=&quot;url&quot; name=&quot;url&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47iw7yj207002d743.jpg" alt="image"></p><p><strong>4、数字：number</strong></p><blockquote><p>输入表单数<code>number</code>属性的时候，在表单尾部会有一个上下的箭头，用来选择数字。另外表单里的<code>step</code>属性表示：点击的时候每一次增加或减少的步数；<code>max</code>属性表示：增加到的最大范围，<code>min</code>属性表示减小到的最小范围。</p></blockquote><pre><code>&lt;form&gt;    年龄：&lt;input type=&quot;number&quot; name=&quot;&quot; step=&quot;3&quot; max=&quot;120&quot; &gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47gemlj206z017gld.jpg" alt="image"></p><p><strong>5、电话号码：tel</strong></p><pre><code>&lt;form&gt;     电话号码： &lt;input type=&quot;tel&quot; name=&quot;tel&quot;&gt;&lt;/form&gt;</code></pre><p><strong>6、颜色：color</strong></p><pre><code>&lt;form&gt;    邮箱：&lt;input type=&quot;color&quot; name=&quot;color&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47gysvj20hw0bojro.jpg" alt="image"></p><p><strong>7、时间：time</strong></p><pre><code>&lt;form&gt;     时间：&lt;input type=&quot;time&quot; name=&quot;time&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47ijvuj205s016a9t.jpg" alt="image"></p><p><strong>8、日期：date</strong></p><pre><code>&lt;form&gt;     日期： &lt;input type=&quot;date&quot; name=&quot;date&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47fpf9j209t066glk.jpg" alt="image"></p><p><strong>9、时间日期：datetime</strong></p><pre><code>&lt;form&gt;     时间日期： &lt;input type=&quot;datetime&quot; name=&quot;datetime&quot;&gt;&lt;/form&gt;</code></pre><p><strong>10、周：week</strong></p><pre><code>&lt;form&gt;     周： &lt;input type=&quot;week&quot; name=&quot;week&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47jppaj20a7063t8o.jpg" alt="image"></p><p><strong>11、月：month</strong></p><pre><code>&lt;form&gt;     月： &lt;input type=&quot;month&quot; name=&quot;month&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47gotfj208x069t8n.jpg" alt="image"></p><p><strong>12、滑块：range</strong></p><blockquote><p><code>max</code>：规定允许的最大值，<code>min</code>：规定允许的最小值。</p></blockquote><pre><code>&lt;form&gt;    滑块： &lt;input type=&quot;range&quot; name=&quot;range&quot; min=&quot;1&quot; max=&quot;20&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpej47gotgj206a01m0rv.jpg" alt="image"></p><h3 id="5-2-表单元素"><a href="#5-2-表单元素" class="headerlink" title="5.2 表单元素"></a>5.2 表单元素</h3><blockquote><p>不是所有浏览器都支持<code>HTML5</code>新的表单元素的，但是不影响使用，即使不支持仍然可以显示常规的表单。</p></blockquote><p><strong>1、datalist</strong></p><blockquote><p>在<code>Web</code>设计中,经常会用到如输入框的自动下拉提示,这将大大方便用户的输入。在以前，如果要实现这样的功能，必须要求开发者使用一些<code>Javascript</code>的技巧或相关的框架进行<code>ajax</code>调用，需要一定的编程工作量。但随着<code>HTML5</code>的慢慢普及，开发者可以使用其中的新的<code>DataList</code>标记就能快速开发出十分漂亮的<code>AutoComplete</code>组件的效果。</p></blockquote><p><code>datalist</code>有点类似于<code>select</code>下拉菜单，<code>datalist</code>元素规定输入域的选项列表。列表是通过<code>datalist</code>内的 <code>option</code>元素创建的。如需把<code>datalist</code>绑定到输入域，请用输入域的<code>list</code>属性引用<code>datalist</code>的<code>id</code>：</p><pre><code>&lt;p&gt;    浏览器版本：&lt;input list=&quot;words&quot;&gt;&lt;/p&gt;&lt;datalist id=&quot;words&quot;&gt;    &lt;option value=&quot;Internet Explorer&quot;&gt;    &lt;option value=&quot;Firefox&quot;&gt;    &lt;option value=&quot;Chrome&quot;&gt;    &lt;option value=&quot;Opera&quot;&gt;    &lt;option value=&quot;Safari&quot;&gt;    &lt;option value=&quot;Sogou&quot;&gt;    &lt;option value=&quot;Maxthon&quot;&gt;&lt;/datalist&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpem55axuzg208t05gaa4.gif" alt="image"></p><h3 id="5-3-表单属性"><a href="#5-3-表单属性" class="headerlink" title="5.3 表单属性"></a>5.3 表单属性</h3><blockquote><p>在<code>HTML5</code>中， <code>&lt;form&gt;</code>和<code>&lt;input&gt;</code>标签添加了几个新属性。其中<code>&lt;form&gt;</code>标签的<code>autocomplete</code>、<code>novalidate</code>属性，我们在上面都讲过了，现在我们来看看<code>&lt;input&gt;</code>提供了哪些新的属性。</p></blockquote><p><strong>1、autocomplete 自动完成</strong></p><blockquote><p><code>autocomplete</code>属性规定<code>form</code>或<code>input</code>域应该拥有自动完成功能。当用户在自动完成域中开始输入时，浏览器应该在该域中显示填写的选项。</p></blockquote><p><strong>提示：</strong><code>autocomplete</code>属性有可能在<code>form</code>元素中默认是开启的，而在<code>input</code>元素中是关闭的。需要手动添加”<code>on</code>“。</p><p>示例代码：</p><pre><code>&lt;input type=&quot;text&quot; autocomplete=&quot;on&quot;&gt;</code></pre><p><strong>2、placeholder 占位符</strong></p><blockquote><p><code>placeholder</code>属性提供一种提示（<code>hint</code>），描述输入域所期待的值。简短的提示在用户输入值前会显示在输入域上。</p></blockquote><p>示例代码：</p><pre><code>用户名：&lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot;&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpen4pjsafj207q00umwx.jpg" alt="image"></p><p><strong>3、autofocus 自动获得焦点</strong></p><blockquote><p><code>autofocus</code>属性是一个<code>boolean</code>属性。<code>autofocus</code>属性规定在页面加载时，域自动地获得焦点。</p></blockquote><p>示例代码：</p><pre><code>用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; autofocus&gt;</code></pre><p><strong>4、multiple 多文件上传</strong></p><blockquote><p><code>multiple</code>属性是一个<code>boolean</code>属性。<code>multiple</code>属性规定<code>&lt;input&gt;</code>元素中可选择多个值。</p></blockquote><p>示例代码：</p><pre><code>&lt;form action=&quot;xxx.php&quot;&gt;  选择图片: &lt;input type=&quot;file&quot; name=&quot;img&quot; multiple&gt;  &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><p><em>此时上传文件时就可以同时上传多个文件了。</em></p><p><strong>5、form 绑定输入域</strong></p><blockquote><p>当一个输入表单<code>input</code>，不在一个表单域<code>form</code>中的时候。通过<code>form</code>属性和表单域的<code>id</code>可以将输入表单绑定到表单域中。</p></blockquote><p>示例代码：</p><pre><code>&lt;form action=&quot;xxx.php&quot; id=&quot;form1&quot;&gt;    用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;    密码: &lt;input type=&quot;text&quot; name=&quot;pwd&quot; form=&quot;form1&quot;&gt;</code></pre><p><em>点击提交按钮，表单域外部的“密码”输入框内容也会提交。</em></p><p><strong>6、required 必填项</strong></p><blockquote><p><code>required</code>属性是一个<code>boolean</code>属性。<code>required</code>属性规定必须在提交之前填写输入域（不能为空）。</p></blockquote><p>示例代码：</p><pre><code>用户名: &lt;input type=&quot;text&quot; name=&quot;usrname&quot; required&gt;</code></pre><p><strong>7、pattern 自定义验证</strong></p><blockquote><p><code>pattern</code>属性描述了自定义一个正则表达式用于验证<code>&lt;input&gt;</code>元素的值。</p></blockquote><p>示例代码：</p><pre><code>&lt;form action=&quot;&quot;&gt;    用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot; pattern=&quot;[A-Za-z]{3}&quot; title=&quot;三位英文字母&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><p>效果图：</p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpeo2q76vjj208d02w0sm.jpg" alt="image"></p><h3 id="5-4-表单事件"><a href="#5-4-表单事件" class="headerlink" title="5.4 表单事件"></a>5.4 表单事件</h3><blockquote><p>这里给大家介绍两个表单事件<code>oninput</code>：用户输入的时候触发的事件；<code>oninvalid</code>：表单验证无法通过时候触发的事件</p></blockquote><p><strong>示例代码：</strong></p><pre><code>&lt;form action=&quot;&quot;&gt;    用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;user&quot;&gt;    &lt;!-- 限定密码格式只能是数字 --&gt;    密 码： &lt;input type=&quot;text&quot; name=&quot;pwd&quot; id=&quot;pwd&quot; pattern=&quot;\d+&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var user = document.getElementById(&#39;user&#39;);    var pwd = document.getElementById(&#39;pwd&#39;);    // 用户输入的时候触发    user.oninput = function(){        alert(1);    }    // 验证无法通过的时候触发    pwd.oninvalid = function(){        alert(2);    }&lt;/script&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpeouepfkgg20h206xt9h.gif" alt="image"></p><p><strong>当验证无法通过的时候，可以通过setCustomValidity方法添加或修改提示内容：</strong></p><pre><code>pwd.oninvalid = function(){    this.setCustomValidity(&quot;密码格式错误&quot;); }</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpeoyljuocj205702j3yb.jpg" alt="image"></p><h3 id="5-5-表单样式"><a href="#5-5-表单样式" class="headerlink" title="5.5 表单样式"></a>5.5 表单样式</h3><blockquote><p>这里主要是说下如何修改<code>placeholder</code>的默认样式。</p></blockquote><ul><li>火狐： <code>input::-moz-placeholder{}</code></li><li>谷歌： <code>input::-webkit-input-placeholder {}</code></li></ul><p><em>通过双伪元素选择器，即可改变placeholder文字的样式。</em></p><h2 id="6-多媒体标签"><a href="#6-多媒体标签" class="headerlink" title="6. 多媒体标签"></a>6. 多媒体标签</h2><blockquote><p>在<code>HTML5</code>之前，在网页上播放音频/视频的通用方法是利用<code>Flash</code>来播放，但是大多情况下，并非所有用户的浏览器都安装了<code>Flash</code>插件，由此使得处理音频/视频播放变的非常复杂，并且移动设备的浏览器并不支持<code>Flash</code>插件。</p></blockquote><h3 id="6-1-音频"><a href="#6-1-音频" class="headerlink" title="6.1 音频"></a>6.1 音频</h3><blockquote><p><code>HTML5</code>通过<code>&lt;audio&gt;</code>标签来解决音频播放的问题。</p></blockquote><p><strong>示例代码：</strong></p><pre><code>&lt;!-- 通过src指定音频文件路径即可 --&gt;&lt;audio src=&quot;./xxx.mp3&quot;&gt;&lt;/audio&gt;</code></pre><p><strong>播放格式</strong></p><blockquote><p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考：</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpeq7i03ulj20k1044glk.jpg" alt="image"></p><p><strong>处理兼容性</strong></p><blockquote><p>在<code>&lt;audio&gt;</code>与<code>&lt;/audio&gt;</code>之间你需要插入浏览器不支持的<code>&lt;audio&gt;</code>元素的提示文本 。<code>&lt;audio&gt;</code>元素允许使用多个 <code>&lt;source&gt;</code>元素。<code>&lt;source&gt;</code> 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件。</p></blockquote><pre><code>&lt;audio&gt;    &lt;!-- 通过source标签指定多格式音频文件 --&gt;    &lt;source src=&quot;xxx.ogg&quot; type=&quot;audio/ogg&quot;&gt;    &lt;source src=&quot;xxx.mp3&quot; type=&quot;audio/mpeg&quot;&gt;    &lt;source src=&quot;xxx.wav&quot; type=&quot;audio/wav&quot;&gt;    您的浏览器不支持 audio 元素。&lt;/audio&gt;</code></pre><p><strong>音频控制属性</strong></p><blockquote><p>通过附加属性可以更友好控制音频的播放.</p></blockquote><ul><li><code>autoplay</code> 自动播放</li><li><code>controls</code> 是否显示控制条</li><li><code>loop</code> 循环播放</li></ul><h3 id="6-2-视频"><a href="#6-2-视频" class="headerlink" title="6.2 视频"></a>6.2 视频</h3><blockquote><p><code>HTML5</code>通过<code>&lt;video&gt;</code>标签来解决音频播放的问题。</p></blockquote><p><strong>示例代码：</strong></p><pre><code>&lt;!-- 通过src指定视频文件路径即可 --&gt;&lt;video src=&quot;./xxx.mp4&quot;&gt;&lt;/video&gt;</code></pre><p><strong>播放格式</strong></p><blockquote><p>由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考:</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/9c47d583gy1fpeqv5sf43j20k8045gll.jpg" alt="image"></p><p><strong>处理兼容性</strong></p><pre><code>&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt;    &lt;source src=&quot;xxx.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;source src=&quot;xxx.ogg&quot; type=&quot;video/ogg&quot;&gt;    您的浏览器不支持Video标签。&lt;/video&gt;</code></pre><h3 id="6-3-音频-视频方法"><a href="#6-3-音频-视频方法" class="headerlink" title="6.3 音频/视频方法"></a>6.3 音频/视频方法</h3><blockquote><p>通过附加属性可以更加友好的控制音频、视频的播放。</p></blockquote><p><strong>1、autoplay 自动播放</strong></p><blockquote><p><code>autoplay</code>属性设置或返回音视频是否在加载后即开始播放。</p></blockquote><p>设置<code>autoplay</code>属性：</p><pre><code>audio|video.autoplay=true|false</code></pre><p>返回<code>autoplay</code>属性：</p><pre><code>audio|video.autoplay</code></pre><p>启用自动播放，并重载视频：</p><pre><code>var video=document.getElementById(&quot;video1&quot;);video.autoplay = true;video.load();</code></pre><p><strong>2、buffered 已缓冲部分</strong></p><blockquote><p><code>buffered</code>属性返回<code>TimeRanges</code>对象。<code>TimeRanges</code>对象表示用户的音视频缓冲范围。缓冲范围指的是已缓冲音视频的时间范围。如果用户在音视频中跳跃播放，会得到多个缓冲范围。</p></blockquote><p><strong>返回值：</strong></p><blockquote><p><code>TimeRanges</code>对象，表示音视频的已缓冲部分。</p></blockquote><p><code>TimeRanges</code>对象属性：</p><ul><li><code>length</code> - 获得音视频中已缓冲范围的数量</li><li><code>start(index)</code> - 获得某个已缓冲范围的开始位置</li><li><code>end(index)</code> - 获得某个已缓冲范围的结束位置</li></ul><p><em>注意：首个缓冲范围的下标是0。</em></p><p><strong>示例代码：</strong></p><p>获得视频的第一段缓冲范围（部分），以秒计：</p><pre><code>var video = document.getElementById(&quot;video1&quot;);alert(&quot;Start: &quot; + video.buffered.start(0) + &quot; End: &quot; + video.buffered.end(0));</code></pre><p><strong>3、controls 是否显示控制条</strong></p><blockquote><p><code>controls</code>属性设置或返回浏览器应当显示标准的音视频控件。</p></blockquote><p>设置<code>controls</code>属性：</p><pre><code>audio|video.controls=true|false</code></pre><p>返回<code>controls</code>属性：</p><pre><code>audio|video.controls</code></pre><p>启用视频控件：</p><pre><code>var video = document.getElementById(&quot;video1&quot;);video.controls = true;</code></pre><p><strong>4、currentSrc 返回当前资源的URL</strong></p><blockquote><p><code>currentSrc</code>熟悉返回当前音频/视频的<code>URL</code>。如果未设置音频/视频，则返回空字符串。</p></blockquote><p>获得当前视频的<code>URL</code>：</p><pre><code>video = document.getElementById(&quot;video1&quot;);alert(video.currentSrc);</code></pre><p><strong>5、currentTime 当前播放位置（时间s）</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>autoplay</code></td><td>资源加载完成后自动播放视频或音频</td></tr><tr><td><code>buffered</code></td><td>返回表示音频/视频已缓冲部分的<code>TimeRanges</code>对象</td></tr><tr><td><code>controls</code></td><td>是否显示控制条</td></tr><tr><td><code>currentSrc</code></td><td>返回当前音频/视频的<code>URL</code></td></tr><tr><td><code>currentTime</code></td><td>设置或返回音频/视频中的当前播放位置（以秒计）</td></tr><tr><td><code>defaultMuted</code></td><td>设置或返回音频/视频默认是否静音</td></tr><tr><td><code>defaultPlaybackRate</code></td><td>设置或返回音频/视频的默认播放速度</td></tr><tr><td><code>duration</code></td><td>返回当前音频/视频的长度（以秒计）</td></tr><tr><td><code>ended</code></td><td>返回音频/视频的播放是否已结束</td></tr><tr><td><code>error</code></td><td>返回表示音频/视频错误状态的<code>MediaError</code>对象</td></tr><tr><td><code>loop</code></td><td>设置或返回音频/视频是否应在结束时重新播放</td></tr><tr><td><code>mediaGroup</code></td><td>设置或返回音频/视频所属的组合（用于连接多个音频/视频元素）</td></tr><tr><td><code>muted</code></td><td>设置或返回音频/视频是否静音</td></tr><tr><td><code>networkState</code></td><td>返回音频/视频的当前网络状态</td></tr><tr><td><code>paused</code></td><td>设置或返回音频/视频是否暂停</td></tr><tr><td><code>playbackRate</code></td><td>设置或返回音频/视频播放的速度</td></tr><tr><td><code>played</code></td><td>返回表示音频/视频已播放部分的<code>TimeRanges</code>对象</td></tr><tr><td><code>preload</code></td><td>设置或返回音频/视频是否应该在页面加载后进行加载</td></tr><tr><td><code>readyState</code></td><td>返回音频/视频当前的就绪状态</td></tr><tr><td><code>seekable</code></td><td>返回表示音频/视频可寻址部分的<code>TimeRanges</code>对象</td></tr><tr><td><code>seeking</code></td><td>返回用户是否正在音频/视频中进行查找</td></tr><tr><td><code>src</code></td><td>设置或返回音频/视频元素的当前来源</td></tr><tr><td><code>startDate</code></td><td>返回表示当前时间偏移的<code>Date</code>对象</td></tr><tr><td><code>textTracks</code></td><td>返回表示可用文本轨道的<code>TextTrackList</code>对象</td></tr><tr><td><code>videoTracks</code></td><td>返回表示可用视频轨道的<code>VideoTrackList</code>对象</td></tr><tr><td><code>volume</code></td><td>设置或返回音频/视频的音量</td></tr></tbody></table><h2 id="7-DOM-扩展"><a href="#7-DOM-扩展" class="headerlink" title="7. DOM 扩展"></a>7. DOM 扩展</h2><h3 id="7-1-获取元素"><a href="#7-1-获取元素" class="headerlink" title="7.1 获取元素"></a>7.1 获取元素</h3><blockquote><p><code>html5</code>中新添了两个查找元素的属性，分别是：<code>querySelector</code>，<code>querySelectorAll</code>。</p></blockquote><pre><code>&lt;ul&gt;     &lt;li class=&quot;one&quot;&gt;&lt;a href=&quot;#&quot;&gt;文字1&lt;/a&gt;&lt;/li&gt;     &lt;li class=&quot;two&quot;&gt;&lt;a href=&quot;#&quot;&gt;文字2&lt;/a&gt;&lt;/li&gt;     &lt;li class=&quot;three&quot;&gt;&lt;a href=&quot;#&quot;&gt;文字3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script type=&quot;text/javascript&quot;&gt;    //获取元素的方式    var a= document.querySelector(&quot;.one a&quot;);    a.style.color=&quot;red&quot;;    //通过该方式可以将所有对应的元素选中 返回的是一个伪数组    var a1= document.querySelectorAll(&quot;a&quot;);  &lt;/script&gt;</code></pre><h3 id="7-2-类名操作"><a href="#7-2-类名操作" class="headerlink" title="7.2 类名操作"></a>7.2 类名操作</h3><blockquote><p><code>html5</code>中新添加了一个操作类名的对象：<code>classList</code>。我们可以通过它里面的方法对元素的类进行操作。</p></blockquote><p><strong>1、添加类（add）</strong></p><blockquote><p>添加类的时候，获取到元素之后，通过<code>classList</code>的<code>add</code>方法添加一个类名，但是一次只能添加一个类名，否则会报错。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .bgc {        width: 300px;        height: 300px;        background-color: pink;    }    .fonts{        font-size: 26px;    }&lt;/style&gt;&lt;div&gt;文字&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;      var div=document.querySelector(&quot;div&quot;);          // 添加样式 只能单独添加          div.classList.add(&quot;bgc&quot;);            div.classList.add(&quot;fonts&quot;);&lt;/script&gt;</code></pre><p><strong>2、移除类（remove）</strong></p><blockquote><p>移除类的时候，获取到元素之后，通过<code>classList</code>的<code>remove</code>方法移除一个类名。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .bgc {        width: 300px;        height: 300px;        background-color: pink;    }    .fonts{        font-size: 26px;    }&lt;/style&gt;&lt;div class=&quot;bgc fonts&quot;&gt;文字&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;      var div=document.querySelector(&quot;div&quot;);          // 移除样式 只能单独移除          div.classList.remove(&quot;bgc&quot;);            div.classList.remove(&quot;fonts&quot;);&lt;/script&gt;</code></pre><p><strong>3、切换类（toggle）</strong></p><blockquote><p>当元素上没有某个类时，它就新增这个类；如果元素已经有了这个类，它就是删除它，就是切换操作。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .bgc {        width: 300px;        height: 300px;        background-color: pink;    }&lt;/style&gt;&lt;div class=&quot;bgc&quot;&gt;文字&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;      var div=document.querySelector(&quot;div&quot;);          // 切换样式 因为元素已经有“bac”这个类名了，所以这里是移除的功能          div.classList.toggle(&quot;bgc&quot;);&lt;/script&gt;</code></pre><p><strong>4、是否存在某个类（contains）</strong></p><blockquote><p>判断获取的元素中是否存在某个类名，返回值为<code>true</code>或者<code>false</code>。</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .bgc {        width: 300px;        height: 300px;        background-color: pink;    }&lt;/style&gt;&lt;div class=&quot;bgc&quot;&gt;文字&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;      var div=document.querySelector(&quot;div&quot;);          // 判断元素是否拥有某个类名          div.classList.contains(&quot;bgc&quot;);    // true&lt;/script&gt;</code></pre><h3 id="7-3-自定义属性"><a href="#7-3-自定义属性" class="headerlink" title="7.3 自定义属性"></a>7.3 自定义属性</h3><blockquote><p><code>HTML5</code>规定可以为元素添加非标准的属性，但要添加前缀<code>data-</code>，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以<code>data-</code>开头。</p></blockquote><p>如：</p><pre><code>&lt;p data-info=&quot;tags&quot;&gt;&lt;/p&gt;</code></pre><p><strong>获取自定义属性（dataset[‘自定义属性名称’]）</strong></p><blockquote><p>通过<code>Node.dataset[&#39;info&#39;]</code> 我们便可以获取到自定义的属性值。</p></blockquote><pre><code>&lt;p data-info=&quot;describe&quot; data-num=&quot;123&quot;&gt;这是一段描述&lt;/p&gt;&lt;script&gt;    var tag = document.querySelector(&#39;p&#39;);    var data = tag.dataset;    console.log(data);   // 打印的是一个对象 DOMStringMap    console.log(data[&#39;info&#39;]);  // &quot;describe&quot;    console.log(data[&#39;num&#39;]);  // &quot;123&quot;&lt;/script&gt;</code></pre><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fw8wjv3qg0j309r033glg.jpg" alt="image"></p><p><em>Node.dataset是以对象形式存在的，当我们为同一个DOM节点指定了多个自定义属性时，Node.dataset则以键值对的形式存储了所有的自定义属性的值。</em></p><p><strong>设置自定义属性（dataset[‘自定义属性名称’]=”设定属性值”）</strong></p><blockquote><p>通过<code>过Node.dataset[&#39;info&#39;]=&quot;值&quot;</code> 我们便可以设置自定义的属性值。</p></blockquote><pre><code>&lt;p data-info=&quot;describe&quot; data-num=&quot;123&quot;&gt;这是一段描述&lt;/p&gt;&lt;script&gt;    var tag = document.querySelector(&#39;p&#39;);    var data = tag.dataset;    data[&#39;name&#39;] = &quot;Ryan&quot;;    console.log(data);     // 多了一个name属性&lt;/script&gt;</code></pre><p><strong>注意</strong></p><blockquote><p>当自定义属性中除了<code>data-</code>之外中间出现“<code>-</code>”连接符时，设置和获取的时候需要将属性名转成驼峰的格式才能正常的设置和获取。</p></blockquote><pre><code>&lt;p data-my-info=&quot;information&quot;&gt;这是一段描述！&lt;/p&gt;&lt;script&gt;    var tag = document.querySelector(&#39;p&#39;);    var data = tag.dataset;    data[&#39;myInfo&#39;] = &quot;info&quot;;    console.log(data);     // {myInfo:&quot;info&quot;}&lt;/script&gt;</code></pre><h2 id="8-网络状态"><a href="#8-网络状态" class="headerlink" title="8. 网络状态"></a>8. 网络状态</h2><blockquote><p>我们可以通过<code>window.navigator.onLine</code>来检测，用户当前的网络状况，返回一个布尔值</p></blockquote><p>通过给<code>window</code>绑定监听事件，可以监测浏览器的一些状态信息</p><ul><li>网络从无到有时触发“<code>online</code>”方法</li></ul><pre><code>window.addEventListener(&#39;online&#39;, function(){    // online是网络从无网到有网的 时候触发})</code></pre><ul><li>网络从有到无时触发“<code>offline</code>”方法</li></ul><pre><code>window.addEventListener(&#39;offline&#39;, function(){    // online是网络从有网到无网的时候触发})</code></pre><h2 id="9-地理定位"><a href="#9-地理定位" class="headerlink" title="9. 地理定位"></a>9. 地理定位</h2><blockquote><p>在<code>HTML</code>规范中，增加了获取用户地理信息的<code>API</code>，这样使得我们可以基于用户位置开发互联网应用，即基于位置服务 (<code>Location Base Service</code>)</p></blockquote><h3 id="9-1-获取地理信息方式"><a href="#9-1-获取地理信息方式" class="headerlink" title="9.1 获取地理信息方式"></a>9.1 获取地理信息方式</h3><blockquote><p>获取地理信息的方式一共有三种分别是：</p></blockquote><ul><li><code>IP</code>地址</li><li>三维坐标<ul><li><code>GPS</code>（<code>Global Positioning System</code>，全球定位系统）</li><li><code>Wi-Fi</code></li><li>手机信号</li></ul></li><li>用户自定义数据</li></ul><p><strong>如下表：</strong></p><blockquote><p>下表对不同获取方式的优缺点进行了比较，浏览器会自动以最优的方式去获取用户地理位置</p></blockquote><table><thead><tr><th>数据源</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><code>IP</code> 地址</td><td>任何地方都可以用，在服务器端处理</td><td>不精确（经常出错，一般精确到城市级）运算代价大</td></tr><tr><td><code>GPS</code></td><td>很精确</td><td>定位时间长，耗电量大；室内效果差；需要额外硬件设备支持</td></tr><tr><td><code>Wi-Fi</code></td><td>精确，可在室内使用，简单、快捷</td><td>在乡村这些<code>Wi-Fi</code>接入点少的地区无法实现用</td></tr><tr><td>手机信号</td><td>相当准确，可在室内使用，简单、快捷</td><td>需要能够访问手机或其 <code>modem</code> 设备</td></tr><tr><td>用户自定义</td><td>可获得比程序定位服务更准确的位置数据，用户自行输入可能比自动检测更快</td><td>可能很不准确，特别是当用户位置变更后</td></tr></tbody></table><h3 id="9-2-隐私"><a href="#9-2-隐私" class="headerlink" title="9.2 隐私"></a>9.2 隐私</h3><blockquote><p><code>HTML5 Geolocation</code>规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。</p></blockquote><h3 id="9-3-使用地理定位"><a href="#9-3-使用地理定位" class="headerlink" title="9.3 使用地理定位"></a>9.3 使用地理定位</h3><blockquote><p>有两个方法都可以获取到当前的地理定位，只是功能上稍微有点区别。</p></blockquote><pre><code>navigator.geolocation.getCurrentPosition(successCallback, errorCallback, options) // 方法：获取当前地理信息navigator.geolocation.watchPosition(successCallback, errorCallback, options) // 重复获取当前地理信息</code></pre><p><strong>当成功获取地理信息后</strong></p><blockquote><p>会调用<code>succssCallback</code>，并返回一个包含位置信息的对象<code>position</code>。</p></blockquote><pre><code>position.coords.latitude  // 纬度position.coords.longitude // 经度</code></pre><p><strong>成功对象position：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fxdcdew23vj30bk0a03z0.jpg" alt="image"></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>coords.latitude</code></td><td>十进制数的纬度</td></tr><tr><td><code>coords.longitude</code></td><td>十进制数的经度</td></tr><tr><td><code>coords.accuracy</code></td><td>位置精度</td></tr><tr><td><code>coords.altitude</code></td><td>海拔，海平面以上以米计</td></tr><tr><td><code>coords.altitudeAccuracy</code></td><td>位置的海拔精度</td></tr><tr><td><code>coords.heading</code></td><td>方向，从正北开始以度计</td></tr><tr><td><code>coords.speed</code></td><td>速度，以米/每秒计</td></tr><tr><td><code>timestamp</code></td><td>响应的日期/时间</td></tr></tbody></table><p><strong>当获取地理信息失败后</strong></p><blockquote><p>会调用<code>errorCallback</code>，并返回错误信息<code>error</code></p></blockquote><p>返回无符号的、简短的错误码，详见下表：</p><table><thead><tr><th>值</th><th>相关联的常量</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td><code>PERMISSION_DENIED</code></td><td>用户不允许地理定位</td></tr><tr><td>2</td><td><code>POSITION_UNAVAILABLE</code></td><td>无法获取当位置</td></tr><tr><td>3</td><td><code>TIMEOUT</code></td><td>超时操作</td></tr></tbody></table><p><strong>示例代码：</strong></p><blockquote><p>获取当前位置的经纬度</p></blockquote><pre><code>window.navigator.geolocation.getCurrentPosition(function(position){    // 纬度    var lat = position.coords.latitude;    // 经度    var long = position.coords.longitude;    console.log(&#39;你当前的纬度为：&#39; + lat + &#39;经度为：&#39; + long)},function(err){  // 错误时回调信息    if(err.code == 1){        alert(&#39;没有权限&#39;)    }else if(err.code == 2){        alert(&#39;内部错误&#39;);    }else{        alert(&#39;超时&#39;)    }},{    // 超时设置    timeout: 5000});</code></pre><h3 id="9-4-百度地图的用法"><a href="#9-4-百度地图的用法" class="headerlink" title="9.4 百度地图的用法"></a>9.4 百度地图的用法</h3><blockquote><p>结合百度地图的API，我们可以使用它上面的一些功能，比如在地图上定位等等等…</p></blockquote><p><strong>进入百度地图开放平台官网：</strong></p><blockquote><p><a href="http://lbsyun.baidu.com/" target="_blank" rel="noopener">网址：</a><a href="http://lbsyun.baidu.com/" target="_blank" rel="noopener">http://lbsyun.baidu.com/</a></p></blockquote><p>找到<code>Web</code>开发 -&gt; <code>javascript API</code></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fxdd1q1o4vj31as0jfacc.jpg" alt="image"></p><p><strong>直接找到示例DEMO，复制源代码，需要获取密钥 （自己申请，需要一到两个工作日）</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;    &lt;style type=&quot;text/css&quot;&gt;        body,        html,        #allmap {            width: 100%;            height: 100%;            overflow: hidden;            margin: 0;            font-family: &quot;微软雅黑&quot;;        }    &lt;/style&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;你申请的秘钥&quot;&gt;&lt;/script&gt;    &lt;title&gt;地图展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    // 百度地图API功能    var map = new BMap.Map(&quot;allmap&quot;); // 创建Map实例    map.centerAndZoom(new BMap.Point(116.404, 39.915), 11); // 初始化地图,设置中心点坐标和地图级别    map.addControl(new BMap.MapTypeControl()); //添加地图类型控件    map.setCurrentCity(&quot;北京&quot;); // 设置地图显示的城市 此项是必须设置的    map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放&lt;/script&gt;</code></pre><p><strong>获取当前所在位置，设置到地图上</strong></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt;    &lt;style type=&quot;text/css&quot;&gt;        body,        html,        #allmap {            width: 100%;            height: 100%;            overflow: hidden;            margin: 0;            font-family: &quot;微软雅黑&quot;;        }    &lt;/style&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;你申请的秘钥&quot;&gt;&lt;/script&gt;    &lt;title&gt;地图展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt;    window.navigator.geolocation.getCurrentPosition(function (pos) {        // 纬度        var lat = pos.coords.latitude;        // 经度        var long = pos.coords.longitude;        console.log(&#39;你当前的纬度为：&#39; + lat + &#39;经度为：&#39; + long)        // 百度地图API功能        var map = new BMap.Map(&quot;allmap&quot;); // 创建Map实例        map.centerAndZoom(new BMap.Point(long, lat), 15); // 初始化地图,设置中心点坐标和地图级别        map.addControl(new BMap.MapTypeControl()); //添加地图类型控件        map.setCurrentCity(&quot;北京&quot;); // 设置地图显示的城市 此项是必须设置的        map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放    }, function (err) {        if (err.code == 1) {            alert(&#39;没有权限&#39;)        } else if (err.code == 2) {            alert(&#39;内部错误&#39;);        } else {            alert(&#39;超时&#39;)        }    }, {        // 超时设置        timeout: 5000    });&lt;/script&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fxde2i3zbgj30wa0j5gun.jpg" alt="image"></p><h2 id="10-WEB-存储"><a href="#10-WEB-存储" class="headerlink" title="10. WEB 存储"></a>10. WEB 存储</h2><blockquote><p>随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，传统方式我们以<code>document.cookie</code>来进行存储的，但是由于其存储大小只有<code>4k</code>左右，并且解析也相当的复杂，每一次发送请求都会携带上<code>cookie</code>，会造成带宽的浪费，给开发带来诸多不便，<code>HTML5</code>规范则提出解决方案。<code>web</code>存储的含义是将数据存储到用户的电脑上，这样可以缓解服务器的压力，并且提高体验。</p></blockquote><h3 id="10-1-特性"><a href="#10-1-特性" class="headerlink" title="10.1 特性"></a>10.1 特性</h3><ul><li>设置、读取方便</li><li>容量较大，<code>sessionStorage</code>约<code>5M</code>，<code>localStorage</code>约<code>20M</code></li><li>只能存储字符串，可以将对象<code>JSON.stringify()</code>转成字符串后存储</li></ul><h3 id="10-2-方法详解"><a href="#10-2-方法详解" class="headerlink" title="10.2 方法详解"></a>10.2 方法详解</h3><ul><li><code>setItem(key, value)</code>设置存储内容</li><li><code>getItem(key)</code>读取存储内容</li><li><code>removeItem(key)</code>删除键值为<code>key</code>的存储内容</li><li><code>clear()</code>清空所有存储内容</li><li><code>key(n)</code>以索引值来获取键名</li><li><code>length</code>存储的数据的个数</li></ul><p><strong>示例代码：</strong></p><pre><code>// 在本地存储了一个键为：username 值为 Ryan&#39;s 的这个一个对象// 在chrome的控制台的application里面的Storage可以查看window.localStorage.setItem(&#39;username1&#39;,&quot;Ryan&#39;s&quot;);window.localStorage.setItem(&#39;username2&#39;,&quot;Levi&#39;s&quot;);window.sessionStorage.setItem(&#39;username1&#39;,&quot;Ryan&#39;s&quot;);window.sessionStorage.setItem(&#39;username2&#39;,&quot;Levi&#39;s&quot;);// 索引键的名字alert(window.localStorage.key(0));alert(window.sessionStorage.key(0));// 取数据 alert(window.localStorage.getItem(&#39;username1&#39;));alert(window.sessionStorage.getItem(&#39;username1&#39;));// 获取本地数据的长度alert(window.localStorage.length);alert(window.sessionStorage.length);// 删除数据window.localStorage.removeItem(&#39;username1&#39;);window.sessionStorage.removeItem(&#39;username1&#39;);// 清空所有的数据window.localStorage.clear();window.sessionStorage.clear();</code></pre><h3 id="10-3-sessionStorage"><a href="#10-3-sessionStorage" class="headerlink" title="10.3 sessionStorage"></a>10.3 sessionStorage</h3><p><strong>特点：</strong></p><ul><li>生命周期为关闭当前页面窗口</li><li>不能多窗口下数据共享（同源策略）</li><li>通过跳转可以解决，页面跳转的时候可以通过<code>session</code>实现数据共享</li></ul><h3 id="10-4-localStorage"><a href="#10-4-localStorage" class="headerlink" title="10.4 localStorage"></a>10.4 localStorage</h3><p><strong>特点：</strong></p><ul><li>生命周期为永久有效，除非手动删除或用代码删除</li><li>可以多窗口共享（同源策略）</li><li>一些不涉及到安全的一些数据（不要太过庞大）都可以存储到本地</li></ul><p><strong>示例代码：</strong></p><pre><code>window.localStorage.setItem(&#39;age&#39;,18)</code></pre><p><strong>效果图：</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fxdm5gt1kqj30e30csdg0.jpg" alt="image"></p><h3 id="10-5-差异性"><a href="#10-5-差异性" class="headerlink" title="10.5 差异性"></a>10.5 差异性</h3><blockquote><p>比较<code>cookie</code>，<code>session</code>，<code>local</code>三者之间的相同点和不同点</p></blockquote><p><strong>相同点：</strong></p><ul><li>都是存储数据，存储在web端，并且都是同源</li></ul><p><strong>不同点：</strong></p><ul><li>（1）<code>cookie</code>只有<code>4K</code>大小 并且每一次请求都会带上<code>cookie</code>体验不好，浪费带宽</li><li>（2）<code>session</code>和<code>local</code>直接存储在本地，请求不会携带，并且容量比<code>cookie</code>要大的多</li><li>（3）<code>session</code>是临时会话，当窗口被关闭的时候就清除掉 ，而<code>local</code>永久存在，<code>cookie</code>有过期时间</li><li>（4）<code>cookie</code>和<code>local</code>都可以支持多窗口共享，而<code>session</code>不支持多窗口共享 但是都支持<code>a</code>链接跳转的新窗口</li></ul><h2 id="11-文件读取"><a href="#11-文件读取" class="headerlink" title="11. 文件读取"></a>11. 文件读取</h2><blockquote><p>通过<code>FileReader</code>对象我们可以读取本地存储的文件，可以使用<code>File</code>对象来指定所要读取的文件或数据。其中<code>File</code>对象可以是来自用户在一个<code>&lt;input&gt;</code>元素上选择文件后返回的<code>FileList</code>对象，也可以来自由拖放操作生成的<code>DataTransfer</code>。</p></blockquote><p><strong>1、FileList 对象</strong></p><blockquote><p>由于<code>HTML5</code>中我们可以通过为表单元素添加<code>multiple</code>属性，因此我们通过<code>&lt;input&gt;</code>上传文件后得到的是一个<code>FileList</code>对象（伪数组形式）。</p></blockquote><p><strong>2、FileReader 对象</strong></p><blockquote><p><code>HTML5</code>新增内建对象，可以读取本地文件内容。<code>var reader = new FileReader;</code>可以实例化一个对象。</p></blockquote><pre><code>var data = file.files[0];// 创建一个读取对象var fr = new FileReader();// 读取文件fr.readAsDataURL(data);</code></pre><p><em>readAsDataURL()以DataURL形式读取文件</em></p><p><strong>3、事件监听</strong></p><blockquote><p><code>onload</code>当文读取完成时调用</p></blockquote><pre><code>fr.addEventListener(&#39;load&#39;, function(){    //获取读取的结果      //result属性里面存储的就是读取文件的结果    var result = fr.result;    })</code></pre><p><strong>完整代码：</strong></p><pre><code>&lt;input type=&quot;file&quot; multiple name=&quot;&quot; id=&quot;&quot;&gt;&lt;button&gt;点击读取文件&lt;/button&gt;&lt;script type=&quot;text/javascript&quot;&gt;var btn = document.querySelector(&#39;button&#39;);var file = document.querySelector(&#39;input[type=&quot;file&quot;]&#39;);var fr = [];btn.onclick = function(){            // 读取文件    for(var i = 0; i &lt; file.files.length; i++){        fr[i] = new FileReader();        fr[i].readAsDataURL(file.files[i]);    }    // fr.readAsDataURL(data);    // 读取文件是一个耗时的操作，所以需要用事件监听读取完毕，    // load事件是文件读取完毕之后触发的事件    for(var j = 0; j &lt; fr.length; j++){        fr[j].addEventListener(&#39;load&#39;, function(){            //获取读取的结果              //result属性里面存储的就是读取文件的结果            console.log(fr);            var result = this.result;                // 创建图片对象            var img = document.createElement(&#39;img&#39;);            img.src = result;            document.body.appendChild(img);         })    }    }&lt;/script&gt;</code></pre><h2 id="12-拖拽"><a href="#12-拖拽" class="headerlink" title="12. 拖拽"></a>12. 拖拽</h2><blockquote><p>在<code>HTML5</code>的规范中，我们可以通过为元素增加<code>draggable=&quot;true&quot;</code>来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启的。</p></blockquote><p><strong>1、拖拽元素</strong></p><blockquote><p>页面中设置了<code>draggable=&quot;true&quot;</code>属性的元素，可以被拖拽，其中<code>&lt;img&gt;</code>、<code>&lt;a&gt;</code>标签默认是可以被拖拽的。</p></blockquote><p><strong>2、目标元素</strong></p><blockquote><p>页面中任何一个元素都可以成为目标元素。</p></blockquote><p><strong>3、事件监听</strong></p><blockquote><p>根据元素类型的不同，需要设置不同的事件监听：</p></blockquote><p>（1）、拖拽元素</p><ul><li><code>ondrag</code> 应用于拖拽元素，整个拖拽过程都会调用</li><li><code>ondragstart</code> 应用于拖拽元素，当拖拽开始时调用</li><li><code>ondragend</code> 应用于拖拽元素，当拖拽结束时调用</li></ul><p>（2）、目标元素</p><ul><li><code>ondragenter</code> 应用于目标元素，当拖拽元素进入时调用</li><li><code>ondragleav</code> 应用于目标元素，当鼠标离开目标元素时调用</li><li><code>ondragver</code> 应用于目标元素，当停留在目标元素上时调用</li><li><code>ondrop</code> 应用于目标元素，当在目标元素上松开鼠标时调用</li></ul><p><strong>示例代码：</strong> 将图片拖拽到浏览器内显示在<code>div</code>内</p><pre><code>&lt;style&gt;    .info {        width: 500px;        height: 500px;        border: 1px solid #000;        position: absolute;        left: 50%;        top: 50%;        line-height: 500px;        text-align: center;        transform:translate(-50%,-50%);        box-shadow: 0 0 10px 2px rgba(0,0,0,.5);         border-radius: 5px;    }    .info img {        width: 100%;        height: 100%;    }&lt;/style&gt;&lt;!-- 目标元素 --&gt;&lt;div class=&quot;info&quot;&gt;将图片拖拽至此&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var info = document.querySelector(&#39;.info&#39;);    // 获取html元素    var oHtml = document.documentElement;    // 问题：浏览器默认会将外部拖拽的文件直接打开，我们需要阻止掉    // 将外部文件拖拽进浏览器里面松开鼠标的时候其实就是在html页面上触发了drop事件，我们只需要在drop事件的时候阻止默认事件    oHtml.ondrop = function(e){        // 阻止默认事件        e.preventDefault();    }    /*drop事件默认是被阻止的，所以还需要在dragover的时候阻止默认事件*/    oHtml.ondragover = function(e){        e.preventDefault();    }    info.ondrop = function(e){        // 获取外部拖拽进来的文件        // console.log(e);        var data = e.dataTransfer.files[0];                var fr = new FileReader();        fr.readAsDataURL(data);        fr.addEventListener(&#39;load&#39;,function(){            var result = fr.result;            var img = document.createElement(&#39;img&#39;);            img.src = result;            info.innerHTML = &#39;&#39;;            info.appendChild(img);        })    }&lt;/script&gt;</code></pre><p><strong>效果图</strong></p><p><img src="http://ww1.sinaimg.cn/large/007kscFEgy1fxfxo8xc91g30j20e7wh5.gif" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS入门详解(一)</title>
      <link href="/2018/11/28/css-ru-men-xiang-jie-yi/"/>
      <url>/2018/11/28/css-ru-men-xiang-jie-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS入门详解-一"><a href="#CSS入门详解-一" class="headerlink" title="CSS入门详解(一)"></a>CSS入门详解(一)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>如同人类的的进化一样，<code>CSS3</code>是<code>CSS2</code>的“进化”版本，在<code>CSS2</code>基础上，增强或新增了许多特性，弥补了<code>CSS2</code>的众多不足之处，使得<code>Web</code>开发变得更为高效和便捷。</p></blockquote><h2 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1.选择器"></a>1.选择器</h2><blockquote><p><code>CSS3</code>新增了许多灵活查找元素的方法，极大的提高了查找元素的效率和精准度。<code>CSS3</code>选择器与<code>jQuery</code>中所提供的绝大部分选择器兼容。</p></blockquote><h3 id="1-1-属性选择器"><a href="#1-1-属性选择器" class="headerlink" title="1.1 属性选择器"></a>1.1 属性选择器</h3><blockquote><p>属性选择器就是通过属性来选择元素。</p></blockquote><table><thead><tr><th>选择器</th><th>含义</th></tr></thead><tbody><tr><td><code>[attr]</code></td><td>存在<code>attr</code>属性即可</td></tr><tr><td><code>[attr=val]</code></td><td>属性值完全等于<code>val</code></td></tr><tr><td><code>[attr*=val]</code></td><td>属性值里包含<code>val</code>字符并且在“任意”位置</td></tr><tr><td><code>[attr^=val]</code></td><td>属性值里包含<code>val</code>字符并且在“开始”位置</td></tr><tr><td><code>[attr$=val]</code></td><td>属性值里包含<code>val</code>字符并且在“结束”位置</td></tr></tbody></table><p><strong>1、[attr]</strong></p><pre><code>&lt;style&gt;    /* 所有拥有class属性的标签，添加color样式 */    [class]{        color: #333;    }&lt;/style&gt;</code></pre><p><strong>2、[attr=val]</strong></p><pre><code>&lt;style&gt;    /* 所有拥有class属性全等于“one”的标签，添加color样式 */    [class = &quot;one&quot;]{        color: #333;    }&lt;/style&gt;</code></pre><p><strong>3、[attr*=val]</strong></p><pre><code>&lt;style&gt;    /* class属性的值里面包含“one”的标签，添加color样式 */    [attr*=&quot;one&quot;]{        color: #333;    }&lt;/style&gt;</code></pre><p><strong>4、[attr^=val]</strong></p><pre><code>&lt;style&gt;    /* class属性的值以“one”开始的标签，添加color样式 */    [attr ^= &quot;one&quot;]{        color: #333;    }&lt;/style&gt;</code></pre><p><strong>5、[attr$=val]</strong></p><pre><code>&lt;style&gt;    /* class属性的值以“one”结束的标签，添加color样式 */    [attr $= &quot;one&quot;]{        color: #333;    }&lt;/style&gt;</code></pre><h3 id="1-2-伪类选择器"><a href="#1-2-伪类选择器" class="headerlink" title="1.2 伪类选择器"></a>1.2 伪类选择器</h3><blockquote><p>除了以前介绍的的<code>:link</code>、<code>:active</code>、<code>:visited</code>、<code>:hover</code>，<code>CSS3</code>又新增了其它的伪类选择器。</p></blockquote><p><strong>1、结构（位置）伪类</strong></p><table><thead><tr><th>选择器</th><th>含义</th></tr></thead><tbody><tr><td><code>:first-child</code></td><td>其父元素的第<code>1</code>个子元素</td></tr><tr><td><code>:last-child</code></td><td>其父元素的最后<code>1</code>个子元素</td></tr><tr><td><code>:nth-child(n)</code></td><td>其父元素的第<code>n</code>个子元素</td></tr><tr><td><code>:nth-last-child(n)</code></td><td>其父元素的第<code>n</code>个子元素（倒着数）</td></tr></tbody></table><p><strong>2、空伪类</strong></p><blockquote><p><code>:empty</code>选中没有任何子节点的元素</p></blockquote><pre><code>&lt;style&gt;   div:empty {   /* 没有子元素的div元素 */        width: 100px;        height: 100px;        background-color: pink;    }&lt;/style&gt;&lt;!-- css 样式不起作用 --&gt;&lt;div class=&quot;one&quot;&gt;阿斯蒂芬&lt;/div&gt;   &lt;!-- css样式不起作用 --&gt;&lt;div&gt;    &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;!-- css样式生效 --&gt;&lt;div&gt;&lt;/div&gt;</code></pre><p><strong>3、目标伪类</strong></p><blockquote><p><code>:target</code>结合锚点进行使用，处于当前锚点的元素会被选中；</p></blockquote><pre><code>&lt;style type=&quot;text/css&quot;&gt;    /* 使用锚链接指向当前标签的时候 */    .one:target {        background-color: pink;        font-size: 30px;    }&lt;/style&gt;&lt;a href=&quot;#hh&quot;&gt;找笑脸去&lt;/a&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p id=&quot;hh&quot; class=&quot;one&quot;&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;&lt;p&gt;阿斯顿发撒旦法撒打发放大法的撒双方都&lt;/p&gt;</code></pre><p><strong>4、排除伪类</strong></p><blockquote><p><code>:not(selector)</code>除<code>selector</code>（任意选择器）外的元素会被选中；</p></blockquote><pre><code>&lt;style&gt;    /* 除了类名是“.not”的div元素 */    div:not(.one) {        width: 100px;        height: 100px;        background-color: pink;    }&lt;/style&gt;&lt;!-- css样式不生效 --&gt;&lt;div class=&quot;one&quot;&gt;&lt;/div&gt;&lt;!-- css样式生效 --&gt;&lt;p&gt;&lt;/p&gt;&lt;!-- css样式生效 --&gt;&lt;div&gt;&lt;/div&gt;</code></pre><h3 id="1-3-伪元素选择器"><a href="#1-3-伪元素选择器" class="headerlink" title="1.3 伪元素选择器"></a>1.3 伪元素选择器</h3><ul><li>1、<code>::first-letter</code>文本的第一个单词或字（如中文、日文、韩文等）</li><li>2、<code>::first-line</code> 文本第一行；</li><li>3、<code>::selection</code> 可改变选中文本的样式；</li><li>4、<code>::before</code>和<code>::after</code></li></ul><p><strong>示例代码：伪元素实现横竖分割线</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {         margin: 0;         padding: 0;         list-style: none;    }    .box {         width: 300px;         height: 200px;         background-color: pink;         margin: 50px auto;    }    .box li {         width: 100px;         height: 100px;         float: left;         background-color: #555;         position: relative;         overflow: hidden;    }    li:before {         content: &quot;&quot;;         display: block;         width: 90px;         height: 1px;         background-color: #ccc;         position: absolute;         top: 97px;         left: 5px;    }    li:after {         content: &quot;&quot;;         display: block;         width: 1px;         height: 90px;         background-color: #ccc;         position: absolute;         left: 0px;         top: 4px;    }    li:nth-child(1):after,li:nth-child(4):after {         display: none;    }    li:nth-last-child(-n+3):before {         display: none;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099839?w=369&amp;h=255" alt="image"></p><blockquote><p><code>:after</code>、<code>:before</code>在旧版本里是伪元素，<code>CSS3</code>的规范里“<code>:</code>”用来表示伪类，“<code>::</code>”用来表示伪元素，但是在高版本浏览器下<code>:after</code>、<code>:before</code>会被自动识别为<code>::after</code>、<code>::before</code>，这样做的目的是用来做兼容处理。</p></blockquote><h2 id="2-颜色"><a href="#2-颜色" class="headerlink" title="2. 颜色"></a>2. 颜色</h2><blockquote><p>新增了<code>RGBA</code>、<code>HSLA</code>模式，其中的<code>A</code>表示透明度，即可以设置颜色值的透明度，相较<code>opacity</code>，它们不具有继承性，即不会影响子元素的透明度。</p></blockquote><h3 id="2-1-RGBA"><a href="#2-1-RGBA" class="headerlink" title="2.1 RGBA"></a>2.1 RGBA</h3><blockquote><p><code>Red</code>、<code>Green</code>、<code>Blue</code>、<code>Alpha</code>即<code>RGBA</code>，<code>R</code>、<code>G</code>、<code>B</code>取值范围<code>0~255</code>。</p></blockquote><pre><code>&lt;style&gt;    #box{        width:100px;        height:100px;        background: rgba(200,200,200,.5);    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><h3 id="2-2-HSLA"><a href="#2-2-HSLA" class="headerlink" title="2.2 HSLA"></a>2.2 HSLA</h3><ul><li><code>H</code> 色调 取值范围<code>0~360</code>，<code>0/360</code>表示红色、<code>120</code>表示绿色、<code>240</code>表示蓝色</li><li><code>S</code> 饱和度 取值范围<code>0%~100%</code></li><li><code>L</code> 亮度 取值范围<code>0%~100%</code></li><li><code>A</code> 透明度 取值范围<code>0~1</code></li></ul><pre><code>&lt;style&gt;    #box{        width:100px;        height:100px;        background: hsla(200,50%,50%,.5);    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><h3 id="2-3-关于-CSS-的透明度"><a href="#2-3-关于-CSS-的透明度" class="headerlink" title="2.3 关于 CSS 的透明度"></a>2.3 关于 CSS 的透明度</h3><blockquote><pre><code>Alpha</code></pre><p>和</p><pre><code>opacity</code></pre><p>的区别主要就是，</p><pre><code>opacity</code></pre><p>具有继承性，父盒子设置该属性，下面所有的子元素都会继承该属性。</p><p><code>transparent</code>不可调节透明度，始终完全透明。</p></blockquote><h2 id="3-文本阴影"><a href="#3-文本阴影" class="headerlink" title="3. 文本阴影"></a>3. 文本阴影</h2><blockquote><p><code>text-shadow</code>，可分别设置偏移量、模糊度、颜色（可设透明度）。</p></blockquote><p>如：</p><pre><code>text-shadow: 2px 2px 2px #CCC;</code></pre><ul><li>1、水平偏移量 正值向右 负值向左；</li><li>2、垂直偏移量 正值向下 负值向上；</li><li>3、模糊度是不能为负值；</li><li>4、阴影颜色。</li></ul><p><strong>示例代码：文字浮雕</strong></p><pre><code>&lt;style&gt;     html,body {          margin: 0;          padding: 0;          width: 100%;          height: 100%;          background-color: #999;          font-size: 50px;          text-align: center;          line-height: 260px;          color: #999;     }    .one {         text-shadow: -1px -1px 1px #fff,1px 1px 1px #000;    }    .two {         text-shadow: -1px -1px 1px #000,1px 1px 1px #fff;    }&lt;/style&gt;&lt;div class=&quot;one&quot;&gt;我是凸起文字&lt;/div&gt;&lt;div class=&quot;two&quot;&gt;我是凹下去的文字&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099840?w=535&amp;h=385" alt="image"></p><h2 id="4-盒模型"><a href="#4-盒模型" class="headerlink" title="4. 盒模型"></a>4. 盒模型</h2><blockquote><p><code>CSS3</code>中可以通过<code>box-sizing</code>来指定盒模型，即可指定为<code>content-box</code>、<code>border-box</code>，这样我们计算盒子大小的方式就发生了改变。</p></blockquote><p>可以分成两种情况：</p><ul><li>1、<code>box-sizing: border-box</code>盒子大小为<code>width</code></li><li>2、<code>box-sizing: content-box</code>盒子大小为<code>width + padding + border</code></li></ul><p><em>注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。</em></p><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;     .box {          width: 316px;          height: 170px;          float: left;          margin-left: 20px;          box-sizing: border-box;     }     .box img {          width: 100%;          height: 100%;     }     .box:hover {          border: 10px solid #00eeff;     }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;   &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot;&gt;   &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099841?w=671&amp;h=185" alt="image"></p><p><em>可以看出通过设置盒子模型后，虽然.box设置了边框，但是整个box的盒子大小没有改变。</em></p><h2 id="5-边框"><a href="#5-边框" class="headerlink" title="5. 边框"></a>5. 边框</h2><blockquote><p>边框中的边框圆角、边框阴影属性，应用十分广泛，兼容性也相对较好，具有符合渐进增强原则的特征。</p></blockquote><h3 id="5-1-边框圆角"><a href="#5-1-边框圆角" class="headerlink" title="5.1 边框圆角"></a>5.1 边框圆角</h3><blockquote><p>通过<code>border-radius</code>属性，设置边框圆角，圆角处理时，脑中要形成圆、圆心、横轴、纵轴的概念，正圆是椭圆的一种特殊情况。</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000017099842?w=324&amp;h=186" alt="image"></p><p>为了方便表述，我们将四个角标记成<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>，如<code>2</code>代表右上角，<code>CSS</code>里提供了<code>border-radius</code>来设置这些角横纵轴半径值。</p><p><em>分别设置横纵轴半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ）。</em></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        margin: 50px auto;        width: 300px;        height: 500px;        border: 1px solid #ccc;        border-radius: 10px 20px 50px 70px / 10px 20px 50px 70px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p>效果图：</p><p><em>一般情况下，我们用不到这么复杂的，除非特殊需求的时候。</em></p><p><img src="https://segmentfault.com/img/remote/1460000017099843?w=330&amp;h=528" alt="image"></p><p><strong>支持简写模式，具体如下：</strong></p><ul><li>1、<code>border-radius: 10px;</code>表示四个角的横纵轴半径都为<code>10px</code>；</li><li>2、<code>border-radius: 10px 5px;</code>表示<code>1</code>和<code>3</code>角横纵轴半径都为<code>10px</code>，<code>2</code>和<code>4</code>角横纵轴半径为<code>5px</code>；</li><li>3、<code>border-radius: 10px 5px 8px;</code>表示<code>1</code>角模纵轴半径都为<code>10px</code>，<code>2</code>和<code>4</code>角横纵轴半径都为<code>8px</code>，<code>3</code>角的横纵轴半径都为<code>8px</code>；</li><li>4、<code>border-radius: 10px 8px 6px 4px;</code>表示<code>1</code>角横纵轴半径都为<code>10px</code>，表示<code>2</code>角横纵轴半径都为<code>8px</code>，表示<code>3</code>角横纵轴半径都为<code>6px</code>，表示<code>4</code>角横纵轴半径都为<code>6px</code>；</li></ul><p><strong>椭圆的画法：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        margin: 50px auto;        width: 300px;        height: 500px;        border: 1px solid #ccc;        /* 当盒子长宽不一致时，圆角属性 分别设置宽度的一半，以及长度的一半，即是椭圆 */        /* 或者直接 border-radius:50%; */        border-radius: 150px 250px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><img src="https://segmentfault.com/img/remote/1460000017099844?w=320&amp;h=518" alt="image"></p><p><em>如果不想计算，直接设百分比：“50%”。</em></p><p><strong>正圆的画法：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        margin: 50px auto;        width: 200px;        height: 200px;        border: 1px solid #ccc;        /* 当盒子长宽相等时，圆角属性分别设置宽度的一半，以及长度的一半，即是正圆 */        /* 或者直接 border-radius:50%; */        border-radius: 100px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><img src="https://segmentfault.com/img/remote/1460000017099845?w=343&amp;h=327" alt="image"></p><p><strong>示例代码：边框圆角合集</strong></p><pre><code>&lt;style&gt;    * {          margin: 0;          padding: 0;          list-style: none;          background-color: wheat;          overflow: hidden;     }     .box {          width: 980px;          height: 400px;          background-color: #fff;          margin: 50px auto;     }     .box li {          float: left;          width: 193px;          height: 193px;          background-color: #fff;          margin:5px;          box-shadow: 2px 3px 5px #aaa;     }     li:first-child:after {          content: &quot;&quot;;          height: 130px;          width: 130px;          margin: 30px auto;          display: block;          border: 1px solid orangered;          border-radius: 50%;     }     li:nth-child(2):after {          content: &quot;&quot;;          display: block;          height: 130px;          width: 130px;          border: 1px solid orangered;          margin: 30px auto;          border-radius: 65px 65px 0px 0px;     }     li:nth-child(3):after {          content: &quot;&quot;;          display: block;          width: 130px;          height: 65px;          border: 1px solid orangered;          margin: 50px auto;          border-radius: 65px 65px 0px 0px;     }     li:nth-child(4):after {          content: &quot;&quot;;          display: block;          width: 130px;          height: 130px;          border: 1px solid orangered;          margin: 20px auto;          border-radius: 65px 0px 0px 0px;     }     li:nth-child(5):after {          content: &quot;&quot;;          width: 130px;          height: 65px;          display: block;          border: 1px solid orangered;          border-radius: 50%;          margin: 50px auto;     }     li:nth-child(6):after{          content: &quot;&quot;;          height: 130px;          width: 65px;          display: block;          border: 1px solid orangered;          border-radius: 50%;          margin: 20px auto;     }     li:nth-child(7):after {          content: &quot;&quot;;          height: 130px;          width: 130px;          display: block;          border: 1px solid orangered;          margin: 20px auto;          border-radius: 135px 0px 0px 0px;     }     li:nth-child(8):after {          content: &quot;&quot;;          width: 135px;          height: 30px;          display: block;          margin: 30px auto;          border: 1px solid orangered;          border-radius: 65px 65px 0px 0px / 30px 30px 0px 0px;     }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099846?w=911&amp;h=500" alt="image"></p><h3 id="5-2-边框阴影"><a href="#5-2-边框阴影" class="headerlink" title="5.2 边框阴影"></a>5.2 边框阴影</h3><blockquote><p><code>box-shadow</code>，与文字阴影类似，可分别设置盒子阴影偏移量、模糊度、颜色（可设透明度）。</p></blockquote><p>如：</p><pre><code>box-shadow: 5px 5px 5px #CCC</code></pre><ul><li>1、水平偏移量 正值向右 负值向左；</li><li>2、垂直偏移量 正值向下 负值向上；</li><li>3、模糊度是不能为负值；</li><li>4、<code>inset</code>可以设置内阴影；</li></ul><p><em>注：设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。可以设置多重边框阴影，实现更好的效果，增强立体感，符合渐进增强，实际开发中可以大胆使用。</em></p><p><strong>示例代码：</strong></p><pre><code>&lt;style&gt;    .box {        width: 200px;        height: 200px;        margin: 50px auto;        border: 1px dashed #000;        box-shadow: 2px 3px 4px rgba(0, 247, 255, 0.452),inset 5px 6px 7px rgba(255, 0, 140, 0.562);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099847?w=254&amp;h=249" alt="image"></p><p><em>我们通过上图可以看到，虚线是盒子的位置，粉色阴影是inset属性设置的，所以是内阴影，浅蓝色是直接设置的外阴影，效果一目了然。</em></p><h2 id="6-背景"><a href="#6-背景" class="headerlink" title="6. 背景"></a>6. 背景</h2><blockquote><p>背景在<code>CSS3</code>中也得到很大程度的增强，比如背景图片尺寸、背景裁切区域、背景定位参照点、多重背景等。</p></blockquote><h3 id="6-1-background-size"><a href="#6-1-background-size" class="headerlink" title="6.1 background-size"></a>6.1 background-size</h3><blockquote><p>通过<code>background-size</code>设置背景图片的尺寸，就像我们设置<code>img</code>的尺寸一样，在移动<code>Web</code>开发中做屏幕适配应用非常广泛。</p></blockquote><p>其参数设置如下：</p><ul><li>可以设置长度单位(<code>px</code>)或百分比（设置百分比时，参照盒子的宽高）</li><li>设置为<code>cover</code>时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。</li><li>设置为<code>contain</code>会自动调整缩放比例，保证图片始终完整显示在背景区域。</li></ul><h3 id="6-2-background-origin"><a href="#6-2-background-origin" class="headerlink" title="6.2 background-origin"></a>6.2 background-origin</h3><blockquote><p>通过<code>background-origin</code>可以设置背景图片定位(<code>background-position</code>)的参照原点。</p></blockquote><p>其参数设置如下：</p><ul><li><code>border-box</code>以边框做为参考原点；</li><li><code>padding-box</code>以内边距做为参考原点；</li><li><code>content-box</code>以内容区做为参考点；</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box1,.box2,.box3 {        width: 200px;        height: 200px;        display: inline-block;        margin: 50px 30px;        border: 10px dashed aquamarine;        padding: 10px;        background-image: url(bg.jpg);        background-repeat: no-repeat;    }    .box1{        background-origin: padding-box;    }    .box2{        background-origin: content-box;    }    .box3{        background-origin: border-box;    }&lt;/style&gt;&lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box3&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099848?w=933&amp;h=387" alt="image"></p><h3 id="6-3-background-clip"><a href="#6-3-background-clip" class="headerlink" title="6.3 background-clip"></a>6.3 background-clip</h3><blockquote><p>通过<code>background-clip</code>，可以设置对背景区域进行裁切，即改变背景区域的大小。</p></blockquote><p>其参数设置如下：</p><ul><li><code>border-box</code>裁切边框以内为背景区域；</li><li><code>padding-box</code>裁切内边距以内为背景区域；</li><li><code>content-box</code>裁切内容区做为背景区域；</li></ul><p><img src="https://segmentfault.com/img/remote/1460000017099849?w=954&amp;h=411" alt="image"></p><h3 id="6-4-多背景"><a href="#6-4-多背景" class="headerlink" title="6.4 多背景"></a>6.4 多背景</h3><blockquote><p>以逗号分隔可以设置多背景，可用于自适应布局。在一个盒子里可以设置多个背景图片，通过背景定位的功能将两张图片组装起来。</p></blockquote><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 320px;        height: 410px;        margin: 50px auto;        background: url(head.jpg) no-repeat left top,                      url(foot.jpg) no-repeat left bottom;         background-size: contain;        background-color: #ccc;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099850?w=397&amp;h=517" alt="image"></p><p><em>从效果图中我们可以看到，在盒子里面设置了两张背景图，分别是上面一部分，下面一部分。这里故意给盒子高度拉长了一点，并且设置了一个灰色的背景，为的就是大家能够清楚的看到上下两部分的背景图。</em></p><h2 id="7-渐变"><a href="#7-渐变" class="headerlink" title="7. 渐变"></a>7. 渐变</h2><blockquote><p>渐变是<code>CSS3</code>当中比较丰富多彩的一个特性，通过渐变我们可以实现许多炫丽的效果，有效的减少图片的使用数量，并且具有很强的适应性和可扩展性。</p></blockquote><h3 id="7-1-线性渐变"><a href="#7-1-线性渐变" class="headerlink" title="7.1 线性渐变"></a>7.1 线性渐变</h3><blockquote><p><code>linear-gradient</code>线性渐变指沿着某条直线朝一个方向产生渐变效果。</p></blockquote><p><strong>1、必要的元素：</strong></p><blockquote><p>借助<code>Photoshop</code>总结得出线性渐变的必要元素</p></blockquote><ul><li>a、方向</li><li>b、起始色</li><li>c、终止色</li><li>d、渐变距离</li></ul><p><strong>2、关于方向</strong></p><blockquote><p>通过具体的方位词指定</p></blockquote><ul><li><code>to left</code></li><li><code>to right</code></li><li><code>to top</code></li><li><code>to bottom</code></li></ul><blockquote><p>通过角度改变渐变的方向</p></blockquote><ul><li><code>0°</code>，从下往上渐变</li><li><code>90°</code>，从左向右渐变</li></ul><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 400px;        height: 150px;        margin: 100px auto;        /* 线性渐变 */        background-image: linear-gradient(            /*渐变的方向*/            45deg,            /*渐变开始的颜色*/            #88f5ea,            /*渐变结束的颜色*/            #d36be7        );    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099851?w=685&amp;h=373" alt="image"></p><p><strong>3、渐变范围</strong></p><blockquote><p>如果不设置范围，默认渐变的范围是父盒子的宽度，如果通过<code>background-size</code>设置宽度的话，渐变范围即为设置的宽度。</p></blockquote><pre><code>&lt;style&gt;    .box {        width: 500px;        height: 100px;        margin: 100px auto;        background-image: linear-gradient(            135deg,            yellow 20%,            black 20%,            black 40%,            yellow 40%,            yellow 60%,            black 60%,            black 80%,            yellow 80%,            yellow         );        background-size: 66px 100px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099852?w=530&amp;h=123" alt="image"></p><h3 id="7-2-径向渐变"><a href="#7-2-径向渐变" class="headerlink" title="7.2 径向渐变"></a>7.2 径向渐变</h3><blockquote><p><code>radial-gradient</code>径向渐变指从一个中心点开始沿着四周产生渐变效果。</p></blockquote><p><strong>1、必要的元素：</strong></p><ul><li>a、辐射范围即圆半径</li><li>b、中心点 即圆的中心</li><li>c、渐变起始色</li><li>d、渐变终止色</li><li>e、渐变范围</li></ul><p><strong>2、关于中心点</strong></p><blockquote><p>中心位置参照的是盒子的左上角，例如：</p></blockquote><pre><code>&lt;style&gt;    #div{        width:200px;        height:200px;        background: radial-gradient(            /* 100px是渐变辐射的范围 0 0 指的是圆心在盒子的左上角 */            100px at 0 0,            /*渐变起始色*/            orange,            /*渐变终止色*/            #ff4500        )    }&lt;/style&gt;&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><img src="https://segmentfault.com/img/remote/1460000017099853?w=361&amp;h=345" alt="image"></p><p><strong>示例代码：镜像渐变画个球</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {        margin: 0;        padding: 0;    }    html,body {        width: 100%;        height: 100%;        background-color: #ccc;    }    .box {         width: 400px;         height: 400px;         background-color: #fff;         margin: 50px auto;         border-radius: 50%;         background-image: radial-gradient(               300px at 100px 100px,               rgba(0,0,0,.1),               rgba(0,0,0,.8)         );    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099854?w=801&amp;h=556" alt="image"></p><h2 id="8-过渡"><a href="#8-过渡" class="headerlink" title="8. 过渡"></a>8. 过渡</h2><blockquote><p>过渡是<code>CSS3</code>中具有颠覆性的特征之一，可以实现元素不同状态间的平滑过渡（补间动画），经常用来制作动画效果。</p></blockquote><h3 id="8-1-帧动画"><a href="#8-1-帧动画" class="headerlink" title="8.1 帧动画"></a>8.1 帧动画</h3><blockquote><p>通过一帧一帧的画面按照固定顺序和速度播放，如电影胶片。</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000017099855?w=311&amp;h=220" alt="image"></p><p><strong>示例代码：</strong></p><pre><code>&lt;!--    baidu.png这个背景图由64张图片横向组成，我们通过动态改变图片的位置，实现动画效果--&gt;&lt;style&gt;    body {        margin: 0;        padding: 0;        background-color: #F7F7F7;    }    .logo {        width: 270px;        height: 129px;        margin: 100px auto;        background-image: url(./baidu.png);        background-position: 0 0;    }&lt;/style&gt;&lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;&lt;script&gt;    var logo = document.querySelector(&#39;.logo&#39;);    var offset = -270;    var n = 0;    setInterval(function () {        n++;        logo.style.backgroundPosition = offset * n + &#39;px 0px&#39;;        if(n &gt;= 64) n = 0;    },100);&lt;/script&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099856?w=347&amp;h=193" alt="image"></p><p><em>这里不做详细了解，主要是为了区分与补间动画的区别。</em></p><h3 id="8-2-补间动画"><a href="#8-2-补间动画" class="headerlink" title="8.2 补间动画"></a>8.2 补间动画</h3><blockquote><p>自动完成从起始状态到终止状态的的过渡。</p></blockquote><p><strong>语法：transition</strong></p><blockquote><p>当前元素只要有“属性”发生变化时，可以平滑的进行过渡，并不仅仅局限于<code>hover</code>状态。</p></blockquote><ul><li><code>transition-property</code>设置过渡属性</li></ul><pre><code>/*设置哪些属性要参加到动画效果中*/transition-property: all;</code></pre><ul><li><code>transition-duration</code>设置动画过渡执行时间</li></ul><pre><code>transition-duration: 2s;</code></pre><ul><li><code>transition-timing-function</code>设置过渡速度类型</li></ul><pre><code>transition-timing-function:linear; /* ease| ease-in | ease-out | ease-in-out | linear; */</code></pre><ul><li><code>transition-delay</code>设置过渡延时</li></ul><pre><code>/*1s后，过渡动画开始过渡*/transition-delay: 1s;</code></pre><p><strong>连写：</strong></p><pre><code>/*          属性  执行时间 延时时间 过渡类型*/transition: all   2s       1s       linear;</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 250px;        height: 250px;        background-color: pink;        margin: 100px auto;        transition: all 2s 1s linear;    }    .box:hover {        width: 200px;        height: 200px;        border-radius:50%;        background-color: rgb(25, 221, 247);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099857?w=363&amp;h=342" alt="image"></p><p><em>我们可以看到，触发hover事件的时候延迟1s后开始执行动画。</em></p><p><strong>示例代码：过渡的实际应用</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    html,body {         margin: 0;         padding: 0;         width: 100%;         height: 100%;    }    .box {         width: 100%;         height: 100%;         background-color: #eee;    }    .l_box {         float: left;         width: 234px;         height: 300px;         margin: 100px 50px;         cursor: pointer;         transition: all 0.5s linear;    }    .l_box:hover {        box-shadow: -2px -2px 20px #777;        margin-top: 90px;    }    .r_box {         width: 234px;         height: 300px;         float: left;         margin: 100px 0px;         background-color: #fff;         text-align: center;         position: relative;    }    .cover {        position: absolute;        bottom: 0;        height: 0px;        width: 234px;        background-color: orange;        transition: all 1s linear;    }    .r_box:hover .cover {        height: 100px;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;l_box&quot;&gt;        &lt;img src=&quot;img/1.jpg&quot; alt=&quot;&quot;&gt;    &lt;/div&gt;    &lt;div class=&quot;r_box&quot;&gt;        &lt;img src=&quot;img/2.jpg&quot; alt=&quot;&quot;&gt;        &lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099858?w=586&amp;h=393" alt="image"></p><h2 id="9-2D转换"><a href="#9-2D转换" class="headerlink" title="9. 2D转换"></a>9. 2D转换</h2><blockquote><p>转换（<code>transform</code>）是<code>CSS3</code>中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合即将学习的过渡和动画知识，可以取代大量之前只能靠<code>Flash</code>才可以实现的效果。</p></blockquote><h3 id="9-1-位移"><a href="#9-1-位移" class="headerlink" title="9.1 位移"></a>9.1 位移</h3><blockquote><p><code>CSS3</code>中，通过<code>translate</code>属性对元素进行位移。</p></blockquote><p>移动<code>translate(x, y)</code>可以改变元素的位置，<code>x</code>、<code>y</code>可为负值；</p><ul><li>a、移动位置相当于自身原来位置</li><li>b、<code>y</code>轴正方向朝下</li><li>c、除了可以像素值，也可以是百分比，相对于自身的宽度或高度</li></ul><pre><code>transform: translate(100px, 30px);</code></pre><p><strong>示例代码</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .line {        height: 200px;        background-color: pink;    }    .box {        width: 100px;        height: 100px;        background-color: rgb(30, 230, 245);        transition: all 1s linear;    }    .line:hover .box {        /* 位移 */        transform: translate(100px, 30px);    }&lt;/style&gt;&lt;div class=&quot;line&quot;&gt;    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099859?w=637&amp;h=214" alt="image"></p><p><em>我们可以看到，鼠标移上去之后，蓝色盒子，分别向左和向下移动了一段距离。</em></p><h3 id="9-2-缩放"><a href="#9-2-缩放" class="headerlink" title="9.2 缩放"></a>9.2 缩放</h3><blockquote><p>缩放<code>scale(x, y)</code>可以对元素进行水平和垂直方向的缩放，<code>x</code>、<code>y</code>的取值可为小数；</p></blockquote><pre><code>/*宽和高都放大1倍*/transform: scale(1.5);</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 200px;        height: 200px;        background-color: pink;        margin: 50px auto;        transition: all 2s linear;    }    .box:hover {        /* 缩放 */        transform: scale(0.5);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099860?w=287&amp;h=265" alt="image"></p><h3 id="9-3-旋转"><a href="#9-3-旋转" class="headerlink" title="9.3 旋转"></a>9.3 旋转</h3><blockquote><p>旋转<code>rotate</code>(<code>deg</code>)可以对元素进行旋转，正值为顺时针，负值为逆时针；</p></blockquote><ul><li>a、当元素旋转以后，坐标轴也跟着发生的转变</li><li>b、调整顺序可以解决，把旋转放到最后</li></ul><pre><code>/* 顺时针旋转 90度 */transform: rotate(90deg);</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 200px;        height: 200px;        background-color: #0df3cd;        margin: 100px auto;        transition: all 2s linear;    }    .box:hover {        transform: rotate(-90deg);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099861?w=287&amp;h=265" alt="image"></p><p><strong>旋转原点：</strong></p><blockquote><p>默认情况下，旋转是按照元素的中心点旋转的，但是我们可以手动设置元素旋转的中心点。</p></blockquote><pre><code>transform-origin: 30px 40px;</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 150px;        height: 150px;        background-color: cyan;        margin: 100px auto;        transition: all 1s linear;        /* 设置旋转原点位置 */        /* transform-origin: left top; */        transform-origin: 30px 40px;    }    .box:hover {        transform: rotate(90deg);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099862?w=347&amp;h=332" alt="image"></p><p><strong>示例代码：扑克牌</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {        margin: 0;        padding: 0;    }    .box {         width: 310px;         height: 438px;         border: 1px solid #ccc;         margin: 50px auto;         position: relative;    }    .box img {         position: absolute;         transform-origin:bottom;         transition: all 2s linear;    }    .box:hover img:nth-child(1) {         transform: rotate(10deg);    }    .box:hover img:nth-child(2) {         transform: rotate(20deg);    }    .box:hover img:nth-child(3) {         transform: rotate(30deg);    }    .box:hover img:nth-child(4) {         transform: rotate(40deg);    }    .box:hover img:nth-child(5) {         transform: rotate(50deg);    }    .box:hover img:nth-child(6) {         transform: rotate(60deg);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;      &lt;img src=&quot;img/pk1.png&quot; alt=&quot;&quot;&gt;      &lt;img src=&quot;img/pk1.png&quot; alt=&quot;&quot;&gt;      &lt;img src=&quot;img/pk1.png&quot; alt=&quot;&quot;&gt;      &lt;img src=&quot;img/pk1.png&quot; alt=&quot;&quot;&gt;      &lt;img src=&quot;img/pk1.png&quot; alt=&quot;&quot;&gt;      &lt;img src=&quot;img/pk1.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099863?w=749&amp;h=595" alt="image"></p><h3 id="9-4-倾斜"><a href="#9-4-倾斜" class="headerlink" title="9.4 倾斜"></a>9.4 倾斜</h3><blockquote><p>倾斜<code>skew(deg, deg)</code>可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为<code>0</code>。</p></blockquote><pre><code>transform: skew(30deg,30deg);</code></pre><p><strong>示例代码：</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    .box {        width: 150px;        height: 150px;        background-color: cyan;        margin: 100px auto;        transition: all 2s linear;    }    .box:hover {        /* 倾斜 */        transform: skew(30deg, 30deg);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099864?w=253&amp;h=246" alt="image"></p><h3 id="9-5-矩阵"><a href="#9-5-矩阵" class="headerlink" title="9.5 矩阵"></a>9.5 矩阵</h3><blockquote><p>矩阵<code>matrix()</code>把所有的<code>2D</code>转换组合到一起，需要<code>6</code>个参数。<code>transform-origin</code>可以调整元素转换的原点，但是对于<code>transform: translate(x，y)</code>没有影响。我们可以同时使用多个转换，其格式为：<code>transform: translate() rotate() scale()</code> …等，其顺序会影转换的效果。</p></blockquote><p><a href="https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">详细可参见</a></p><h2 id="10-3D-转换"><a href="#10-3D-转换" class="headerlink" title="10. 3D 转换"></a>10. 3D 转换</h2><h3 id="10-1-3D-坐标轴"><a href="#10-1-3D-坐标轴" class="headerlink" title="10.1 3D 坐标轴"></a>10.1 3D 坐标轴</h3><blockquote><p>用<code>X</code>、<code>Y</code>、<code>Z</code>分别表示空间的<code>3</code>个维度，三条轴互相垂直。如下图：</p></blockquote><p><img src="https://segmentfault.com/img/remote/1460000017099865?w=368&amp;h=402" alt="image"></p><p><em>网格状的正方形，可以想象成是我们的电脑桌面2D平面。</em></p><p><strong>在 3D 转换中，前面 2D 转换的属性在这都可以使用：</strong></p><ul><li>位移</li></ul><pre><code>transform:translate(100px,100px,100px);</code></pre><ul><li>旋转</li></ul><pre><code>transform:rotate(30deg,30deg,30deg);</code></pre><ul><li>缩放</li></ul><pre><code>transform:scale(2,0.5,0.5);</code></pre><ul><li>倾斜</li></ul><pre><code>transform:skew(30deg,30deg,30deg);</code></pre><p><em>在3D转换中，一定要加上一个透视属性，才能在电脑2D平面中显示出3D的效果，透视属性请看下章。</em></p><h3 id="10-2-透视（perspective）"><a href="#10-2-透视（perspective）" class="headerlink" title="10.2 透视（perspective）"></a>10.2 透视（perspective）</h3><blockquote><p>电脑显示屏是一个<code>2D</code>平面，图像之所以具有立体感（<code>3D</code>效果），其实只是一种视觉呈现，通过透视可以实现此目的。<code>perspective</code>通过透视产生的<code>3D</code>效果，只是视觉呈现而已，并不是真正的<code>3d</code>立体的盒子；就是<code>近大远小</code>的效果。</p></blockquote><p>透视的概念其实很简单，就是“近大远小”。</p><p><img src="https://segmentfault.com/img/remote/1460000017099866?w=600&amp;h=600" alt="image"></p><p><strong>举个例子：</strong></p><blockquote><p>在<code>2D</code>转换的时候，我们知道一个<code>translate</code>属性，他分别可以设置向左向右或者向上向下平移，但是却不能向里面或外面平移。</p></blockquote><pre><code>&lt;style&gt;    .box{        width: 550px;        height: 150px;        margin: 100px auto;        padding: 6px;        border: 1px dashed #ccc;    }    .box li{        float: left;        width: 150px;        height: 150px;        padding: 0;        list-style: none;        margin-right: 50px;        transition: all 0.5s linear;    }    .box li:first-child{        background: salmon;    }    .box li:nth-child(2){        background: deepskyblue;    }    .box li:last-child{        background: khaki;        margin-right: 0px;    }    /* 第一个盒子向X轴的负方向移动100px */    .box li:first-child:hover{        transform: translateX(-100px);    }    /* 第二个盒子向Y轴的正方向移动100px */    .box li:nth-child(2):hover{        transform: translateY(100px);    }    /* 第三个盒子Z轴的负方向移动100px */    .box li:last-child:hover{        transform: translateZ(-100px);    }&lt;/style&gt;&lt;ul class=&quot;box&quot;&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099867?w=855&amp;h=383" alt="image"></p><p><em>没有加透视属性的时候，因为z轴是垂直电脑平面射出来的，translateZ是看不出效果的。</em></p><p><strong>如何设置透视属性？</strong></p><blockquote><p>给当前元素的直接父元素添加<code>perspective: 800px;</code>透视属性，注意这个值可以是随意的，但是最佳展现距离是<code>600px~1000px</code>。</p></blockquote><pre><code>&lt;style&gt;    .box{        width: 550px;        height: 150px;        margin: 100px auto;        padding: 6px;        border: 1px dashed #ccc;        /* 给变换的 li 的直接父元素 ul 添加透视属性 perspective */        perspective: 800px;    }    .box li{        float: left;        width: 150px;        height: 150px;        padding: 0;        list-style: none;        margin-right: 50px;        transition: all 0.5s linear;    }    .box li:first-child{        background: salmon;    }    .box li:nth-child(2){        background: deepskyblue;    }    .box li:last-child{        background: khaki;        margin-right: 0px;    }    /* 第一个盒子向X轴的负方向移动100px */    .box li:first-child:hover{        transform: translateX(-100px);    }    /* 第二个盒子向Y轴的正方向移动100px */    .box li:nth-child(2):hover{        transform: translateY(100px);    }    /* 第三个盒子Z轴的负方向移动100px */    .box li:last-child:hover{        transform: translateZ(-100px);    }&lt;/style&gt;&lt;ul class=&quot;box&quot;&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;    &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099868?w=855&amp;h=383" alt="image"></p><p><em>如图所示，在ul加上透视属性后，第三个盒子向着z轴的负方向移动了100px。</em></p><p><em>透视可以将一个2D平面，在转换的过程当中，呈现3D效果。（没有perspective，便“没有”Z轴）并非任何情况下都需要透视效果。</em></p><h3 id="10-3-3D呈现（transform-style）"><a href="#10-3-3D呈现（transform-style）" class="headerlink" title="10.3 3D呈现（transform-style）"></a>10.3 3D呈现（transform-style）</h3><blockquote><p>什么是<code>3D</code>呈现呢？不要与前面的透视搞混，透视只能使一个物体呈现近大远小的状态，不能呈现出一个立体感的东西，比如我在页面上用六个面组成一个正方形，通过透视你可能只能改变他的远近距离，并不能让他看起来像个立体的盒子，所以这里需要用到另一个属性：<code>transform-style</code>。</p></blockquote><pre><code>transform-style: preserve-3d | flat</code></pre><ul><li><code>flat</code>：所有子元素在<code>2D</code>平面呈现</li><li><code>preserve-3d</code>：保留<code>3D</code>空间</li></ul><p><em>必须设置在父元素身上并且父元素有转换（就是有变形）并且子元素也得有转换（变形）才能看得到效果。</em></p><p><strong>1、示例代码：正方体</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;    * {         margin: 0;         padding: 0;    }    .box {         width: 200px;         height: 200px;         margin: 150px auto;         position: relative;         /* 透视 */         /* perspective: 1000px; */         /* 转为立方体 */         transform-style: preserve-3d;         transform: rotateY(45deg) rotateX(30deg);    }    .box&gt;div {         position: absolute;         width: 100%;         height: 100%;    }    .left {        background-color: pink;        transform: rotateY(-90deg) translateZ(150px);    }    .right {        background-color: green;        transform: rotateY(90deg) translateZ(150px);    }    .top {        background-color: orange;        transform: rotateX(90deg) translateZ(150px);    }    .bottom {        background-color: blue;        transform: rotateX(-90deg) translateZ(150px);    }    .before {        background-color: red;        transform: translateZ(150px);    }    .back {        background-color: greenyellow;        transform: translateZ(-150px);    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;top&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;before&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;back&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099869?w=649&amp;h=492" alt="image"></p><p><strong>2、示例代码：3D 导航</strong></p><pre><code>&lt;style type=&quot;text/css&quot;&gt;     * {          margin: 0;          padding: 0;          list-style: none;     }     nav {          width: 600px;          height: 60px;          line-height: 60px;          margin: 200px auto;     }     li {          height: 60px;          width: 150px;          float: left;          position: relative;          transform-style: preserve-3d;          transition: all 0.5s ease-in;     }     span {          position: absolute;          width: 150px;          height: 60px;          display: block;         color: #fff;          text-align: center;     }     span:first-child{          background-color: #ff287a;         transform: rotateX(90deg) translateZ(30px);     }     span:last-child{         transform: translateZ(30px);         background-color: #00bdab;     }     li:hover {          transform: rotateX(-90deg);     }&lt;/style&gt;&lt;nav&gt;    &lt;ul&gt;        &lt;li&gt;            &lt;span&gt;Home&lt;/span&gt;            &lt;span&gt;主页&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;span&gt;Menu&lt;/span&gt;            &lt;span&gt;菜单&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;span&gt;Admin&lt;/span&gt;            &lt;span&gt;管理&lt;/span&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;span&gt;About&lt;/span&gt;            &lt;span&gt;关于我们&lt;/span&gt;        &lt;/li&gt;    &lt;/ul&gt;&lt;/nav&gt;</code></pre><p><strong>效果图：</strong></p><p><img src="https://segmentfault.com/img/remote/1460000017099870?w=648&amp;h=123" alt="image"></p><h3 id="10-4-3D呈现案例：3D轮播图"><a href="#10-4-3D呈现案例：3D轮播图" class="headerlink" title="10.4 3D呈现案例：3D轮播图"></a>10.4 3D呈现案例：3D轮播图</h3><p><strong>1、普通版 3D 轮播图</strong></p><p>实现思路：</p><ul><li>通过<code>CSS3</code>中<code>transform-style: preserve-3d</code>的概念，将视图设置成<code>3D</code>展示模式；</li><li>四张图片，分别设置其绕着<code>X</code>轴旋转的角度，分别对应四个立体面；</li><li>将旋转好的图片沿着<code>Z</code>轴平移盒子宽度的一半；</li><li>定义一个全局变量<code>num</code>，用来记录按钮点击的次数，当当按动按钮的时候，让<code>ul</code>旋转<code>num*90°</code>；</li></ul><p>示例代码：</p><pre><code>&lt;style&gt;    * {        padding: 0;        margin: 0;        list-style-type: none;    }    .box {        width: 960px;        height: 540px;        /* border: 5px solid #999; */        margin: 150px auto;    }    .box ul {        width: 960px;        height: 540px;        position: relative;        transform-style: preserve-3d;        transition: transform .6s;    }    .box ul li {        width: 100%;        height: 100%;        position: absolute;        left: 0;        top: 0;    }    img {        width: 100%;        height: 100%;    }    .box ul li:nth-child(1) {        transform: rotateX(90deg) translateZ(270px);    }    .box ul li:nth-child(2) {        transform: rotateX(-90deg) translateZ(270px);    }    .box ul li:nth-child(3) {        transform: rotateX(180deg) translateZ(270px);    }    .box ul li:nth-child(4) {        transform: translateZ(270px);    }    .btn {        width: 1080px;        margin: 0 auto;        position: relative;        height: 0px;        top: -470px;    }    .btn button {        width: 40px;        height: 80px;        border-radius: 10px;        background: rgba(0, 0, 0, 0.2);        border: none;        outline: none;        font: 900 24px/80px &#39;宋体&#39;;        color: #fff;    }    .btn button:frist-child {        float: left;    }    .btn button:last-child {        /* border-radius: 0 10px 10px 0; */        float: right;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;    &lt;ul&gt;        &lt;li&gt;&lt;img src=&quot;./imgs/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;./imgs/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;./imgs/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;img src=&quot;./imgs/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;div class=&quot;btn&quot;&gt;    &lt;button&gt;&amp;lt;&lt;/button&gt;    &lt;button&gt;&amp;gt;&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var btn = document.querySelectorAll(&#39;button&#39;);    var box = document.querySelector(&#39;.box&#39;);    var _ul = box.querySelector(&#39;ul&#39;);    var num = 0;    // btn 获取到的是一个伪数组    btn[1].onclick = function () {        num++;        _ul.style.transform = &#39;rotateX(&#39; + num * 90 + &#39;deg)&#39;    }    btn[0].onclick = function () {        num--;        _ul.style.transform = &#39;rotateX(&#39; + num * 90 + &#39;deg)&#39;;    }&lt;/script&gt;</code></pre><p>效果图：</p><p><img src="https://segmentfault.com/img/remote/1460000017099871?w=790&amp;h=513" alt="image"></p><p><strong>2、切割版 3D 轮播图</strong></p><p>实现思路：</p><ul><li>结构上将之前定义好的<code>ul</code>重复四次；</li><li>设定延时，整个动画执行时间是<code>0.8s</code>，设定每一个<code>ul</code>延迟执行<code>0.2s</code>，即第一个延时<code>0s</code>，第二个延时<code>0.2s</code>，第三个延时<code>0.4s</code>，第四个延时<code>0.6s</code>；</li><li>其余步骤同上，着重强调的是，相对于上面的案例，本案例给按钮加了限制，监听第一次所有的<code>ul</code>旋转结束之后，按钮才能再一次被点击。</li></ul><p>示例代码：</p><pre><code>&lt;style&gt;    * {        padding: 0;        margin: 0;        list-style-type: none;    }    .box {        width: 960px;        height: 540px;        margin: 150px auto;        display: flex;    }    .box ul {        width: 960px;        height: 540px;        position: relative;        transform-style: preserve-3d;        transition: transform .8s;    }    .box ul li {        width: 100%;        height: 100%;        position: absolute;        left: 0;        top: 0;        overflow: hidden;    }    img {        width: 960px;        height: 540px;    }    /* 设定延时 */    .box ul:nth-child(1) {      transition-delay:0s;    }    .box ul:nth-child(2) {      transition-delay:.2s;    }    .box ul:nth-child(3) {      transition-delay:.4s;    }    .box ul:nth-child(4) {      transition-delay:.6s;    }    /* 拼凑图片 */    .box ul:nth-child(2) img {      margin-left: -240px;    }    .box ul:nth-child(3) img {      margin-left: -480px;    }    .box ul:nth-child(4) img {      margin-left: -720px;    }    .box ul li:nth-child(1) {        transform: rotateX(90deg) translateZ(270px);    }    .box ul li:nth-child(2) {        transform: rotateX(-90deg) translateZ(270px);    }    .box ul li:nth-child(3) {        transform: rotateX(180deg) translateZ(270px);    }    .box ul li:nth-child(4) {        transform: translateZ(270px);    }    .btn {        width: 1080px;        margin: 0 auto;        position: relative;        height: 0px;        top: -470px;    }    .btn button {        width: 40px;        height: 80px;        border-radius: 10px;        background: rgba(0, 0, 0, 0.2);        border: none;        outline: none;        font: 900 24px/80px &#39;宋体&#39;;        color: #fff;    }    .btn button:frist-child {        float: left;    }    .btn button:last-child {        /* border-radius: 0 10px 10px 0; */        float: right;    }&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;&lt;ul&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;  &lt;li&gt;&lt;img src=&quot;./imgs/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&quot;btn&quot;&gt;&lt;button&gt;&amp;lt;&lt;/button&gt;&lt;button&gt;&amp;gt;&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var btn = document.querySelectorAll(&#39;button&#39;);    var box = document.querySelector(&#39;.box&#39;);    var _ul = box.querySelectorAll(&#39;ul&#39;);    var num = 0;    var flag = true;    // btn 获取到的是一个伪数组        btn[1].onclick = function () {      if (flag) {        flag = false;        num++;        for (var i = 0; i &lt; _ul.length; i++) {          _ul[i].style.transform = &#39;rotateX(&#39; + num * 90 + &#39;deg)&#39;;        }        // 监听最后一个transition事件结束的时候 将flag 置为 true 防止重复点击        _ul[_ul.length - 1].addEventListener(&#39;transitionend&#39;, function () {          flag = true;        })      }    }    btn[0].onclick = function () {      if (flag) {        flag = false;        num--;        for (var i = 0; i &lt; _ul.length; i++) {          _ul[i].style.transform = &#39;rotateX(&#39; + num * 90 + &#39;deg)&#39;;        }        _ul[_ul.length - 1].addEventListener(&#39;transitionend&#39;, function () {          flag = true;        })      }    }&lt;/script&gt;</code></pre><p>效果图：</p><p><img src="https://segmentfault.com/img/remote/1460000017099872?w=790&amp;h=513" alt="image"></p><h3 id="10-5-backface-visibility"><a href="#10-5-backface-visibility" class="headerlink" title="10.5 backface-visibility"></a>10.5 backface-visibility</h3><blockquote><p><code>backface-visibility</code>属性定义当元素不面向屏幕时是否可见。</p></blockquote><p>如果在旋转元素不希望看到其背面时，该属性很有用。有两个属性：</p><ul><li>1、<code>visible</code>背面是可见的</li><li>2、<code>hidden</code>背面是不可见的</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>做Typora入门（中文版）</title>
      <link href="/2018/11/27/zuo-typora-ru-men-zhong-wen-ban/"/>
      <url>/2018/11/27/zuo-typora-ru-men-zhong-wen-ban/</url>
      
        <content type="html"><![CDATA[<p>写Markdown费事？Typora让你像写word一样行云流水，所见即所得。</p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Typora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。</li><li>Markdown的语法因不同的解析器或编辑器而异，Typora使用的是<a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/" target="_blank" rel="noopener">GitHub Flavored Markdown</a>。</li></ul><iframe height="360" width="640" src="https://www.typora.io/img/beta.mp4" frameborder="0" allowfullscreen></iframe><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>Typora<a href="https://www.typora.io/#download" target="_blank" rel="noopener">下载</a>。</p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul><li>加粗： <code>Ctrl/Cmd + B</code></li><li>标题： <code>Ctrl/Cmd + H</code></li><li>插入链接： <code>Ctrl/Cmd + K</code></li><li>插入代码： <code>Ctrl/Cmd + Shift + C</code></li><li>行内代码： <code>Ctrl/Cmd + Shift + K</code></li><li>插入图片： <code>Ctrl/Cmd + Shift + I</code></li><li>无序列表： <code>Ctrl/Cmd + Shift + L</code></li><li>撤销： <code>Ctrl/Cmd + Z</code></li><li>一级标题：快捷键为Crtl + 1，以此类推</li></ul><h3 id="块元素"><a href="#块元素" class="headerlink" title="块元素"></a>块元素</h3><h4 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h4><p>在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。</p><h4 id="标题级别"><a href="#标题级别" class="headerlink" title="标题级别"></a>标题级别</h4><blockquote><p># 一级标题， 快捷键为Crtl + 1<br>## 二级标题，快捷键为Crtl + 2<br>###### 六级标题，快捷键为Crtl + 6</p></blockquote><h4 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h4><blockquote><p>> + 空格 + 引用文字</p></blockquote><h4 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h4><p>输入 <em>列表内容 将创建一个无序列表，该</em>符号可以替换为+或-。</p><p>输入1. 列表内容 将创建一个有序列表，其markdown源代码如下：</p><blockquote><p>无序列表<br>* AA<br>* BB<br>* CC</p><p>有序列表</p><ol><li>AA</li><li>BB</li><li>CC</li></ol></blockquote><h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><blockquote><p>- [ ] 不勾选<br>- [x] 勾选</p></blockquote><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>在Typora中输入””” + 回车，并在后面选择一个语言名称即可语法高亮。</p><blockquote><p>语法高亮:</p><pre><code>&gt; def helloWorld():&gt;     print &#39;hello, world&#39;&gt; \</code></pre></blockquote><h4 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h4><p>输入<code>$$</code>，然后按“回车”键，如下：<br>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$</p><blockquote><p>\$$<br>\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>\$$</p></blockquote><h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>输入<code>| 表头1 | 表头2 |</code>并回车。即可将创建一个包含两列的表，然后就像操作Word文档一样设置表格即可，没必要知道Markdown的复杂语法，因为这些语法会由Typora自动生成。效果如下：</p><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td></td></tr></tbody></table><h4 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h4><blockquote><p>你可以创建一个脚注，像这样<a href="这是上面的注释内容。">^1</a>.</p></blockquote><p>你可以创建一个脚注，像这样<a href="https://www.simon96.online/2018/10/18/Typora%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%AD%E6%96%87%E7%89%88%EF%BC%89/%E8%BF%99%E6%98%AF%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%B3%A8%E9%87%8A%E5%86%85%E5%AE%B9%E3%80%82" target="_blank" rel="noopener">^1</a>.</p><p>注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。</p><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>输入<code>***</code>或<code>---</code> 再按回车即可绘制一条水平线，如下：</p><hr><h4 id="YAML-Front-Matter"><a href="#YAML-Front-Matter" class="headerlink" title="YAML Front Matter"></a>YAML Front Matter</h4><p>Typora支持<a href="http://jekyllrb.com/docs/frontmatter/" target="_blank" rel="noopener">YAML Front Matter</a>， 在文章开头输入<code>---</code>，然后按回车即可。</p><h4 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h4><p>输入<code>[toc]</code>然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><h3 id="跨度元素"><a href="#跨度元素" class="headerlink" title="跨度元素"></a>跨度元素</h3><p>跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h5><blockquote><p>这是一个带有标题属性的<a href="http://example.com/&gt; “标题”" target="_blank" rel="noopener">链接</a>.<br>这是一个没有标题属性的<a href="http://example.net/" target="_blank" rel="noopener">链接</a>&gt;.</p></blockquote><p>效果如下：</p><p>这是一个带有标题属性的<a href="http://example.com/" target="_blank" rel="noopener">链接</a>.<br>这是一个没有标题属性的<a href="http://example.net/" target="_blank" rel="noopener">链接</a>.</p><h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><blockquote><p>这是一个[参考链接]<a href="http://example.com/" target="_blank" rel="noopener">id</a>。<br>[id]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> “标题”</p></blockquote><p>这是一个<a href="http://example.com/" target="_blank" rel="noopener">参考链接</a>。</p><h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><p>Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。输入[<a href="mailto:td_simon@outlook.com" target="_blank" rel="noopener">td_simon@outlook.com</a>](mailto:<a href="mailto:td_simon@outlook.com" target="_blank" rel="noopener">td_simon@outlook.com</a>) 即 <a href="mailto:td_simon@outlook.com" target="_blank" rel="noopener">td_simon@outlook.com</a>。<br>Typora还会自动链接标准网址。例如：<a href="http://www.simon96.online./" target="_blank" rel="noopener">www.simon96.online。</a></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><blockquote><p><img src="/path/to/img.jpg" alt="显示的文字"><br><img src="/path/to/img.jpg" alt="显示的文字" title="图片标题"></p></blockquote><h4 id="倾斜"><a href="#倾斜" class="headerlink" title="倾斜"></a>倾斜</h4><pre><code>&gt; *单个星号*&gt; _单下划线_</code></pre><p>效果如下：<br><em>单个星号</em></p><p><em>单下划线</em></p><h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><pre><code>&gt; *两个星号*&gt; _双下划线_</code></pre><p>效果如下：<br><strong>两个星号</strong><br><strong>双下划线</strong></p><h4 id="代码标记"><a href="#代码标记" class="headerlink" title="代码标记"></a>代码标记</h4><p>标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号——</p><p>使用该<code>printf()</code>功能。<br>效果如下：<br>使用该<code>printf()</code>功能。</p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><blockquote><p><code>~~删除线~~</code></p></blockquote><p>效果如下：</p><p><del>删除线</del></p><h4 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h4><p><code>&lt;u&gt;\下划线&lt;/u&gt;</code></p><p>效果如下：</p><p><u>\下划线</u></p><h4 id="表情符号-smile"><a href="#表情符号-smile" class="headerlink" title="表情符号:smile:"></a>表情符号:smile:</h4><blockquote><p>：smile ：（注意为：是英文的冒号）</p></blockquote><p>:smile:</p><h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><p>H~2~O (需在设置中打开该功能)</p><h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><p>X^2^(需在设置中打开该功能)</p><h4 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h4><p>==高亮==(需在设置中打开该功能)</p><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>支持HTML</p><h4 id="嵌入内容"><a href="#嵌入内容" class="headerlink" title="嵌入内容"></a>嵌入内容</h4><p>支持iframe-based嵌入代码，</p><blockquote><p>&lt; iframe height=’265’ scrolling=’no’ title=’Fancy Animated SVG Menu’ src=’<a href="http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2%27" target="_blank" rel="noopener">http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2’</a> frameborder=’no’ allowtransparency=’true’ allowfullscreen=’true’ style=’width: 100%;’&gt;</p></blockquote><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><blockquote><p>&lt; video src=”xxx.mp4” /&gt;</p></blockquote><hr><p><strong>总结：</strong></p><ol><li>建议打开大纲视图（快捷键ctrl + shift + 1）。</li><li>插入表格需要顶格写，不然显示不出来。</li><li>以上语法不用刻意记，在Typora中的右键菜单都有， 常用功能基本上都有快捷键。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>做一个好前端必须要知道的事——JS语言</title>
      <link href="/2018/11/27/zuo-yi-ge-hao-qian-duan-bi-xu-yao-zhi-dao-de-shi-js-yu-yan/"/>
      <url>/2018/11/27/zuo-yi-ge-hao-qian-duan-bi-xu-yao-zhi-dao-de-shi-js-yu-yan/</url>
      
        <content type="html"><![CDATA[<h1 id="做一个好前端必须要知道的事——JS语言"><a href="#做一个好前端必须要知道的事——JS语言" class="headerlink" title="做一个好前端必须要知道的事——JS语言"></a>做一个好前端必须要知道的事——JS语言</h1><p>编程语言按各种方法可以分为各种类型，现在让我们来看看JS属于什么类型语言</p><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>按编译执行过程，可以分为编译型语言和解释型语言。比如</p><ul><li>c 语言，必须先经过编译生成目标文件，然后链接各个目标文件和库文件，生成可执行文件。</li><li>Java、scala 则是先编译成字节码，然后解释执行字节码（可以理解为编译型语言也可以理解为解释型语言）。准确的理解，java 是编译型语言，源代码整个编译成字节码，java 字节码，是解释型语言。</li><li>Python 是解释型语言，不过也可以先进行编译，编译成 python 的字节码。</li><li>Javascript 是解释型语言。目前貌似还没有直接将 js 整个编译然后才执行（有说法是 js 动态性太强，先整体编译难度太大，执行性能不如解释执行高）。</li></ul><p>⚠️注意：解释型语言也是需要编译的。区分编译型语言和解释型语言，是看源代码是否整个编译成目标代码然后执行还是编译一段执行一段。<br>对于传统编译型语言来说，编译步骤分为：词法分析、语法分析、语义检查、代码优化和字节生成。<br>但对于解释型语言来说，通过词法分析和语法分析得到语法树后，就可以开始解释执行了（根据语法树和符号表生成机器码）。<br>这也就解释了为什么都说 js 是解释执行的，读一句执行一句，但是实际上 js 中还没执行到的代码语法错误导致整个 js 不会执行的问题。例如：</p><pre class=" language-bash"><code class="language-bash">console.log<span class="token punctuation">(</span><span class="token string">'不会被console出来'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">=</span> // 这里的语法错误导致了上面的代码也不会执行</code></pre><p>其实js变量提升的现象也很明显的证明了js是先编译而后执行的<br>在浏览器中，多个&lsaquo;script&rsaquo;标签中的 js 代码，是分段编译的（所以，某一个&lsaquo;script&rsaquo;标签中的语法错误不会导致另一个&lsaquo;script&rsaquo;中的代码不执行）但是全局对象是共享的。</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>按语言按变量的类型在编译时确定还是运行时确定可以分为静态语言和动态语言。比如</p><ul><li>java，String s = null; 变量 s 的类型在编译时就可以确定为字符串类型。</li><li>python，变量不需要声明，变量的类型在第一次赋值时由值的类型确定。</li><li>js，let val;let = ‘1’; 变量 val 在运行 val=’1’时才能确定为字符串类型。</li></ul><h2 id="弱类型语言"><a href="#弱类型语言" class="headerlink" title="弱类型语言"></a>弱类型语言</h2><p>按变量的类型是否在运行时可以改变分为强类型语言和弱类型语言。比如</p><ul><li>Java、scala 是强类型语言，变量一旦声明，它的类型以后不能被改变。</li><li>Python 是强类型语言。</li><li>Js 是弱类型语言。比如 let v = ‘1’;v=1;v=true;这在 js 中是合法的。</li></ul><h2 id="非常灵活的语言"><a href="#非常灵活的语言" class="headerlink" title="非常灵活的语言"></a>非常灵活的语言</h2><p>按语言范式可以分为声明式、命令式、函数式语言。</p><ul><li>声明式编程，告诉计算机我要做什么，而不是如何做。在更高层面写代码，更关心的是目标，而不是底层算法实现的过程。例如 css, 正则表达式，sql 语句，html, xml…</li><li>命令式编程，告诉计算机如何做，而不管我想要做什么。解决某一问题的具体算法实现。例如 java、c。</li><li>函数式编程，将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。</li><li>很多语言并不是单纯的支持某一种范式，像 java8 也添加了部分对函数式的支持。 </li><li>js 是一个非常灵活的语言，支持命令式和函数式编程。</li></ul><h2 id="各种类型语言的优缺点"><a href="#各种类型语言的优缺点" class="headerlink" title="各种类型语言的优缺点"></a>各种类型语言的优缺点</h2><ul><li>一般编译型语言性能比解释型语言高。但是由于编译型语言需要先进行编译。</li><li>解释型语言的好处是，部署到线上的是源代码，可以直接修改线上环境的代码，解决一些 bug。比如我们有时候直接修改线上的 js 代码。</li><li>编译型语言通常会用 xml 做配置文件，因为我们通常不会改编译后的字节码。解释型语言的配置，直接写在源代码里更方便，用 xml 做配置就显得多余。</li><li>静态语言，有利于编译时检查。比如 java、在 ide 中为对象的一个不存在的属性赋值能在编译时检查出错误。</li><li>Js 是动态语言。对象的某个属性是否存在，在编译时无法确定。这导致某些错误要到运行时才可能发现。所以一般 js 程序的正确性，更需要单元测试保证。</li><li>强类型语言由于类型在声明之后不允许改变，所以能实现编译时类型检查。动态语言和弱类型语言，则更灵活，实现相同功能的代码量通常更少或者更容易实现复杂功能。当然可读性可维护性方面不如静态语言和强类型语言。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>纯CSS打造银色MacBook Air（完整版）</title>
      <link href="/2018/11/26/chun-css-da-zao-yin-se-macbook-air-wan-zheng-ban/"/>
      <url>/2018/11/26/chun-css-da-zao-yin-se-macbook-air-wan-zheng-ban/</url>
      
        <content type="html"><![CDATA[<h2 id="纯CSS打造银色MacBook-Air（完整版）"><a href="#纯CSS打造银色MacBook-Air（完整版）" class="headerlink" title="纯CSS打造银色MacBook Air（完整版）"></a>纯CSS打造银色MacBook Air（完整版）</h2><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前段时间自己用CSS绘制了一个银色的MacBook Air，今天把它从电脑硬盘深处挖了出来，我把我的思路和想法写下来和小伙伴们分享分享。先把最后的效果给大家。</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkAHI.jpg" alt="FAkAHI.jpg"></p><p>这其实是一个半成品，键盘上的其他图标和文字都还没有加，图标的话可以用font-face，待我找着合适的字体图标网址链接后给大家补全，同时也欢迎小伙伴们捣腾。</p><h2 id="零、第零步"><a href="#零、第零步" class="headerlink" title="零、第零步"></a>零、第零步</h2><p>这里使用了CSS的before、after伪元素、渐变gradient、阴影、nth-child选择器等相关内容，阴影和渐变效果从图片上可能看的不太清楚，小伙伴们可以去上面的Codepen上查看，文章的最后我会给出整个源代码，有兴趣的可以自己随意修改完善。</p><p>Ok，开始肆无忌惮地进入。</p><p>首先介绍一下绘制的结构。</p><p>对于键盘，就是建立了一个无序列表ul，然后写上若干个li即可，其他的用几个div包裹即可，先给出HTML结构：</p><pre><code>&lt;div class=&quot;board&quot;&gt;&lt;div class=&quot;blackbar&quot;&gt;&lt;/div&gt;&lt;div class=&quot;keyboard&quot;&gt;&lt;ul&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&quot;touch&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>4个div加上2个伪元素，总共六个部分构成整个MacBook Air。board是MacBook Air的底座，blackbar是屏幕的那个黑色旋转轴，keyboard是键盘，touch是触控板；board:before是上面的盖子，border-bottom是盖子下面的那个黑色细长条。Ok，这六部分构成了整个MacBook Air。</p><p>没图我说个什么：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkkDA.jpg" alt="FAkkDA.jpg"></p><p>接下来，我按照我的绘制顺序一步步来介绍。口渴的小伙伴可以先去沏杯茶。</p><h2 id="一、第一步"><a href="#一、第一步" class="headerlink" title="一、第一步"></a>一、第一步</h2><p>先给出HTML，下面是一段很长很长但是却没什么研究价值的无序列表，让滚轮飞起来吧：</p><pre><code>&lt;div class=&quot;board&quot;&gt;&lt;div class=&quot;blackbar&quot;&gt;&lt;/div&gt;&lt;div class=&quot;keyboard&quot;&gt;&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;@&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;&amp;&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;—&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;Q&lt;/li&gt;&lt;li&gt;W&lt;/li&gt;&lt;li&gt;E&lt;/li&gt;&lt;li&gt;R&lt;/li&gt;&lt;li&gt;T&lt;/li&gt;&lt;li&gt;Y&lt;/li&gt;&lt;li&gt;U&lt;/li&gt;&lt;li&gt;I&lt;/li&gt;&lt;li&gt;O&lt;/li&gt;&lt;li&gt;P&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;A&lt;/li&gt;&lt;li&gt;S&lt;/li&gt;&lt;li&gt;D&lt;/li&gt;&lt;li&gt;F&lt;/li&gt;&lt;li&gt;G&lt;/li&gt;&lt;li&gt;H&lt;/li&gt;&lt;li&gt;J&lt;/li&gt;&lt;li&gt;K&lt;/li&gt;&lt;li&gt;L&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;Z&lt;/li&gt;&lt;li&gt;X&lt;/li&gt;&lt;li&gt;C&lt;/li&gt;&lt;li&gt;V&lt;/li&gt;&lt;li&gt;B&lt;/li&gt;&lt;li&gt;N&lt;/li&gt;&lt;li&gt;M&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;By Pure CSS.To Be Continued.&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&quot;touch&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>键盘按键为若干个li，其中按键上有两个符号的我用两个span包了起来，像这样：</p><pre><code>&lt;li&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/li&gt;</code></pre><p>因为它们最后式一上一下的69体位，用span包裹住便于分别布置它们的位置。</p><p>先绘制一个600&lowast;450的div，并将board居中，给一个银色的color，这里用的是rgb(210,210,210)，用border-radius绘制出四个20px的圆角，用box-shadow给出一个灰色的阴影，这里用的灰色是rgb(160,160,160)，小伙伴们可以自己选择合适的颜色，最后从div的左下角到右上角以60度添加一个线性渐变linear-gradient，是从白色开始从四分之一出过渡到灰色。因为之后的div会用到绝对定位，所以在此先把其父元素board定位为relative。</p><p>完整的代码及效果如下：</p><pre><code>.board{    margin: 0 auto;    padding: 0 auto;    width: 600px;    height: 450px;    margin-top: 50px;    background: rgb(210,210,210);    border-radius: 20px;    position: relative;    box-shadow: 0px 5px 6px rgb(160,160,160);    background:-webkit-linear-gradient(60deg,rgba(250,250,250,1) 25%,rgba(210,210,210,1));}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkFud.jpg" alt="FAkFud.jpg"></p><p>这样，一个有阴影和线性渐变过渡效果的面板就率先完成了。</p><h2 id="二、第二步"><a href="#二、第二步" class="headerlink" title="二、第二步"></a>二、第二步</h2><p>接下来我要画笔记本盖子，用的是伪元素board:before。</p><p>因为盖子是翻起来的，所以从上往下看是一个窄边。把board:before填充为780px&lowast;20px的div，背景颜色为灰色。</p><p>实现及效果如下：</p><pre><code>.board:before{    content: &#39;&#39;;    display: block;    width: 780px;    height: 20px;    background: rgb(210,210,210);}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkPjH.jpg" alt="FAkPjH.jpg"></p><p>然后调一下位置，board:before定位为绝对定位，board宽600px，盖子宽780px，所以left=-(780-600)/2=-90px，top为board:before的高20px，顺带做出一个大弧形的效果，水平半径取大一些，垂直半径取小一些，like this：</p><pre><code>border-top-left-radius: 390px 18px;border-top-right-radius: 390px 18px;</code></pre><p>此时的效果如下：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkCge.jpg" alt="FAkCge.jpg"></p><p>有那么个意思了，为了做出立体的效果，我们给盖子从上到下加个渐变的过渡效果：</p><pre><code>background:-webkit-linear-gradient(top,rgb(210,210,210) 50%,rgb(255,255,255));</code></pre><p>再顺带把屏幕下的那条小黑条加上，一句话很简单：</p><pre><code>border-bottom: 2px solid rgb(0,0,0);</code></pre><p>看看效果先：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkVEt.jpg" alt="FAkVEt.jpg"></p><p>有没有感觉某些地方有些违和？放大看一下这里：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAknC8.jpg" alt="FAknC8.jpg"></p><p>来个更加菊部的：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkZUP.jpg" alt="FAkZUP.jpg"></p><p>对，就是这个小角处，给点效果：</p><pre><code>border-bottom: 2px solid rgb(0,0,0);</code></pre><p>再看看效果：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAke4f.jpg" alt="FAke4f.jpg"></p><p>这样黑边那也有了小的光滑弧度过渡，显得更加自然。</p><p>附上这一步的完整代码和效果：</p><pre><code>.board:before{    content: &#39;&#39;;    display: block;    width: 780px;    height: 20px;    background: rgb(210,210,210);    border-radius: 0px 0px 3px 3px;    border-top-left-radius: 390px 18px;    border-top-right-radius: 390px 18px;    position: absolute;    top:-20px;     left: -90px;    border-bottom: 2px solid rgb(0,0,0);     background:-webkit-linear-gradient(top,rgb(210,210,210) 50%,rgb(255,255,255));}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkKgg.jpg" alt="FAkKgg.jpg"></p><h2 id="三、第三步"><a href="#三、第三步" class="headerlink" title="三、第三步"></a>三、第三步</h2><p>这一步我们来做屏幕旋转轴，也就是屏幕下方的那条黑色矩形blackbar。</p><p>同样先设置width和height，absolute定位，居中显示，移动的距离可以参考上面的方法小算一下就可以了，加上2px的圆角，为了显示出旋转轴立体的沟槽，我们给blackbar类的下边框和右边框加上2px的白色实线，同时给blackbar一个从上到下的渐变，中间显示出窄窄的亮丽的白色即可，颜色和过渡的位置小伙伴们可以自行了断，oops，是自行把握。</p><p>实现和效果：</p><pre><code>.blackbar{    width: 450px;    height: 18px;    position: absolute;     left: 75px;    border-radius: 2px;    border-bottom: 2px solid #ffffff; /* 小白边 */    border-right: 2px solid #ffffff;    background: -webkit-linear-gradient(top,rgb(30,30,30) ,rgb(60,60,60) 35%,rgb(100,100,100) 50%,rgb(30,30,30) 65%);    background: -linear-gradient(top,rgb(30,30,30) ,rgb(60,60,60) 35%,rgb(100,100,100) 50%,rgb(30,30,30) 65%);}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAku8S.jpg" alt="FAku8S.jpg"></p><h2 id="四、第四步"><a href="#四、第四步" class="headerlink" title="四、第四步"></a>四、第四步</h2><p>接下来就是MacBook Air最显眼的部分了，那就是键盘部分，为什么显眼呢，因为它占的地儿最大吧哈哈哈（不好笑的事也要大笑三声）。</p><p>在画键盘之前呢，小伙伴们最好先算好整个键盘区域的大小，各个按键的大小和排列，否则到时候只能一点点重新调，很麻烦。好了，咱先把键盘区域画下来吧。</p><p>传统步骤，设置宽高，绝对定位，然后设置left、top居中，勾勒出1px solid 颜色为rgb(180,180,180)的border，8px的圆角，白色的背景颜色；</p><p>实现和效果如下：</p><pre><code>.keyboard{    position: absolute;    width:530px;    height: 216px;    left: 35px;    top: 35px;    border: 1px solid rgb(180,180,180);    border-radius: 8px;    background:rgba(250,250,250,1);}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkMvQ.jpg" alt="FAkMvQ.jpg"></p><p>为了显示出立体的沟槽感，阴影又该出来了。我们用box-shadow给keyboard的四条边框添加四条内部inset阴影，关于box-shadow以后有机会再讲，先把实现和效果贴上：</p><pre><code>box-shadow:2px 0px 2px rgb(180,180,180) inset,0px 3px 3px rgb(180,180,180) inset,-5px -0px 1px rgb(255,255,255) inset,0px -3px 3px rgb(180,180,180) inset;</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkNCT.jpg" alt="FAkNCT.jpg"></p><p>雏形出来了，接下来就是一个个的nth-child了。让我们接着猛烈地荡起双桨吧。</p><h2 id="五、第五步"><a href="#五、第五步" class="headerlink" title="五、第五步"></a>五、第五步</h2><p>就像前面提到的，我们最好事先先计算好每个按键的大小和位置，做到心中有数，不至于到时候一片混乱，否则整个键盘就像东汉末年似的这一块儿那一块儿。</p><p>首先是一些常规的设置，去掉列表标志，margin、padding设置，列表的宽和高balabala，按照之前的计算，设置按键与按键的间距，大致排列下这么多个按键，并给按键添加4px的圆角，为了显示立体效果，加上一个border：</p><pre><code>border: 1px solid rgb(70,70,70);</code></pre><p>并四个边添加阴影：</p><pre><code>box-shadow: 1px 0px 0px rgb(0,0,0),0px 1px 0px rgb(0,0,0),-1px 0px 0px rgb(0,0,0),0px -1px 0px rgb(0,0,0);</code></pre><p>附上代码和效果:</p><pre><code>ul,li{    list-style: none;    margin:0 auto;    padding:0 auto;    display: block;    font-family: &quot;Vrinda&quot;;    -webkit-user-select: none;    -moz-user-select: none;    -ms-user-select: none;    user-select: none;}ul{    width:530px;    margin-top: 8px;    padding-left: 8px;    /* border:2px solid black; */}li{    width:29px;    height:29px;    float: left;    /* padding-left: 0px; */    margin-right: 5px;    margin-bottom: 5px;    background-color: rgb(30,30,30);    color: rgb(200,200,200);    text-align: center;    line-height: 28px;    font-size: 12px;    border-radius: 4px;    border: 1px solid rgb(70,70,70);    box-shadow: 1px 0px 0px rgb(0,0,0),    0px 1px 0px rgb(0,0,0),    -1px 0px 0px rgb(0,0,0),    0px -1px 0px rgb(0,0,0);}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkluj.jpg" alt="FAkluj.jpg"></p><p>看上去还很乱，连文本都溢出了，但是妈妈说过，心急吃不了热豆腐，慢慢来，保准等会就驯服得她服服帖帖的。</p><p>Tips：请用力记住父母的生日哦。</p><p>细心的小伙伴们会发现有一段代码，貌似不细心的也能发现，就是这段：</p><pre><code>-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;</code></pre><p>这是什么意思呢？先来看下不加这段代码的效果：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAk1Ds.jpg" alt="FAk1Ds.jpg"></p><p>对，就是这一片的蓝色，当用鼠标去键盘上拖着选中的时候，那一个个的li就会被选中，添加这段代码就能还我们一片巧克力键盘了，就能还我们一个洁白的蓝天了。</p><p>洁白…的…蓝天…^o^</p><p>我们先把键盘最上面的那一排功能键先捣腾好。这里我们用nth-child来选择上面那一排我没数错数量应该是14个的功能键，并给它们简单设置样式。</p><p>这里使用链式写法，实现和效果如下：</p><pre><code>li:nth-child(-n+14):nth-child(n+1){    width:30px;    height:15px;}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAk3bn.jpg" alt="FAk3bn.jpg"></p><p>接下来调整第二行的数字按键上的那些数字和符号的一上一下的69体位，同样先用nth-child选中再设置样式：</p><pre><code>li:nth-child(-n+27):nth-child(n+16) span,li:nth-child(40) span,li:nth-child(41) span,li:nth-child(42) span,    li:nth-child(53) span,li:nth-child(54) span,li:nth-child(-n+66):nth-child(n+64) span{    display: block;    margin-top: 5px;    line-height: 0.5; }</code></pre><p>然后设置除了最后的那四个方向键外的其他键的大小，很简单，算准写就行，要做一个心中有数的男人，这块直接贴代码：</p><pre><code>li:nth-child(28),li:nth-child(29){    width:45px;}li:nth-child(43),li:nth-child(55){    width:55px;}li:nth-child(56),li:nth-child(67){    width:73px;}    li:nth-child(-n+74):nth-child(n+68){    height:33px;}li:nth-child(72){    width:173px;}li:nth-child(71),li:nth-child(73){    width:37px;}</code></pre><p>找个驿站半路休息下先，顺带看下效果：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkGEq.jpg" alt="FAkGEq.jpg"></p><p>除了四个方向键，其他的按键放置得还算可以，接着走。</p><p>四个方向键设置也很简单，设置宽高，定位即可，不罗嗦了，直接上：</p><pre><code>li:nth-child(75),li:nth-child(77),li:nth-child(78){    margin-top: 18px;    height: 14px;}li:nth-child(76){    height: 13px;    margin-top: 19px;}li:nth-child(78){    position: absolute;    bottom: 22px;    right:38px;}</code></pre><p>效果：</p><p><img src="https://s1.ax1x.com/2018/11/26/FAkY5V.jpg" alt="FAkY5V.jpg"></p><p>恩，美感效果还在我的审美范围之内。</p><h2 id="六、第六步"><a href="#六、第六步" class="headerlink" title="六、第六步"></a>六、第六步</h2><p>最后一步就是触控板touch的绘制了，哈哈哈，终于要诺曼底登陆了，待我喝口菊花茶先。</p><p>触控板的绘制和键盘的绘制基本上是一样的，设置大小，定位，圆角，border即可。直接上：</p><pre><code>.touch{    position: absolute;    width:200px;    height:150px;    border: 2px solid rgb(190,190,190);    bottom: 23px;    left: 200px;    border-radius: 8px;}</code></pre><p><img src="https://s1.ax1x.com/2018/11/26/FAkJU0.jpg" alt="FAkJU0.jpg"></p><h2 id="七、小了个结"><a href="#七、小了个结" class="headerlink" title="七、小了个结"></a>七、小了个结</h2><p>到这里，MacBook Air就算完成了，还是那句话，是个半成品，一些字体图标还待用font-face来完成，当然还可以添加些动画，让它像产品旋转来展示等等，这只是抛砖引玉而已，期待小伙伴们更多奇思妙想。小伙伴们有好的想法欢迎分享~~~</p><p>源自：<a href="http://www.cnblogs.com/myvin/p/4621231.html" target="_blank" rel="noopener">www.cnblogs.com/myvin/p/4621231.html</a><br>声明：文章著作权归作者所有，如有侵权，请联系小编删除。<br>感谢 · 转发<br>欢迎大家留言</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML基础知识总结</title>
      <link href="/2018/11/22/html-ji-chu-zhi-shi-zong-jie/"/>
      <url>/2018/11/22/html-ji-chu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>经过这段时间的学习，对于html的一些基础知识有了一定的了解。所谓好记性不如烂笔头，唯有一点点累积，才能汇聚成知识的海洋。现在，我对这段时间的学习做一个总结。</p><h2 id="一、HTML的定义"><a href="#一、HTML的定义" class="headerlink" title="一、HTML的定义"></a>一、HTML的定义</h2><p>   HTML，超文本标记语言，写给浏览器的语言，目前网络上应用最广泛的语言。HTML也在不断的更新，最新版本已经出现了HTML5。在HTML5中出现了许多新特性，也遗弃了一些旧元素。我们写好html文件后，在浏览器中打开。主流的浏览器包括IE、Firefox、Chrome、Goole等。</p><h2 id="二、HTML标签元素"><a href="#二、HTML标签元素" class="headerlink" title="二、HTML标签元素"></a>二、HTML标签元素</h2><p>HTML元素由开始标签和结束标签组成。虽然现在我们还不知道具体标签代表的意思，但标签一定是这样的格式：有一对开始&lt;&gt;和结束&lt;/&gt;。一般标签名推荐用小写。标签具有属性，属性用来表示标签的特征。比如，我们用大小这个属性，来衡量一个苹果。所以，大小可以用来表示苹果的特征。属性时写在标签里面的，而且是开始标签内。</p><h2 id="三、HTML-的基本结构"><a href="#三、HTML-的基本结构" class="headerlink" title="三、HTML 的基本结构"></a>三、HTML 的基本结构</h2><p>结构由网页的头部和网页的身体组成。如下例子：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>html<span class="token operator">></span>    <span class="token operator">&lt;</span>head<span class="token operator">></span>        <span class="token operator">&lt;</span>title<span class="token operator">></span>这是我的博客<span class="token operator">&lt;</span>/title<span class="token operator">></span>    <span class="token operator">&lt;</span>/head<span class="token operator">></span>    <span class="token operator">&lt;</span>body<span class="token operator">></span>      这是我的身体。    <span class="token operator">&lt;</span>/body<span class="token operator">></span><span class="token operator">&lt;</span>/html<span class="token operator">></span></code></pre><p>在上面的例子中，第一个标签<html>是告诉浏览器这是html文档的开始。Html文档的最后一个标签是</html>，是告诉浏览器这是html的终止。标签<head><meta name="generator" content="Hexo 3.8.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>之间的文本是头部信息，在<title></title>之间的文本是文档标题，会显示在浏览器的窗口的标题栏。<body><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>之间的文本是正文。</p><h2 id="四、规范的html页面"><a href="#四、规范的html页面" class="headerlink" title="四、规范的html页面"></a>四、规范的html页面</h2><h3 id="1、文档声明"><a href="#1、文档声明" class="headerlink" title="1、文档声明"></a>1、文档声明</h3><p>在<html>前，要写文档声明语句: &lt;!DOCTYPE HTML&gt;，当然也可以用小写表示。文档声明的作用是告诉浏览器该文档遵循html规范。</html></p><h3 id="2、标题"><a href="#2、标题" class="headerlink" title="2、标题"></a>2、标题</h3><p>一般情况下，我们都会设定html文档的标题。这样的作用是使用户看起来感觉友好。标签为<title></title>,标签内放标题名称。</p><h3 id="3、页面编码"><a href="#3、页面编码" class="headerlink" title="3、页面编码"></a>3、页面编码</h3><p>编码的种类有多种，但常用的是utf-8和gb2312。utf-8为多国语言编码，gb2312为中文简体编码。对于编码的详细问题，可以浏览博客。设置网页编码的语句为<meta charset="utf-8">，是在<head><meta name="generator" content="Hexo 3.8.0"></head>标签内定义的。</p><h3 id="4、页面关键字，内容"><a href="#4、页面关键字，内容" class="headerlink" title="4、页面关键字，内容"></a>4、页面关键字，内容</h3><p>我们可以在文档中设置一些关键词，内容介绍。这样的好处是，当我们的网页发布在网上，用户可以通过在搜索框中输入关键字，找出一些比较符合的网页。这样一来，我们的网页便可以更容易地被别人访问。</p><h2 id="五、常用元素"><a href="#五、常用元素" class="headerlink" title="五、常用元素"></a>五、常用元素</h2><h3 id="1、-换行符。"><a href="#1、-换行符。" class="headerlink" title="1、 换行符。"></a>1、 换行符。</h3><p>换行对于文本编辑来说是最正常不过的了。当文字写满一行，需要换行。或者根据需要，在文本中换行，这都是可以的。如下例子：</p><pre class=" language-bash"><code class="language-bash">  <span class="token operator">&lt;</span>body<span class="token operator">></span>     我要换行<span class="token operator">&lt;</span>br /<span class="token operator">></span>换行后 <span class="token operator">&lt;</span>/body<span class="token operator">></span></code></pre><h3 id="2、段落"><a href="#2、段落" class="headerlink" title="2、段落 "></a>2、段落 <p></p></h3><p>在写文章时，我们可以用p标签来定义一个段落。如下定义了两个段落：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>p<span class="token operator">></span>UTF-8。UTF-8就是在互联网上使用最广的一种unicode的实现方式。<span class="token operator">&lt;</span>/p<span class="token operator">></span><span class="token operator">&lt;</span>p<span class="token operator">></span>GBK编码，包括了GB2312中的编码，同时扩充了许多，通行于大陆。<span class="token operator">&lt;</span>/p<span class="token operator">></span></code></pre><p>在定义了段落后，可以利用属性align来对段落进行设置。属性align的值包括left（左对齐）、center（居中对齐）、right（右对齐）三种。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>p align<span class="token operator">=</span>“center”<span class="token operator">></span>UTF-8。UTF-8就是在互联网上使用最广的一种unicode的实现方式。         <span class="token operator">&lt;</span>/p<span class="token operator">></span></code></pre><img src="https://images2015.cnblogs.com/blog/808020/201608/808020-20160805113907997-148929216.png" class="[class names]"><h3 id="3、标题。标题有六种大小h后的数字越大，说明标题越大。分别为"><a href="#3、标题。标题有六种大小h后的数字越大，说明标题越大。分别为" class="headerlink" title="3、标题。标题有六种大小h后的数字越大，说明标题越大。分别为"></a>3、标题。标题有六种大小h后的数字越大，说明标题越大。分别为</h3><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>h1<span class="token operator">></span>标题1<span class="token operator">&lt;</span>/h1<span class="token operator">></span>             <span class="token operator">&lt;</span>h2<span class="token operator">></span>标题2<span class="token operator">&lt;</span>/h2<span class="token operator">></span><span class="token operator">&lt;</span>h3<span class="token operator">></span>标题3<span class="token operator">&lt;</span>/h3<span class="token operator">></span><span class="token operator">&lt;</span>h4<span class="token operator">></span>标题4<span class="token operator">&lt;</span>/h4<span class="token operator">></span><span class="token operator">&lt;</span>h5<span class="token operator">></span>标题5<span class="token operator">&lt;</span>/h5<span class="token operator">></span><span class="token operator">&lt;</span>h6<span class="token operator">></span>标题6<span class="token operator">&lt;</span>/h6<span class="token operator">></span></code></pre><h3 id="4、文本格式化，一些常用于设置文本字体的元素："><a href="#4、文本格式化，一些常用于设置文本字体的元素：" class="headerlink" title="4、文本格式化，一些常用于设置文本字体的元素："></a>4、文本格式化，一些常用于设置文本字体的元素：</h3><pre class=" language-bash"><code class="language-bash">         <span class="token operator">&lt;</span>b<span class="token operator">></span>定义粗体文本<span class="token operator">&lt;</span>/b<span class="token operator">></span><span class="token operator">&lt;</span>br /<span class="token operator">></span>         <span class="token operator">&lt;</span>i<span class="token operator">></span> 定义斜体文本 <span class="token operator">&lt;</span>/i<span class="token operator">></span><span class="token operator">&lt;</span>br /<span class="token operator">></span>         <span class="token operator">&lt;</span>del<span class="token operator">></span>定义删除文本<span class="token operator">&lt;</span>/del<span class="token operator">></span><span class="token operator">&lt;</span>br /<span class="token operator">></span>         <span class="token operator">&lt;</span>sup<span class="token operator">></span>定义上标字<span class="token operator">&lt;</span>/sup<span class="token operator">></span><span class="token operator">&lt;</span>br /<span class="token operator">></span>         <span class="token operator">&lt;</span>sub<span class="token operator">></span>定义下标字<span class="token operator">&lt;</span>/sub<span class="token operator">></span><span class="token operator">&lt;</span>br /<span class="token operator">></span></code></pre><h3 id="5、定义超链接"><a href="#5、定义超链接" class="headerlink" title="5、定义超链接"></a>5、定义超链接<a href="“URL”"></a></h3><p>a标签用来定义一条超链接，其中要有的是href属性，href的作用是指明超链接要链接到的网址。除了href属性，还有title属性表示链接的提示信息。target属性表示链接的打开方式，即当点击了链接，选择是在另一个页面打开还是本页面打开。其属性值包括_blank(新的空白页)self(当前页),top（当前页）。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span><span class="token operator">></span>百度一下<span class="token operator">&lt;</span>/a<span class="token operator">></span> </code></pre><p>href的值可以是外部链接，也可以是内部文件，如.html文件。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>a href<span class="token operator">=</span>“http://www.163.com”<span class="token operator">></span>外部链接<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span>“about.html”<span class="token operator">></span>内部链接 <span class="token operator">&lt;</span>/a<span class="token operator">></span>href也可以链接到别的地址，如邮箱、电话、sms。<span class="token operator">&lt;</span>a href<span class="token operator">=</span>“1233456.qqcom”<span class="token operator">></span>邮件链接<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span>“tel:电话号码”<span class="token operator">></span>拨打电话<span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"sms:139xxxxxxx"</span><span class="token operator">></span>发送短信<span class="token operator">&lt;</span>/a<span class="token operator">></span></code></pre><img src="https://images2015.cnblogs.com/blog/808020/201608/808020-20160805114041231-316044158.png" class="[class names]"><h3 id="6-锚点"><a href="#6-锚点" class="headerlink" title="6.锚点"></a>6.锚点</h3><p>有时我们在浏览网页时会发现，有些网页比较人性化，会有点击返回顶部的按键。这样的效果其实用锚点标签就能做到。锚点就是点击使用户跳到文档的某个部分。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#位置名"</span><span class="token operator">></span> <span class="token operator">&lt;</span>/a<span class="token operator">></span><span class="token operator">&lt;</span>a name<span class="token operator">=</span><span class="token string">"位置名"</span><span class="token operator">></span> <span class="token operator">&lt;</span>/a<span class="token operator">></span> 如代码例子：<span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"#map"</span><span class="token operator">></span>跳转<span class="token operator">&lt;</span>/a<span class="token operator">></span> <span class="token operator">&lt;</span>p id<span class="token operator">=</span><span class="token string">"map"</span><span class="token operator">></span>代码代码<span class="token operator">&lt;</span>/p<span class="token operator">></span></code></pre><h3 id="7、图像img"><a href="#7、图像img" class="headerlink" title="7、图像img"></a>7、图像img</h3><p>如下：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"img/fenfjing.jpg"</span> width<span class="token operator">=</span><span class="token string">"100"</span> height<span class="token operator">=</span><span class="token string">"100"</span> alt<span class="token operator">=</span><span class="token string">"风景"</span> /<span class="token operator">></span></code></pre><h3 id="8、列表"><a href="#8、列表" class="headerlink" title="8、列表"></a>8、列表</h3><p>（1）、无序列表。</p><p>Html中列表也是常用的元素。无序列表用(ul)(li)(/li)(/ul)表示。</p><p>说明：</p><p>属性：    type</p><p>属性值：   列表前的符号</p><p> disc     实心原点   </p><p> circle　  符号为空心圆</p><p> square　　符号为方形</p><p>例子如下：</p><pre class=" language-bash"><code class="language-bash"> <span class="token operator">&lt;</span>ul type<span class="token operator">=</span><span class="token string">"disc"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span> <span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><pre class=" language-bash"><code class="language-bash"> <span class="token operator">&lt;</span>ul type<span class="token operator">=</span><span class="token string">"circle"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><img src="https://images2015.cnblogs.com/blog/808020/201608/808020-20160805114211575-170728485.png" class="[class names]"> <pre class=" language-bash"><code class="language-bash"> <span class="token operator">&lt;</span>ul type<span class="token operator">=</span><span class="token string">"square"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>    <span class="token operator">&lt;</span>/ul<span class="token operator">></span></code></pre><p>（2）、有序列表</p><p>有序列表使用数字或字母系统来组织列表里包含的信息。有序列表可以使用数字(默认)、大写字母、小写字母、大写罗马数字和小写罗马数字排列项目。</p><p>说明：</p><p>属性               属性值                             说明</p><p>type     1、 a 、 A、i、I       用来设置项目前面的标记</p><p>start         数值                         排序的起点数值</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>ol type<span class="token operator">=</span><span class="token string">"1"</span> start<span class="token operator">=</span><span class="token string">"2"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>/ol<span class="token operator">></span>         <span class="token operator">&lt;</span>ol type<span class="token operator">=</span><span class="token string">"a"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>/ol<span class="token operator">></span>         <span class="token operator">&lt;</span>ol type<span class="token operator">=</span><span class="token string">"A"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>/ol<span class="token operator">></span>         <span class="token operator">&lt;</span>ol type<span class="token operator">=</span><span class="token string">"i"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>/ol<span class="token operator">></span>         <span class="token operator">&lt;</span>ol type<span class="token operator">=</span><span class="token string">"I"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>苹果<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>香蕉<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>li<span class="token operator">></span>雪梨<span class="token operator">&lt;</span>/li<span class="token operator">></span>         <span class="token operator">&lt;</span>/ol<span class="token operator">></span></code></pre><p>（3）、定义列表</p><p>定义列表用来组织术语和它们的定义。任何信息如果包含多个术语和相对应的解释，都可以使用定义列表进行组织。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>dl<span class="token operator">></span><span class="token operator">&lt;</span>dt<span class="token operator">></span>爱好<span class="token operator">&lt;</span>/dt<span class="token operator">></span><span class="token operator">&lt;</span>dd<span class="token operator">></span>听歌<span class="token operator">&lt;</span>/dd<span class="token operator">></span><span class="token operator">&lt;</span>dt<span class="token operator">></span>爱好<span class="token operator">&lt;</span>/dt<span class="token operator">></span><span class="token operator">&lt;</span>dd<span class="token operator">></span>跑步 <span class="token operator">&lt;</span>/dd<span class="token operator">></span><span class="token operator">&lt;</span>dd<span class="token operator">></span>唱歌 <span class="token operator">&lt;</span>/dd<span class="token operator">></span><span class="token operator">&lt;</span>/dl<span class="token operator">></span></code></pre><img src="https://images2015.cnblogs.com/blog/808020/201608/808020-20160805114413747-31081520.png" class="[class names]"> <h3 id="9、-HTML-实体字符。"><a href="#9、-HTML-实体字符。" class="headerlink" title="9、 HTML 实体字符。"></a>9、 HTML 实体字符。</h3><p>在html中，有些特殊字符是需要用html语言表示出来的。一个字符实体包含三个部分：一个&amp;符，一个实体名或者一个实体号，最后一个分号（；）。如下所示：</p><ul><li>实体名是大小写敏感的。</li></ul><p>实体字符         字符实体</p><p>大于号 (&gt;)        &lsaquo; &amp;gt&rsaquo; ;</p><p>小于号 (&lt;)      &lsaquo;&amp;lt&rsaquo; ;</p><p>引号 (“)          &lsaquo;&amp;quot&rsaquo; ;</p><p>注册商标(®)       &lsaquo;&amp;reg&rsaquo; ;</p><p>版权(© )          &lsaquo;&amp;copy&rsaquo; ;</p><p>&lsaquo;&amp;copy&rsaquo;    ;     &lsaquo;&amp;amp&rsaquo;   ;</p><h3 id="10、-图像热区"><a href="#10、-图像热区" class="headerlink" title="10、 图像热区"></a>10、 图像热区</h3><p>平时我们在浏览网页时，当鼠标经过一张图片中的某个位置时，发现是可点击的。也就是说，我们点击这个部分，就会链接到别的地方。创建图像热区想要用<img>b标签把图片插入进来，然后使用<area>标签在刚才插入的图片里划分热区。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"URL"</span>  usemap<span class="token operator">=</span><span class="token string">"# map 名称"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>map name<span class="token operator">=</span><span class="token string">"map 名称"</span><span class="token operator">></span>         <span class="token operator">&lt;</span>area shape<span class="token operator">=</span><span class="token string">"形状"</span> coords<span class="token operator">=</span><span class="token string">"坐标值"</span> href<span class="token operator">=</span><span class="token string">"URL"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>/map<span class="token operator">></span></code></pre><p>Rect:矩形   左上角坐标与右下角坐标（x，y，x，y）</p><p>Circle:圆形  圆心坐标，半径  （x，y ，r）</p><p>Poly:多边形  各顶点的坐标   （x，y，x，y，x，y。。。）</p><p>说明：</p><p>URL :                图像的地址</p><p>usermap   :       表示要使用#后面的那个名字的&lsaquo;map&rsaquo; 标签来为图片划分热区</p><p>shape  :             热区形状(rect矩形、circle圆形、poly多边形 )</p><p>coords  :            形状的坐标值</p><p>注：usemap的值要与map的name值保持一致。坐标可以通过PS软件–菜单栏导航器—-信息—坐标值。</p><p>例子如下：热区范围为一个矩形</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>img src<span class="token operator">=</span><span class="token string">"img/map.jpg"</span> usemap<span class="token operator">=</span><span class="token string">"#p1"</span>/<span class="token operator">></span> <span class="token operator">&lt;</span>map name<span class="token operator">=</span><span class="token string">"p1"</span> id<span class="token operator">=</span><span class="token string">"p1"</span><span class="token operator">></span>　　<span class="token operator">&lt;</span>area  shape<span class="token operator">=</span><span class="token string">"rect"</span> coords<span class="token operator">=</span><span class="token string">"500,120,550,150"</span> href<span class="token operator">=</span><span class="token string">"img/1.jpg"</span> target<span class="token operator">=</span><span class="token string">"_blank"</span>/<span class="token operator">></span><span class="token operator">&lt;</span>/map<span class="token operator">></span></code></pre><p>在这里我设置了新疆为图像热区，热区范围为一个矩形。点击地图中的新疆，就会跳转到一张图片中。要注意的是要准确的写出热区的坐标，也就是热区的范围。其坐标值可以利用工具ps工具选取。</p><h3 id="11、-表格"><a href="#11、-表格" class="headerlink" title="11、 表格"></a>11、 表格</h3><p>表格由 &lsaquo;table&rsaquo;  标签以及一个或多个 tr、th或td 元素组成。</p><p>单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。</p><p>基本结构：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>table border<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">></span><span class="token operator">&lt;</span>tr<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span>row 1, cell 1<span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span>row 1, cell 2<span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>/tr<span class="token operator">></span><span class="token operator">&lt;</span>tr<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span>row 2, cell 1<span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>td<span class="token operator">></span>row 2, cell 2<span class="token operator">&lt;</span>/td<span class="token operator">></span><span class="token operator">&lt;</span>/tr<span class="token operator">></span><span class="token operator">&lt;</span>/table<span class="token operator">></span></code></pre><p>row 1, cell 1    row 1, cell 2<br>row 2, cell 1    row 2, cell 2<br>说明：</p><p>html有10个表格相关的标签。</p><p>&lsaquo;caption&rsaquo;         定义表格标题</p><p>&lsaquo;col&rsaquo; 　　　　　 定义列</p><p>&lsaquo;colgroup&rsaquo; 　　 定义表格列的分组</p><p>&lsaquo;table&rsaquo; 　　　   定义表格</p><p>&lsaquo;tbody&rsaquo; 　　  　定义表格主体</p><p>&lsaquo;td&rsaquo; 　　　　　 定义一个单元格</p><p>&lsaquo;tfoot&rsaquo; 　　　　定义表格的表注（底部）</p><p>&lsaquo;th&rsaquo; 　　　　 　定义表格表头</p><p>&lsaquo;thead&rsaquo; 　　 　定义表格的表头</p><p>&lsaquo;tr&rsaquo; 　　　　　 定义行</p><ul><li>通常很少使用&lsaquo;tbody&rsaquo; 、&lsaquo;thead&rsaquo; 、&lsaquo;tfoot&rsaquo; 标签，因为浏览器对它们的支持不好。</li></ul><p>属性说明：</p><p>属性                   值                                  说明</p><p>width                px、 %                           指定表格的宽度    </p><p>height               px、%                              表格的高度</p><p>border               px                                指定表格边框的宽度</p><p>cellpadding          px                            指定边框与内容之间的空白                           </p><p>cellspacing          px、 %                          指定单元格之间的空白                  </p><p>align            left、 right 、 center                指定表格的对齐方式                  </p><p>valign          top、 middle 、 bottom                 垂直排列方式</p><p>colspan                列数                            合并列单元格</p><p>rowspan               行数                             合并行单元格</p><p>bgcolor               颜色值                            表格背景色</p><p>background             图片                                表格背景图</p><p>bordercolor  　      　颜色值　                        表格边框颜色　　　　　</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>table align<span class="token operator">=</span><span class="token string">"center"</span> cellpadding<span class="token operator">=</span><span class="token string">"2"</span> cellspacing<span class="token operator">=</span><span class="token string">"3"</span> width<span class="token operator">=</span><span class="token string">"300"</span> height<span class="token operator">=</span><span class="token string">"300"</span> border<span class="token operator">=</span><span class="token string">"1"</span> <span class="token operator">></span>       <span class="token operator">&lt;</span>tr <span class="token operator">></span>            <span class="token operator">&lt;</span>td colspan<span class="token operator">=</span><span class="token string">"2"</span><span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&lt;</span>/td<span class="token operator">></span>                                 <span class="token operator">&lt;</span>/tr<span class="token operator">></span>       <span class="token operator">&lt;</span>tr<span class="token operator">></span>            <span class="token operator">&lt;</span>td <span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&lt;</span>/td<span class="token operator">></span>            <span class="token operator">&lt;</span>td<span class="token operator">></span><span class="token operator">&amp;</span>nbsp<span class="token punctuation">;</span><span class="token operator">&lt;</span>/td<span class="token operator">></span>       <span class="token operator">&lt;</span>/tr<span class="token operator">></span>        <span class="token operator">&lt;</span>/table<span class="token operator">></span></code></pre><h3 id="12、-lsaquo-iframe-rsaquo-内嵌框架"><a href="#12、-lsaquo-iframe-rsaquo-内嵌框架" class="headerlink" title="12、 &lsaquo;iframe&rsaquo; 内嵌框架"></a>12、 &lsaquo;iframe&rsaquo; 内嵌框架</h3><p>属性                            属性值              说明</p><p>width                           px , %                 指定框架的宽度</p><p>height                         px , %                  指定框架的高度</p><p>scrolling                     yes,no,auto           是否显示滚动条</p><p>frameborder                  1, 0                   是否显示边框</p><p>语法：<br>&lsaquo;iframe src=”URL” name=”框架名”&rsaquo;  &lsaquo;/iframe&rsaquo;<br>如下： </p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token string">"http://www.baidu.com"</span> name<span class="token operator">=</span><span class="token string">"baidu"</span> height<span class="token operator">=</span><span class="token string">"600"</span>width<span class="token operator">=</span><span class="token string">"600"</span><span class="token operator">></span><span class="token operator">&lt;</span>/iframe<span class="token operator">></span></code></pre><p>scrolling属性在没写明的情况下，是根据设定的框架高度来确定是否需要滚动条的。</p><h3 id="13、-form-表单"><a href="#13、-form-表单" class="headerlink" title="13、 form 表单"></a>13、 form 表单</h3><p>html中表单的作用是很强大的。我们生活中经常要用到表单，如一些基本信息的填写。在网页中也是如此，我们免不了注册一些账号，此时用到的表单就比较多了。</p><p>表单主要负责获取用户填写的数据，并通过浏览器向服务器传送数据。</p><p>表单使用标签&lsaquo;form&rsaquo; 定义。</p><p>表单的基本结构：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form name<span class="token operator">=</span><span class="token string">"form1"</span> action<span class="token operator">=</span><span class="token string">"URL"</span> method<span class="token operator">=</span><span class="token string">"get|post"</span> target<span class="token operator">=</span><span class="token string">"文档显示方式"</span><span class="token operator">></span>   用户名：<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"uname"</span> /<span class="token operator">></span>   密 码：<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"passwd"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p>说明：</p><p>属性                     说明</p><p>name                   表单的名称</p><p>action                   表单提交地址</p><p>method                表单数据提交的方式 （get:在url地址上面传送参数到服务器,post：在后台传送参数到服务器）</p><p>enctype                MIME类型              </p><p>target                   打开方式&lsaquo;blank:在一个新的窗口打开 self:在相同的框架中调入文档 top:把文档调入原来的最顶部的浏览器窗口中&rsaquo;<br>文本域：文本域通过&lsaquo;input type=”text”&rsaquo; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form<span class="token operator">></span>   First name: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"firstname"</span><span class="token operator">></span><span class="token operator">&lt;</span>br<span class="token operator">></span>   Last name: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> name<span class="token operator">=</span><span class="token string">"lastname"</span><span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p> 注意:表单本身并不可见。同时，在大多数浏览器中，文本域的缺省宽度是20个字符。</p><p> 浏览器显示如下：</p><p>First name: </p><p>Last name: </p><p>注意:表单本身并不可见。同时，在大多数浏览器中，文本域的缺省宽度是20个字符。</p><p>说明：</p><p>属性                  说明</p><p>type                input元素类型                          </p><p>name              input 元素的名称</p><p>value              input 元素的值</p><p>size                input 元素的宽度</p><p>readonly              是否只读</p><p>maxlength       输入字符的最大长度</p><p>disabled               是否禁用</p><p>密码字段</p><p>密码字段通过标签&lsaquo;input type=”password”&rsaquo; 来定义:</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form<span class="token operator">></span>Password: <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"password"</span> name<span class="token operator">=</span><span class="token string">"pwd"</span><span class="token operator">></span><span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p>浏览器显示效果如下：</p><p>Password: </p><p>属性                  说明</p><p>type                input元素类型                          </p><p>name              input 元素的名称</p><p>size                input 元素的宽度</p><p>maxlength      定义最多输入的字符数</p><p>注意:密码字段字符不会明文显示，而是以星号或圆点替代。</p><p>单选按钮</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"radio"</span><span class="token operator">></span> 标签定义了表单单选框选项<span class="token operator">&lt;</span>form<span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"radio"</span> name<span class="token operator">=</span><span class="token string">"sex"</span> value<span class="token operator">=</span><span class="token string">"male"</span><span class="token operator">></span>Male<span class="token operator">&lt;</span>br<span class="token operator">></span><span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"radio"</span> name<span class="token operator">=</span><span class="token string">"sex"</span> value<span class="token operator">=</span><span class="token string">"female"</span><span class="token operator">></span>Female<span class="token operator">&lt;</span>/form<span class="token operator">></span></code></pre><p>name属性：定义单选框的名称，要保证数据的准确获取，单选框都是以组为单位使用的，在同一组的单选按项要用同一个名称。</p><p>复选框</p><pre><code>&lt;input type=&quot;checkbox&quot;&gt; 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;song&quot; value=&quot;听歌&quot;&gt;听歌&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;run&quot; value=&quot;跑步&quot;&gt; 跑步&lt;/form&gt;</code></pre><pre><code>&lt;input type=&quot;submit&quot;&gt; 定义了提交按钮.</code></pre><p>隐藏域</p><p>隐藏域用于在程序发送没有必要让用户看到特定值的时候使用。</p><pre><code>   &lt;input type=&quot;hidden&quot; name=&quot;uid&quot; value=&quot;10&quot;/&gt;</code></pre><p>上传文件   </p><pre><code>&lt;input type=“file” name=“photo” /&gt;</code></pre><p>注意：</p><p>利用这项功能时，在 form 标签中要指定method属性。要把method 指定为post, enctype属性指定为 multipart/form-data。</p><p>说明：</p><p> multiple     控制是否上传多文件</p><pre><code>&lt;input type=&quot;file&quot; name=&quot;photo&quot; multiple /&gt;&lt;input type=&quot;button&quot; value=&quot;请选择文件...&quot;/&gt;</code></pre><p>说明：</p><p>属性                   　　说明</p><p>name                　  元素的名称</p><p>rows                  　 指定文本框的高度</p><p>cols         　　　 　  指定文本框的宽度</p><p>例：</p><pre><code>&lt;textarea name=&quot;content&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt; &lt;/textarea&gt;</code></pre><p>注：此处的文本框宽高是由字符个数组成的。</p><p>简单下拉框：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>form action<span class="token operator">=</span><span class="token string">""</span><span class="token operator">></span><span class="token operator">&lt;</span>select name<span class="token operator">=</span><span class="token string">"cars"</span><span class="token operator">></span><span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"volvo"</span><span class="token operator">></span>Volvo<span class="token operator">&lt;</span>/option<span class="token operator">></span><span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"saab"</span><span class="token operator">></span>Saab<span class="token operator">&lt;</span>/option<span class="token operator">></span><span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"fiat"</span><span class="token operator">></span>Fiat<span class="token operator">&lt;</span>/option<span class="token operator">></span><span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"audi"</span><span class="token operator">></span>Audi<span class="token operator">&lt;</span>/option<span class="token operator">></span><span class="token operator">&lt;</span>/select<span class="token operator">></span></code></pre><p>属性                            说明</p><p>name                           下拉列表框的名称        </p><p>size                           下拉列表框的显示行数</p><p>multiple                      是否多选</p><p>disabled                      是否禁用</p><p>selected                     设置默认选中的选项</p><p>value                           选项值</p><p> label</p><p>lable 标签的作用是将输入项或选项及其标签文字关联起来。</p><p>例：</p><pre class=" language-bash"><code class="language-bash"> <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"radio"</span> name<span class="token operator">=</span><span class="token string">"sex"</span> value<span class="token operator">=</span><span class="token string">"1"</span> id<span class="token operator">=</span><span class="token string">"male"</span> /<span class="token operator">></span>         <span class="token operator">&lt;</span>label for<span class="token operator">=</span><span class="token string">"male"</span><span class="token operator">></span>男<span class="token operator">&lt;</span>/label<span class="token operator">></span>         <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"radio"</span> name<span class="token operator">=</span><span class="token string">"sex"</span> value<span class="token operator">=</span><span class="token string">"0"</span> id<span class="token operator">=</span><span class="token string">"female"</span> /<span class="token operator">></span>         <span class="token operator">&lt;</span>label for<span class="token operator">=</span><span class="token string">"female"</span><span class="token operator">></span>女<span class="token operator">&lt;</span>/label<span class="token operator">></span></code></pre><p>optgroup(表单元素：下拉框分组)</p><pre class=" language-bash"><code class="language-bash">optgroup 元素用于组合选项<span class="token operator">&lt;</span>select name<span class="token operator">=</span><span class="token string">"city"</span> multiple<span class="token operator">></span>         <span class="token operator">&lt;</span>optgroup label<span class="token operator">=</span><span class="token string">"广东"</span><span class="token operator">></span>             <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"1"</span><span class="token operator">></span>广州<span class="token operator">&lt;</span>/option<span class="token operator">></span>              <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"2"</span><span class="token operator">></span>深圳<span class="token operator">&lt;</span>/option<span class="token operator">></span>        <span class="token operator">&lt;</span>/optgroup<span class="token operator">></span>       <span class="token operator">&lt;</span>optgroup label<span class="token operator">=</span><span class="token string">"其他"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"3"</span><span class="token operator">></span>长沙<span class="token operator">&lt;</span>/option<span class="token operator">></span>            <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"4"</span><span class="token operator">></span>香港<span class="token operator">&lt;</span>/option<span class="token operator">></span>            <span class="token operator">&lt;</span>/optgroup<span class="token operator">></span> <span class="token operator">&lt;</span>/select<span class="token operator">></span></code></pre><p>&lsaquo;datalist&rsaquo;</p><p> 标签定义选项列表。与 input 元素配合使用该元素，来定义 input 可能的值。datalist 及其选项不会被显示出来，它仅仅是合法的输入值列表。使用 input 元素的 list 属性来绑定 datalist。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>input list<span class="token operator">=</span><span class="token string">"cars"</span> /<span class="token operator">></span><span class="token operator">&lt;</span>datalist id<span class="token operator">=</span><span class="token string">"cars"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"BMW"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"Ford"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>option value<span class="token operator">=</span><span class="token string">"Volvo"</span><span class="token operator">></span><span class="token operator">&lt;</span>/datalist<span class="token operator">></span></code></pre><p> HTML5新标签</p><p>标签                   描述</p><p>&lsaquo;form&rsaquo;              定义供用户输入的表单</p><p>&lsaquo;input&rsaquo;              定义输入域</p><p>&lsaquo;textarea&rsaquo;          定义文本域 (一个多行的输入控件)</p><p>&lsaquo;label&rsaquo;            定义了&lsaquo;input&rsaquo;  元素的标签，一般为输入标题</p><p>&lsaquo;fieldset&rsaquo;          定义了一组相关的表单元素，并使用外框包含起来</p><p>&lsaquo;legend&rsaquo;           定义了 &lsaquo;fieldset&rsaquo;  元素的标题</p><p>&lsaquo;select&rsaquo;            定义了下拉选项列表</p><p>&lsaquo;optgroup&rsaquo;         定义选项组</p><p>&lsaquo;option&rsaquo;            定义下拉列表中的选项</p><p>&lsaquo;button&rsaquo;            定义一个点击按钮</p><p>&lsaquo;datalist&rsaquo; New      指定一个预先定义的输入控件选项列表</p><p>&lsaquo;keygen&rsaquo; New        定义了表单的密钥对生成器字段</p><p>&lsaquo;output&rsaquo; New        定义一个计算结果</p><p>HTML5的表单所有type类型</p><p>button              定义可点击的按钮（大多与 JavaScript 使用来启动脚本）</p><p>checkbox            定义复选框。</p><p>color               定义拾色器。</p><p>date                定义日期字段（带有 calendar 控件）</p><p>datetime            定义日期字段（带有 calendar 和 time 控件）</p><p>datetime-local      定义日期字段（带有 calendar 和 time 控件）</p><p>month               定义日期字段的月（带有 calendar 控件）</p><p>week                定义日期字段的周（带有 calendar 控件）</p><p>time                定义日期字段的时、分、秒（带有 time 控件）</p><p>email               定义用于 e-mail 地址的文本字段</p><p>file                定义输入字段和 “浏览…” 按钮，供文件上传</p><p>hidden              定义隐藏输入字段</p><p>image               定义图像作为提交按钮</p><p>number              定义带有 spinner 控件的数字字段</p><p>password            定义密码字段。字段中的字符会被遮蔽。</p><p>radio               定义单选按钮。</p><p>range               定义带有 slider 控件的数字字段。</p><p>reset               定义重置按钮。重置按钮会将所有表单字段重置为初始值。</p><p>search              定义用于搜索的文本字段。</p><p>submit              定义提交按钮。提交按钮向服务器发送数据。</p><p>tel                 定义用于电话号码的文本字段。</p><p>text                默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</p><p>url                 定义用于 URL 的文本字段。</p><h3 id="14、音频"><a href="#14、音频" class="headerlink" title="14、音频"></a>14、音频</h3><p>基本格式：&lsaquo;audio src=”” controls&rsaquo;&lsaquo; audio&rsaquo; </p><p>不同浏览器会对音频的兼容性不同，所以最好是在属性type中指明其类型</p><p>属性说明：</p><p>autoplay        如果出现该属性，则视频在就绪后马上播放。</p><p>controls        如果出现该属性，则向用户显示控件，比如播放按钮。</p><p>loop            如果出现该属性，则当媒介文件完成播放后再次开始播放。</p><p>muted           规定视频的音频输出应该被静音。</p><p>poster          URL 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。</p><p>preload         如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果 使用 “autoplay”，则忽略该属性。</p><p>src url         要播放的视频的 URL。</p><p>width           设置视频播放器的宽度。</p><p>height          设置视频播放器的高度。</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>audio src<span class="token operator">=</span><span class="token string">"4.ogv"</span> width<span class="token operator">=</span><span class="token string">"300"</span> height<span class="token operator">=</span><span class="token string">"40"</span> controls<span class="token operator">></span><span class="token operator">&lt;</span>audio<span class="token operator">></span></code></pre><h3 id="15、视频"><a href="#15、视频" class="headerlink" title="15、视频　"></a>15、视频　</h3><p>基本格式：&lsaquo;video src=”4.ogv” controls &rsaquo;<br>&lsaquo; /viedo&rsaquo; 　</p><p>其属性与音频类同。</p><p>作者：ly婠婠<br><a href="http://www.cnblogs.com/46ly/" target="_blank" rel="noopener">出处</a></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript基础知识总结</title>
      <link href="/2018/11/22/javascript-ji-chu-zhi-shi-zong-jie/"/>
      <url>/2018/11/22/javascript-ji-chu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript基本知识"><a href="#JavaScript基本知识" class="headerlink" title="JavaScript基本知识"></a>JavaScript基本知识</h2><p>JavaScript是一门独立的语言，像我们学习php,python等需要安装apache,python3.6，那我们学习JavaScript只需要我们电脑有一个浏览器即可，浏览器具有js解释器</p><h2 id="一、如何编写"><a href="#一、如何编写" class="headerlink" title="一、如何编写"></a>一、如何编写</h2><p>首先我们看看JavaScript代码存在的形式：</p><p>head中：</p><pre><code>第一种&lt;script&gt;        //javascript代码        alert(123);&lt;/script&gt;第二种&lt;script type=&quot;text/javascript&quot;&gt;        //javascript代码        alert(123);&lt;/script&gt;第三种，js代码保存在文件中&lt;script src=&quot;js文件路径&quot;&gt;&lt;/script&gt;</code></pre><p> 对于js代码，如果我们把它放在head里面，那么浏览器在解析的时候就会先执行js代码，然后才会显示html中的代码，这样，如果你引入的js代码的地址有问题，那么浏览器就会相应很长时间，然后才会显示body里面的内容，这样就给用户造成了很大的影响，所以我们一般把js代码的引入放在body的最下面</p><p> 最后才去加载js。</p><p>js的注释：</p><pre><code>单行注释：//多行注释：/*  代码  */</code></pre><h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><p>JavaScript中变量，局部变量必须一个 var 开头，如果未使用var，则默认表示声明的是全局变量。</p><pre><code>&lt;script&gt;        //全局变量        name=&#39;alex&#39;        function func(){            //局部变量            var name=&#39;eric&#39;        }&lt;/script&gt;</code></pre><h2 id="三、基本的数据类型"><a href="#三、基本的数据类型" class="headerlink" title="三、基本的数据类型"></a>三、基本的数据类型</h2><p>JavaScript 中的数据类型分为原始类型和对象类型：<br>​    <ul>原始类型<br>​        <li>数字</li><br>​        <li>字符串</li><br>​        <li>布尔值</li><br>​    </ul><br>​    <ul>对象类型<br>​        <li>数组</li><br>​        <li>“字典”</li><br>​        <li>…</li><br>​    </ul></p><h3 id="1-数字（Number）"><a href="#1-数字（Number）" class="headerlink" title="1.数字（Number）"></a>1.数字（Number）</h3><p>在js中不区分整数值和浮点数值，所有数字均用浮点数值表示</p><p>转换：</p><ul><br><li>parseInt(..)    将某值转换成数字，不成功则返回NaN</li><br><li>parseFloat(..) 将某值转换成浮点数，不成功则返回NaN</li><br></ul><br>特殊值：<br><ul><br><li>NaN，非数字。可使用 isNaN(num) 来判断。</li><br><li>Infinity，无穷大。可使用 isFinite(num) 来判断。</li><br></ul><h3 id="2-字符串（String）"><a href="#2-字符串（String）" class="headerlink" title="2.字符串（String）"></a>2.字符串（String）</h3><p>字符串是由字符组成的数组，但在JavaScript中字符串是不可变的：可以访问字符串任意位置的文本</p><pre><code>a=&quot;xiaoming&quot;a.charAt(索引位置)                       // 获得某个位置的字符a.substring(起始位置，结束位置)            //截取a中的某段字符，不包含结束位置的字符a.length                                //获取当前字符串的长度</code></pre><p>首先先介绍：</p><p><b>console.log(1);</b><br>这个是在F12调试的console页面打印东西，我们可以在自己的网页的console放一些东西，比如百度，放的是招聘信息。</p><p>下面我们用我们上面的知识写一个 跑马灯 ：</p><p>先介绍一些知识：</p><ul><li>定时器：setInterval(‘要执行的代码’,间隔时间)</li></ul><pre><code>&lt;script&gt;        function f1(){            console.log(1);        }        //创建一个定时器        //setInterval(&quot;alert(123);&quot;,2000);        setInterval(&quot;f1();&quot;,2000);&lt;/script&gt;</code></pre><ul><br><li>这样就每隔2秒钟就在console上打印1</li><br><li>根据id选择器名称获得标签内容：tag=document.getElementById(“i1”);</li><br><li>获取标签内部内容：tag.innerText</li><br></ul><br>有了上面的知识，我们就可以做出一个 跑马灯了<br><br><br><code>bash&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;i1&quot;&gt;JavaScript学习实例&lt;/div&gt;    &lt;script&gt;        function func() {            //根据id获得指定的标签内容            var tag = document.getElementById(&quot;i1&quot;);            //获取标签内部的内容            var content = tag.innerText;            var f = content.charAt(0);            var l = content.substring(1,content.length);            var new_string = l+f;            tag.innerText = new_string;        }        setInterval(&quot;func()&quot;,1000);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code><br><br><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314154118446-1041447125.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314154118446-1041447125.png</a><br><br>字符串的其他函数：<br><br><code>basha = &#39;xiaoming&#39;;a.trim()                           　　//移除空白,比如a = &#39;  xiaoming    &#39;，返回的值就是xiaoming,没有了两边的空格a.trimLeft()a.trimRight)a.concat(value, ...)               　　//拼接,比如：a.concat(&#39;xixi&#39;);  返回的a的值就为xiaomingxixi  a.indexOf(substring,start)        　　 //子序列位置，比如a.indexOf(&#39;ao&#39;); 返回的就是 2a.lastIndexOf(substring,start)    　　 //子序列位置，倒着找a.slice(start, end)              　　  //切片a.toLowerCase()                 　　   //大写a.toUpperCase()                　　    //小写a.split(delimiter, limit)       　　   //分割 比如：a=&quot;xixixixi&quot;; a.split(&#39;i&#39;);返回的就是[&quot;x&quot;,&quot;x&quot;,&quot;x&quot;,&quot;&quot;]    a.split(&#39;i&#39;,2);返回的就是[&quot;x&quot;,&quot;x&quot;]a.search(regexp)                　　　 // 从头开始匹配，返回匹配成功的第一个位置(g无效)obj.match(regexp)                 　　 //全局搜索，如果正则中有g表示找到全部，否则只找到第一个。obj.replace(regexp, replacement)     　//替换，正则中有g则替换所有，否则只替换第一个匹配项，                                     $数字：匹配的第n个组内容；                                     $&amp;amp;：当前匹配的内容；                                     $`：位于匹配子串左侧的文本；                                     $&#39;：位于匹配子串右侧的文本                                     $$：直接量$符号</code><br><br>### 3.布尔类型（Boolean)<br><br><p>布尔类型仅包含真假，与Python不同的是其首字母小写,在python中表示真假用True和False，在JavaScript中表示真假用true和false。</p><br><br>### 4.数组<br><br><p>在python中[11,22,33]，这种叫做列表，但是在js中叫做数组。</p><br><br>常用函数：<br><br><code>basha = [11,22,33,44]a.length          //数组的大小a.push(ele)       //尾部追加元素 和python中的append一样a.pop()           //尾部获取一个元素a.unshift(ele)    //头部插入元素a.shift()         //头部移除元素a.splice(start, deleteCount, value, ...)  //插入、删除或替换数组的元素，起始位置，删除个数，要插入的值　　比如：a = [11,22,33,44];　　　　　a.splice(1,1,99);  那此时的a中就有[11,99,33,44]　　　　　a.splice(1,0,909); 那此时的a中就有[11,909,99,33,44]　　　　　a.splice(1,1);     那此时的a中就有[11,99,33,44]               a.slice( )        //切片,和字符串的substring差不多a.reverse( )      //反转a.join(sep)       //将数组元素连接起来以构建一个字符串a.concat(val,..)  //连接数组a.sort( )         //对数组元素进行排序</code><br><br><br>### 5.字典<br><br><br><p>js中的字典和python的差不多</p><br><br><code>a={&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;}取值的话：a[&#39;k1&#39;]=&#39;v1&#39;</code><br><br><br>### 6.序列化<br><br><p>在python中有json模块，把字典列表转换成字符串，再转换回来就用load()等。</p><br><br>在js中也有，比如我们在访问一个页面的时候，会返回数据 。返回的数据默认都是一个字符串，这个时候我们就需要对其进行处理<br><ul><br><li>JSON.stringify(obj)    序列化:把一个数组转换成字符串</li><br><li>JSON.parse(str)        反序列化：把字符串转换成数组</li><br></ul><pre><code>li = [11,22,33,77,5]s=JSON.stringify(li)        //s的结果为&quot;[11,22,33,77,5]&quot;new_li = JSON.parse(s)  //new_li的值为[11, 22, 33, 77, 5]</code></pre><h3 id="7-转义"><a href="#7-转义" class="headerlink" title="7.转义"></a>7.转义</h3><p>场景：我在地址框中输入这个中文搜索，然后我把这个地址复制下来的时候就变成这样子：<a href="https://www.baidu.com/s?wd=%E5%B0%8F%E6%98%8E，会把我们的中文转义为其他的" target="_blank" rel="noopener">https://www.baidu.com/s?wd=%E5%B0%8F%E6%98%8E，会把我们的中文转义为其他的</a></p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316011243975-82675763.png" class="[class names]"><ul><br><li>decodeURI( )                   URl中未转义的字符</li><br><li>decodeURIComponent( )   URI组件中的未转义字符</li><br><li>encodeURI( )                   URI中的转义字符</li><br><li>encodeURIComponent( )   转义URI组件中的字符</li><br><li>escape( )                         对字符串转义</li><br><li>unescape( )                     给转义字符串解码</li><br><li>URIError                         由URl的编码和解码方法抛出</li><br></ul><pre><code>url = &quot;https://www.baidu.com/s?wd=小明&quot;newurl=encodeURI(url)    &quot;https://www.baidu.com/s?wd=%E5%B0%8F%E6%98%8E&quot;decodeURI(newurl)    &quot;https://www.baidu.com/s?wd=小明&quot;newUrl = encodeURIComponent(url)　　&quot;https%3A%2F%2Fwww.baidu.com%2Fs%3Fwd%3D%E5%B0%8F%E6%98%8E&quot;    </code></pre><h3 id="8-eval"><a href="#8-eval" class="headerlink" title="8.eval"></a>8.eval</h3><p> 在python中有eval()函数和exec()函数</p><p>eval()只能执行表达式，并且可以得到返回值：var = eval(“1+1”),即使表达式是一个字符串，我们也能够得到运算结果。</p><p>exec()可以直接执行代码，但是没有返回值</p><p>在JavaScript中的eval是上面两个函数的合集，既可以执行表达式，也可以执行代码</p><h3 id="9-时间"><a href="#9-时间" class="headerlink" title="9.时间"></a>9.时间</h3><p>在python中，有time模块来获取当前时间，在JavaScript中需要有一个Date对象，比如</p><p>var d = new Date() </p><pre><code>var d =  new Date()    d的值：Fri Mar 16 2018 15:16:27 GMT+0800 (中国标准时间)d.getMinutes()    得到分钟:16n = d.getMinutes()+4    可以加上4分钟：20d.setMinutes(n)    设置时间：1521184827952dFri Mar 16 2018 15:20:27 GMT+0800 (中国标准时间)</code></pre><p>d.getXXXX获取时间</p><p>d.setXXXX设置时间</p><h3 id="10-js正则"><a href="#10-js正则" class="headerlink" title="10.js正则"></a>10.js正则</h3><p>在JavaScript我们定义一个字符串是rep=’aasdfasd’,但是定义正则表达式是用//即：rep=/\d+/</p><ul><br><li>/…/  用于定义正则表达式</li><br><li>/…/g 表示全局匹配</li><br><li>/…/i 表示不区分大小写</li><br><li>/…/m 表示多行匹配</li><br></ul><br>JS正则匹配时本身就是支持多行，此处多行匹配只是影响正则表达式^和$，m模式也会使用^$来匹配换行的内容<br><br><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180319180406291-778585251.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180319180406291-778585251.png</a><br><br>上述例子中，如果只用了g 那么匹配到了JavaScript之后，换行之后的java就匹配不到了；如果加了m，就能够匹配到<br><br><br><br>在JavaScript中正则匹配有两个函数<br><br>test -   判断字符串是否符合规定的zhengze,如果符合返回true,如果不符合返回false<br><br>exec -  获得匹配的数据，如果匹配到了，以数组的形式返回匹配到的数据<br><br>　　非全局模式:获取匹配结果数组，注意：第一个元素是第一个匹配的结果，后面元素是正则子匹配（正则内容分组匹配）<br><br>　　全局模式:需要反复调用exec方法，来一个一个获取结果，直到匹配获取结果为null表示获取完毕<br><br><br><br><br><br>## 四、循环<br><br>### for循环<br><br>1.循环时，循环的元素是索引<br><br><br><code>basha = [11,22,33,44]for(var item in a){　　console.log(a[item]);  }a = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;,&#39;v2&#39;}for(var item in a){　　console.log(a[item]);}</code><br><br>2.设置变量i:<br><br><code>basha = [11,22,33,44]for(var i=0;i&lt;a.length;i++){}这种循环不适合字典的循环</code><br><br>## 五、条件语句<br><br><br><code>bashif(条件){}else if(条件){}else{}</code><br><br><br>判断条件：<br><ul><br><li>==      比较值相等</li><br><li>!=       不等于</li><br><li>===   比较值和类型相等</li><br><li>!===  不等于</li><br><li>||        或         python:or</li><br><li>&amp;&amp;      且　　 python:and</li><br></ul><h2 id="六、函数"><a href="#六、函数" class="headerlink" title="六、函数"></a>六、函数</h2><h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h3><p>JavaScript中函数基本上可以分为一下三类：</p><p>普通函数：</p><pre><code>function func(){  alert(13);  }</code></pre><p>匿名函数：</p><pre><code>//我们的定时器，我们可以写成：setInterval(&quot;func&quot;,5000);//但是我们也可以写成匿名函数的样式：这里面的函数没有名字setInterval(function(){    console.log(123);},5000);//下面的也是一个匿名函数var func = function(arg){     return &quot;tony&quot;;}</code></pre><p>自执行函数：创建函数并且自动执行，两个（），一个（）里面写函数，一个（）中写需要执行这个函数所传入的参数：</p><pre><code>(function(arg){    console.log(arg);})(1)</code></pre><h3 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2.作用域"></a>2.作用域</h3><p>其他的语言：以代码块作为作用域：</p><pre><code>public void Func(){      if(1==1){            string name=&quot;java&quot;;                }                  console.writeline(name);}Func()</code></pre><p>上述代码在运行的时候会报错，name这个变量只在if这个代码块中生效，如果出了这个代码块在调用就会报错</p><p>python：是以函数作为作用域的</p><pre><code>def func(){      if 1==1:           name=&#39;xiaoming&#39;      print(name)   }func()//在python中这个代码是可以运行的&lt;br&gt;print(name)//在python中这个代码是不可以运行的</code></pre><p>JavaScript：<br>a.是以函数作为作用域的</p><pre><code>function func(){     if(1==1){           var name=&quot;xiaoming&quot;;        }     console.log(name);  }func();//这个就可以执行</code></pre><p>b.函数的作用域在函数未被调用之前，已经被创建　　</p><p>c.函数的作用域存在作用域链，并且也是在被调用之前创建的</p><pre><code>xo = &#39;xiaoming&#39;function func(){　　var xo=&#39;eric&#39;    function inner(){    　　console.log(xo)　　}　　return inner;}var ret = func();//执行这个ret是inner的代码块:inner(){console.log(xo)}ret()//返回的是ericxo = &#39;xiaoming&#39;function func(){　　var xo=&#39;eric&#39;    function inner(){    　　console.log(xo)　　}　　var xo = &#39;tony&#39;;　　return inner;}var ret = func();ret()//返回的是tony,当解释器解析的时候里面的代码是不会执行的，只创建作用域。</code></pre><p> <a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316154914788-1112621431.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316154914788-1112621431.png</a></p><p>上面的代码，在没有执行的时候解释器编译的时候遇到func函数就生成一个作用域，里面又有一个inner函数，所以又生成了inner作用域，这两个是嵌套的关系，这个就是作用域链。</p><p>d.JavaScript函数内部局部变量提前声明</p><pre><code>function func(){    console.log(xxoo);}func();//程序直接报错function func(){    console.log(xxoo);    var xxoo = &#39;xiaoming&#39;;  }func();//这里输出的undefined，当解释器解析的时候会生成作用域链，同时会找出内部的局部变量，然后执行：var xxoo;但是没有赋值，那就是undefined。下面我们执行func()的时候，代码是从上到下执行的，运行console.log(xxoo)时，xxoo还没有被赋值，所以打印的就是undefined</code></pre><p> 例子：</p><p><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316230139169-1075541496.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316230139169-1075541496.png</a></p><p>所以上面的代码的结果依次为：</p><p><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316230422229-1398481031.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316230422229-1398481031.png</a></p><h3 id="3-JavaScript面向对象"><a href="#3-JavaScript面向对象" class="headerlink" title="3.JavaScript面向对象"></a>3.JavaScript面向对象</h3><p>对函数的一个变种：</p><p>之前我们创建函数是这样的：</p><pre><code>function foo(){  var xo=&#39;xiaoming&#39;;  }foo();</code></pre><p>那下面我们创建函数的时候用下面的方法：</p><pre><code>function Foo(n){     this.name=n;//这个this其实就是python中的self　　　this.sayName = function(){　　　　　console.log(this.name);　　　}}var obj1 = new Foo(&#39;we&#39;);//这样obj就创建了一个对象，对象中封装了一个nameobj1.nameobj1.sayName()var obj2 = new Foo(&#39;we&#39;);//这样obj就创建了一个对象，对象中封装了一个nameobj2.nameobj2.sayName()</code></pre><p> a.this代指对象（python self）</p><p>b.创建对象时，new函数（）</p><p><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316160815866-1566884061.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316160815866-1566884061.png</a></p><p>我们看，我们创建了obj1,2两个对象，当我们都执行.name和.sayName()函数的时候，sayName()相当于在每一个对象中都重复了定义了一次，这个就完全没有必要。所以我们应该把这个sayName()放在某一个地方，然后以后要用的时候就调用就可以了。</p><p>原型：</p><pre><code>function Foo(n){    this.name=n;}#Foo的原型Foo.prototype={　　&#39;sayName&#39;:function(){　　　　console.log(this.name);　　　　}}obj1 = new Foo(&#39;we&#39;);obj1.sayName()obj2 = new Foo(&#39;wwe&#39;);</code></pre><p> 这样我们在创建两个对象的时候，也就在Foo中只封装了一个name，如果在调用sayName函数的时候，会通过obj1先找到Foo这个类，然后通过这个类找到他的原型里的sayName函数，如果有就执行。</p><h2 id="七、DOM"><a href="#七、DOM" class="headerlink" title="七、DOM"></a>七、DOM</h2><p> 把html的标签转换成了文档对象，就可以依据JavaScript提供的功能找到当前页面的某些标签，从而可以改变标签的属性，内容等</p><h3 id="1-找到标签"><a href="#1-找到标签" class="headerlink" title="1.找到标签"></a>1.找到标签</h3><p>直接找：</p><ul><br><li>document.getElementById(‘i1’):&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;通过id选择器查找</li><br><li>document.get<span style="color: #ff0000">Elements</span>ByTagName(‘div’):&nbsp; &nbsp;通过标签名获取标签集合，获得的是多个元素，使用<span style="color: #ff0000">数组</span>组成的&nbsp;</li><br><li>document.get<span style="color: #ff0000">Elements</span>ByClassName(‘div’):根据class选择器获取标签集合</li><br><li>document.get<span style="color: #ff0000">Elements</span>ByName(‘user’):&nbsp; &nbsp; &nbsp; &nbsp;根据name属性获取标签集合</li><br></ul><br>间接找：<br><br>先找到一个标签，然后使用下面的方法可以找到其他的<br><br><br><code>bashparentNode          // 父节点childNodes          // 所有子节点firstChild          // 第一个子节点lastChild           // 最后一个子节点nextSibling         // 下一个兄弟节点previousSibling     // 上一个兄弟节点parentElement           // 父节点标签元素children                // 所有子标签firstElementChild       // 第一个子标签元素lastElementChild        // 最后一个子标签元素nextElementtSibling     // 下一个兄弟标签元素previousElementSibling  // 上一个兄弟标签元素</code><br><br><br>### 2.操作标签<br><br>文件内容操作：<br><ul><br><li>获取标签中的文本内容：标签.innerText&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 对标签内部文本进行重新赋值：标签.innerText=” “</li><br></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;i1&quot;&gt;        我是i1    &lt;/div&gt;    &lt;a&gt;asdf&lt;/a&gt;    &lt;a&gt;5+9&lt;/a&gt;    &lt;a&gt;greg&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>现在我有div,3个a标签：在console上进行调试</p><pre><code>document.getElementById(&#39;i1&#39;)                //获得id为i1的标签内容　　&lt;div id=​&quot;i1&quot;&gt;​    　　    我是i1   　　 ​&lt;/div&gt;​document.getElementById(&#39;i1&#39;).innerText;    //获取i1标签中的文字　　&quot;我是i1&quot;document.getElementById(&#39;i1&#39;).innerText = &#39;新内容&#39;;   //修改i1标签中的文字　　&quot;新内容&quot;document.getElementsByTagName(&#39;a&#39;)                   //通过标签名a来获得标签集合　　HTMLCollection(3) [a, a, a]0: a1: a2: alength: 3__proto__: HTMLCollectiondocument.getElementsByTagName(&#39;a&#39;)[1]                //想要获得标签集合中的某一个，就要像去数组元素一样的去取　　&lt;a&gt;​5+9​&lt;/a&gt;​document.getElementsByTagName(&#39;a&#39;)[1].innerText = 666;　　666tags=document.getElementsByTagName(&#39;a&#39;);　　HTMLCollection(3) [a, a, a]for(var i=0;i&lt;tags.length;i++){tags[i].innerText=777;}  //用循环把超链接中的文字都修改了　　777</code></pre><ul><br><li>innerHTML&nbsp; :获取全部内容包括HTML</li><br><li>value :<br><ul><br><li>对input操作，获取当前标签中的值</li><br><li>对select操作，获取当前已经选中的value值（selectedIndex以数组的形式改变选中的选项）</li><br><li>对textarea操作，获取文本框的值</li><br></ul><br></li><br></ul><br><h4>样式操作：</h4><br><ul><br><li>className<br><ul><br><li>tag.classname= ‘’ 直接做整体操作，如果标签有class选择器就修改class选择器的名称，如果没有就添加class选择器</li><br><li>tag.classList.add(‘样式名’) 一个选择器可以有多个名字，所以就有了classList，使用add方法就可以添加样式名</li><br><li>tag.classList.remove(‘样式名’)删除一个样式名</li><br></ul><br></li><br><li>style</li><br></ul><pre><code>&lt;div id=&#39;i1&#39; class=&quot;c1 c2&quot; style=&quot;fon-size:16px;background-color:red;&quot;&gt;&lt;/div&gt;//我们用js来为div加样式的话就可以这样写：var obj = document.getElementById(&#39;i1&#39;);obj.style.fontSize=&#39;16px&#39;;obj.style.backgroundColor = &#39;red&#39;;obj.style.color=&#39;red&#39; </code></pre><p></p><h4>属性操作：</h4><p></p><ul><br><li>setAttribute(‘属性名’，‘值’)</li><br><li>removeAttribute(‘属性名’)</li><br><li>attributes:获取所有属性</li><br></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;button&quot; onclick=&quot;AddEle();&quot; value=&quot;+&quot;/&gt;    &lt;input type=&quot;button&quot; onclick=&quot;AddEle2();&quot; value=&quot;+&quot;/&gt;    &lt;div id=&quot;i1&quot;&gt;        &lt;p&gt;&lt;input type=&quot;text&quot; /&gt;&lt;/p&gt;    &lt;/div&gt;    &lt;script&gt;　　　　　//第一种创建标签的方式，以字符串的方式        function AddEle(){            var tag = &quot;&lt;p&gt;&lt;input type=&#39;text&#39;/&gt;&lt;/p&gt;&quot;;　　　　　　　//注意：第一个参数只能是&#39;beforeBegin&#39;、 &#39;afterBegin&#39;、 &#39;beforeEnd&#39;、 &#39;afterEnd&#39;　　　　　　　document.getElementById(&#39;i1&#39;).insertAdjacentHTML(&quot;beforeEnd&quot;,tag); }function AddEle2() {            var tag=document.createElement(&#39;input&#39;);            tag.setAttribute(&#39;type&#39;,&#39;text&#39;);            tag.style.fontSize=&#39;16px&#39;;            tag.style.color=&#39;red&#39;;            var p =document.createElement(&#39;p&#39;);            p.appendChild(tag);            document.getElementById(&#39;i1&#39;).appendChild(p);        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>提交表单<br>任何标签都可以通过DOM提交表单</p><p>document.getElementById(‘form表单的选择器名称’).submit();</p><pre><code>&lt;form id=&quot;f1&quot; action=&quot;http://www.baidu.com&quot;&gt;        &lt;input type=&quot;text&quot;/&gt;        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;        &lt;a onclick=&quot;submitForm();&quot;&gt;提交&lt;/a&gt;    &lt;/form&gt;    &lt;script&gt;        function submitForm(){            document.getElementById(&#39;f1&#39;).submit();        }    &lt;/script&gt;</code></pre><p></p><h4>其他操作</h4><p></p><ul><br><li>console.log()&nbsp; 输出框</li><br><li>alert()&nbsp; 弹出框</li><br><li>confirm(信息)&nbsp; &nbsp;如果点击确定返回true,点击取消返回false</li><br><li>location.href&nbsp; 获取当前url</li><br><li>location.href = ‘<a href="http://www.baidu.com&#39;" target="_blank" rel="noopener">www.baidu.com&#39;</a>&nbsp; 重定向，跳转</li><br><li>location.reload()&nbsp; 重新加载，页面刷新</li><br><li>setInterval(‘func(){}’,second)&nbsp; 定时器&nbsp; ,var obj = setInterval(function(){},500);&nbsp; 定时器一直执行</li><br><li>clearInterval(obj)&nbsp; 清除定时器</li><br><li>setTimeout();&nbsp; 定时器，只执行一次。setTimeout(function(){},5000)；等5s之后才执行function</li><br><li>clearTimeout();&nbsp; 清楚setTimeout的定时器　</li><br></ul><h3 id="3-事件"><a href="#3-事件" class="headerlink" title="3.事件"></a>3.事件</h3><p>先看一道面试题：</p><p>　　行为 样式 结构     相分离的页面？</p><p>　　js     css    html    相互独立 </p><p>一般我们写HTML是下面这个样子的：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt; &lt;style&gt;        #test{            background-color: red;            width:300px;            height:400px;        } &lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;test&quot; onclick=&quot;t1();&quot;&gt;asdf&lt;/div&gt;    &lt;script&gt;        function t1(){            console.log(&quot;asdf&quot;);        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>但是这个没有做到相分离，我们在html中还是有onclick，所以是不符合要求的，那我们可以稍微的改一下：</p><pre><code> &lt;style&gt;        #test{background-color: red;width:300px;height:400px;} &lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;test&quot;&gt;asdf&lt;/div&gt;    &lt;script&gt;        var mydiv = document.getElementById(&#39;test&#39;);        mydiv.onclick = function(){            console.log(&quot;asdfa&quot;);        }    &lt;/script&gt;&lt;/body&gt;</code></pre><p>这样我们就把css,html,js分离了出来。</p><p>在看一个例子，一个表格，鼠标移动到哪行背景颜色变红色，移出来的时候恢复：</p><pre><code> &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot; width=&quot;300px;&quot;&gt;        &lt;tr&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;1&lt;/td&gt;            &lt;td&gt;1&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;2&lt;/td&gt;            &lt;td&gt;2&lt;/td&gt;            &lt;td&gt;2&lt;/td&gt;        &lt;/tr&gt;        &lt;tr&gt;            &lt;td&gt;3&lt;/td&gt;            &lt;td&gt;3&lt;/td&gt;            &lt;td&gt;3&lt;/td&gt;        &lt;/tr&gt;    &lt;/table&gt;    &lt;script&gt;        var myTrs = document.getElementsByTagName(&quot;tr&quot;);        var len = myTrs.length;        for(var i=0;i&lt;len;i++){            myTrs[i].onmousemove = function(){                //this,谁调用这个函数，this就指向谁                this.style.backgroundColor=&#39;red&#39;;            }            myTrs[i].onmouseout = function(){                this.style.backgroundColor=&#39;&#39;;            }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>需要注意的是，里面有一个this,表示的是当前触发事件的标签，而不能写成myTrs[i]，原因是：作用域的问题。在解析的时候，function里面的代码并不会去执行，在解析的时候循环就已经执行好了，相当于我们在看到的时候 i 已经等于3，那就获取不到想要的行了</p><p>再来看一道面试题：</p><p>　　div已经绑定了一个click事件，点击之后能够console出aaa，能不能再绑定一个click事件，在打印出aaa同时再打印出bbb?</p><pre><code>mydiv.addEventListener(&quot;click&quot;,function(){console.log(&#39;aaa&#39;)},false);mydiv.addEventListener(&quot;click&quot;,function(){console.log(&#39;bbb&#39;)},false);</code></pre><p>用到的是addEventListener，我们看一下第三个参数的含义：事件之捕捉和冒泡：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    #main{        width:300px;        height:400px;        background-color: pink;    }    #content{        width:150px;        height:200px;        background-color: green;    }&lt;/style&gt;&lt;body&gt;    &lt;div id=&quot;main&quot;&gt;        &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var mymain = document.getElementById(&#39;main&#39;);        var mycontent = document.getElementById(&#39;content&#39;);        mymain.addEventListener(&quot;click&quot;,function(){console.log(&quot;main&quot;)},false);        mycontent.addEventListener(&quot;click&quot;,function(){console.log(&quot;content&quot;)},false);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我们看看上面的例子，当我们是false的时候，我们点击content的div，显示的是：</p><p><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316183211859-1316554001.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316183211859-1316554001.png</a></p><p>当我们的参数是true的时候，我们显示的是：</p><p><a href="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316183211859-1316554001.png" target="_blank" rel="noopener">https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316183211859-1316554001.png</a></p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316183401359-2114176358.png" class="[class names]"><h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><h3 id="1-第一种绑定方式："><a href="#1-第一种绑定方式：" class="headerlink" title="1.第一种绑定方式："></a>1.第一种绑定方式：</h3><pre><code>&lt;input id=&quot;i1&quot; type=&quot;button&quot; onclick=&quot;ClickOn(this)&quot;&gt;function ClickOn(self){  //self当前点击的标签  }</code></pre><h3 id="2-第二种绑定方式："><a href="#2-第二种绑定方式：" class="headerlink" title="2.第二种绑定方式："></a>2.第二种绑定方式：</h3><pre><code>&lt;input id=&#39;i1&#39; type=&quot;button&quot;&gt;document.getElementById(&#39;i1&#39;).onclick = function(){  //this代指当前点击的标签  }</code></pre><ul><br><li>onmousemove：鼠标移入</li><br><li>onmouseout：鼠标移出</li><br><li>onclick:点击</li><br><li>onfocus:获得焦点</li><br><li>onblur：失去焦点</li><br><li>&nbsp;……</li><br></ul><p>下面我们来写一个模态对话框的实例：</p><pre><code> &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .hide{            display: none;        }        .c1{            position:fixed;            top:0;            left:0;            right:0;            bottom:0;            background-color: black;            opacity: 0.6;            z-index:9;        }        .c2{            width:500px;            height:300px;            background-color: white;            position:fixed;            left:50%;            top:50%;            margin-top:-150px;            margin-left:-250px;            z-index:10;        }    &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;margin:0;&quot;&gt;    &lt;div&gt;        &lt;table style=&quot;border:1px solid black;background-color:pink;text-align: center&quot;&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;主机名&lt;/th&gt;                    &lt;th&gt;端口&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr&gt;                    &lt;td&gt;192.168.123.1&lt;/td&gt;                    &lt;td&gt;22&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;192.168.123.2&lt;/td&gt;                    &lt;td&gt;23&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;192.168.123.3&lt;/td&gt;                    &lt;td&gt;24&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;        &lt;input type=&quot;button&quot; value=&quot;添加&quot; onclick=&quot;ShowModel();&quot;/&gt;    &lt;/div&gt;    &lt;!--遮罩层开始--&gt;    &lt;div id=&quot;i1&quot; class=&quot;c1 hide&quot;&gt;&lt;/div&gt;    &lt;!--遮罩层结束--&gt;    &lt;!--模态框开始--&gt;    &lt;div id=&quot;i2&quot; class=&quot;c2 hide&quot;&gt;        &lt;p&gt;&lt;input id=&quot;p1&quot; type=&quot;text&quot; /&gt;&lt;/p&gt;        &lt;p&gt;&lt;input id=&quot;p2&quot; type=&quot;text&quot; /&gt;&lt;/p&gt;        &lt;p&gt;            &lt;input type=&quot;button&quot; value=&quot;取消&quot; onclick=&quot;CancelModel();&quot; /&gt;            &lt;input type=&quot;button&quot; value=&quot;确定&quot; onclick=&quot;AcceptData();&quot;/&gt;        &lt;/p&gt;    &lt;/div&gt;    &lt;!--模态框结束--&gt;    &lt;script&gt;        function ShowModel() {            document.getElementById(&#39;i1&#39;).classList.remove(&#39;hide&#39;);            document.getElementById(&#39;i2&#39;).classList.remove(&#39;hide&#39;);        }        function CancelModel(){            document.getElementById(&#39;i1&#39;).classList.add(&#39;hide&#39;);            document.getElementById(&#39;i2&#39;).classList.add(&#39;hide&#39;);        }        function AcceptData(){            var p1 = document.getElementById(&#39;p1&#39;).value;            var p2 = document.getElementById(&#39;p2&#39;).value;            if(p1&amp;&amp;p2){                document.getElementById(&#39;i1&#39;).classList.add(&#39;hide&#39;);                document.getElementById(&#39;i2&#39;).classList.add(&#39;hide&#39;);            }else{                alert(&quot;请将数据填写完整&quot;);            }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>我们还可以对表格实现全选反选和取消：</p><pre><code> &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;margin:0;&quot;&gt;    &lt;div&gt;        &lt;table style=&quot;border:1px solid black;background-color:pink;text-align: center&quot;&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;请选择&lt;/th&gt;                    &lt;th&gt;主机名&lt;/th&gt;                    &lt;th&gt;端口&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody id=&quot;tb&quot;&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;                    &lt;td&gt;192.168.123.1&lt;/td&gt;                    &lt;td&gt;22&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;                    &lt;td&gt;192.168.123.2&lt;/td&gt;                    &lt;td&gt;23&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;&lt;input type=&quot;checkbox&quot; /&gt;&lt;/td&gt;                    &lt;td&gt;192.168.123.3&lt;/td&gt;                    &lt;td&gt;24&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;        &lt;input type=&quot;button&quot; value=&quot;添加&quot; onclick=&quot;ShowModel();&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;全选&quot; onclick=&quot;AllChoose();&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;取消&quot; onclick=&quot;NoneChoose();&quot;/&gt;        &lt;input type=&quot;button&quot; value=&quot;反选&quot; onclick=&quot;ReserveChoose();&quot;/&gt;    &lt;/div&gt;    &lt;script&gt;        function AllChoose(){            var tbody = document.getElementById(&#39;tb&#39;);            //获取所有的tr            var tr_list = tbody.children;            for (var i=0;i&lt;tr_list.length;i++){                //循环所有的tr,current_tr                var current_tr = tr_list[i];                var checkbox = current_tr.children[0].children[0];                checkbox.checked=true;            }        }        function NoneChoose(){            var tbody = document.getElementById(&#39;tb&#39;);            //获取所有的tr            var tr_list = tbody.children;            for (var i=0;i&lt;tr_list.length;i++){                //循环所有的tr,current_tr                var current_tr = tr_list[i];                var checkbox = current_tr.children[0].children[0];                checkbox.checked=false;            }        }        function ReserveChoose(){            var tbody = document.getElementById(&#39;tb&#39;);            //获取所有的tr            var tr_list = tbody.children;            for (var i=0;i&lt;tr_list.length;i++){                //循环所有的tr,current_tr                var current_tr = tr_list[i];                var checkbox = current_tr.children[0].children[0];                checkbox.checked=!checkbox.checked;            }        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>这里的checkbox:</p><p>　　获取值：checkbox对象.checked                                 设置值：checkbox对象.checked=true　　　　</p><p>后台管理左侧菜单：实现点击菜单一，其他菜单都收起来。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .hide{            display: none;        }        .item .header{            height:35px;            background-color: #2459a2;            color:white;            line-height: 35px;        }        .item .header:hover{            background-color: blue;            color:orange;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style=&quot;height:48px&quot;&gt;&lt;/div&gt;    &lt;div style=&quot;width:300px&quot;&gt;        &lt;div class=&quot;item&quot;&gt;            &lt;div id=&quot;i1&quot; class=&quot;header&quot; onclick=&quot;ChangeMenu(&#39;i1&#39;);&quot;&gt;菜单一&lt;/div&gt;            &lt;div class=&quot;content&quot;&gt;                &lt;div&gt;内容一&lt;/div&gt;                &lt;div&gt;内容二&lt;/div&gt;                &lt;div&gt;内容三&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;            &lt;div id=&quot;i2&quot; class=&quot;header&quot; onclick=&quot;ChangeMenu(&#39;i2&#39;);&quot;&gt;菜单二&lt;/div&gt;            &lt;div class=&quot;content hide&quot;&gt;                &lt;div&gt;内容一&lt;/div&gt;                &lt;div&gt;内容二&lt;/div&gt;                &lt;div&gt;内容三&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;            &lt;div id=&quot;i3&quot; class=&quot;header&quot; onclick=&quot;ChangeMenu(&#39;i3&#39;);&quot;&gt;菜单三&lt;/div&gt;            &lt;div class=&quot;content hide&quot;&gt;                &lt;div&gt;内容一&lt;/div&gt;                &lt;div&gt;内容二&lt;/div&gt;                &lt;div&gt;内容三&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;            &lt;div id=&quot;i4&quot; class=&quot;header&quot; onclick=&quot;ChangeMenu(&#39;i4&#39;);&quot;&gt;菜单四&lt;/div&gt;            &lt;div class=&quot;content hide&quot;&gt;                &lt;div&gt;内容一&lt;/div&gt;                &lt;div&gt;内容二&lt;/div&gt;                &lt;div&gt;内容三&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        function ChangeMenu(nid){            var current_header = document.getElementById(nid);            var item_list = current_header.parentElement.parentElement.children;            for(var i = 0;i &lt; item_list.length;i++){                var current_item = item_list[i];                current_item.children[1].classList.add(&#39;hide&#39;);            }            current_header.nextElementSibling.classList.remove(&#39;hide&#39;);        }    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> 当然菜单的点击事件也可以做一下修改：我们之前点击菜单的时候，我们因为每个菜单都设置了id,所以在onclick事件中我们传入的参数是id名称，</p><p>如果不添加id,我们改成onclick=”ChangeMenu(this)”，即在onclick传入的是this参数。</p><p>然后我们就不用通过document获取id标签，而是直接用var current_header = nid;</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css基础知识总结</title>
      <link href="/2018/11/21/css-ji-chu-zhi-shi-zong-jie/"/>
      <url>/2018/11/21/css-ji-chu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="css基本知识"><a href="#css基本知识" class="headerlink" title="css基本知识"></a>css基本知识</h2><p>我们先看一个小例子：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style=&quot;background-color:#2459a2;height: 48px;&quot;&gt;1&lt;/div&gt;    &lt;div style=&quot;background-color:red;&quot;&gt;2&lt;/div&gt;    &lt;div style=&quot;background-color:green;&quot;&gt;3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre> <div style="background-color:#2459a2;height: 48px;">1</div><br> <div style="background-color:red;">2</div><br> <div style="background-color:green;">3</div><p>我们可以看到我们在div中加了style,里面有background-color，height等属性，这样就使的原本什么都没有的div添加了背景色高度等。</p><h2 id="css的编写"><a href="#css的编写" class="headerlink" title="css的编写"></a>css的编写</h2><p>在标签上设置style属性：width,height,background…….<br>写在head里面，写一个&lsaquo;style&rsaquo;标签中写样式：</p><pre class=" language-bash"><code class="language-bash"><span class="token operator">&lt;</span>head<span class="token operator">></span><span class="token operator">&lt;</span>style<span class="token operator">></span><span class="token comment" spellcheck="true">#i1{</span>  background-color:red<span class="token punctuation">;</span>  height:48px      <span class="token punctuation">}</span><span class="token operator">&lt;</span>/style<span class="token operator">></span><span class="token operator">&lt;</span>/head<span class="token operator">></span></code></pre><p> 单独创建一个.css格式的文件，在.css文件中写入样式，在html文件中的head标签中引入该.css文件：<br>&lsaquo;link rel=”stylesheet” href=”common.css” /&rsaquo;</p><h2 id="选择器使用css"><a href="#选择器使用css" class="headerlink" title="选择器使用css"></a>选择器使用css</h2><p> 1.标签选择器：</p><pre><code>div{background-color:red; } &lt;div &gt; &lt;/div&gt;</code></pre><p>2.class选择器：</p><pre><code>.bd{background-color:red; } &lt;div class=&#39;bd&#39;&gt; &lt;/div&gt; </code></pre><p>3.id选择器：</p><pre><code>#idselect{background-color:red; } &lt;div id=&#39;idselect&#39; &gt; &lt;/div&gt;</code></pre><p>4.关联选择器（空格）</p><pre><code>#idselect p{background-color:red; } &lt;div id=&#39;idselect&#39; &gt; &lt;p&gt; &lt;/p&gt; &lt;/div&gt;</code></pre><p>5.组合选择器：（逗号）</p><pre><code>input,div,p{ background-color:red; } </code></pre><p>6.属性选择器：</p><pre><code>input[type=&#39;text&#39;]{ width:100px; height:200px; } </code></pre><p>css中的优先级</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .c1{            background-color: red;            color: white;        }        .c2{            font-size: 58px;            #color:black;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;c1 c2&quot;&gt;asdfas&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> 上面我们设置了一个div有两个class名称，然后先设置了一个color:white,显示的效果如下：<br><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313170423687-1932802288.png" class="[class names]"></p><p>下面我们在.c2的css中把color:black的注释去掉，显示的效果如下：</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313170519958-1912902775.png" class="[class names]"><p>我们再在&rsaquo;div&rsaquo;标签中添加：style=”color:blue”，那么显示的效果如下：</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313170746969-1806163476.png" class="[class names]"><p>这就涉及到了css样式的优先级：（就近原则）</p><p>　　style—&gt;c2—-c1(这里c2,c1的优先级是看在css中谁的样式写在下面，如果上面head标签的style标签中两个位置互换，那么就是c1的优先级大于c2)</p><h2 id="常用的css中的样式"><a href="#常用的css中的样式" class="headerlink" title="常用的css中的样式"></a>常用的css中的样式</h2><p> 1.边框</p><p>默认4个边都加上：</p><p>　　 border:1px solid/dotted red (1像素，实线/虚线，红色)：</p><p>只加左边和右边：</p><p>　　border-left-right:1px solid/dotted red </p><p> 2.height,width,line-height,color,font-size,font-weight:</p><p>height,width:高度，宽度</p><p>　　height:48px;width:200px     or     height:48px;width:80%（可以用具体的值也可以用百分比）</p><p>text-align:center，水平方向居中</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313172436168-615590022.png" class="[class names]"><p>line-height行高：</p><p>　　如果我们想要把文字垂直居中就可以用这个属性（行高像素==height像素）,即height:48px，line-height:48px，则字体就居中了。</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313172743598-915330394.png" class="[class names]"><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313172752196-1584586787.png" class="[class names]"><p>font-size字体大小：font-size:12px;</p><p>font-weight字体的样式：100-900,bold(加粗),bolder（更粗），inherit,initial,lighter,normal,unset</p><p>color字体颜色；</p><p>3.float属性：浮动</p><p>如果我们写了2个div,那这2个div就会每个各占一行，如果我们想让一个div在左边占20%，一个div在右边80%，想要两个div在一行对接起来，那就需要用到float</p><p>首先看看我们不用float的效果：</p><pre><code>&lt;div style=&quot;background-color: red;width:20%;&quot;&gt;div1&lt;/div&gt;&lt;div style=&quot;background-color: green;width:80%&quot;&gt;div2&lt;/div&gt;</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313173811075-1960358527.png" class="[class names]"><p> 如果我们让这两个div都向左浮动：</p><pre><code>&lt;div style=&quot;background-color: red;width:20%;float:left;&quot;&gt;div1&lt;/div&gt;&lt;div style=&quot;background-color: green;width:80%;float:left&quot;&gt;div2&lt;/div&gt;</code></pre><p> 两个就重合在一起，并且一个站20%，一个占80%<br><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313174005712-565863141.png" class="[class names]"></p><p>如果我改成div1占20%往左浮动，div2占60%往右浮动：那么中间就会空出20%</p><pre><code>&lt;div style=&quot;background-color: red;width:20%;float:left;&quot;&gt;div1&lt;/div&gt;&lt;div style=&quot;background-color: green;width:60%;float:right&quot;&gt;div2&lt;/div&gt;</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313174212711-495932291.png" class="[class names]"><p> 现在我们写一个盒子，里面有一些div：</p><pre><code>&lt;div style=&quot;width: 300px; border: 1px solid red;&quot;&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;        &lt;div style=&quot;width:96px;height:30px;border:1px solid green;float:left&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p> 我们可以发现用了float我们就可以做到类似很多前端页面一块一块的样式，我们最外面的div的高度是随着里面小div不断的增多而增多的。</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313175552747-1722762029.png" class="[class names]"><p>但是有一个问题，我们可以看到上面有一个红色的线，他是外层div的边框，为什么父div的边框没有了呢，只有一个了呢？这个就是使用float之后会产生的问题。</p><p>解决方法：</p><p>在父div中的最后加上这么一段：<div style="clear:both;"></div></p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313175903532-1925960022.png" class="[class names]"><p>这样，父div的边框就显现了出来</p><p>4.display</p><p>首先我们看一段：</p><pre><code>&lt;div style=&quot;background-color: red;&quot;&gt;div1&lt;/div&gt;&lt;span style=&quot;background-color: green;&quot;&gt;span1&lt;/span&gt;</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313180454153-496478144.png" class="[class names]"><p>现在我们想要让块级标签变成一个行内标签：display:inline</p><pre><code>&lt;div style=&quot;background-color: red;display:inline;&quot;&gt;div1&lt;/div&gt;&lt;span style=&quot;background-color: green;&quot;&gt;span1&lt;/span&gt;</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313180620892-412934657.png" class="[class names]"><p>我们想要让span这个行内标签变成块级标签：display:block;<br><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313180735746-1839341791.png" class="[class names]"></p><hr><p>行内标签：无法设置高度，宽度，padding,margin</p><p>块级标签：可以设置高度，宽度，padding,margin</p><pre><code>&lt;span style=&quot;background-color: red;width:200px;height:48px;&quot;&gt;span1&lt;/span&gt;&lt;a style=&quot;background-color: red;&quot;&gt;chaolianjei&lt;/a&gt; 我们可以发现一点效果都没有</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313181138086-1758711987.png" class="[class names]"><p>display:inline-block;</p><p>　　具有inline，默认自己有多少占多少；</p><p>　　具有block，可以设置高度，宽度，padding,margin</p><pre><code>&lt;span style=&quot;background-color: red;width:200px;height:48px;display: inline-block;&quot;&gt;span1&lt;/span&gt;&lt;a style=&quot;background-color: red;&quot;&gt;chaolianjei&lt;/a&gt;</code></pre><p> 加了display:inline-block;之后，span就可以设置宽高了：</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313181452665-1096668336.png" class="[class names]"><p>display:none;让标签消失：<br><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313181726886-476302618.png" class="[class names]"><br><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180313181829167-173447817.png" class="[class names]"></p><p>5.padding margin(0 auto)内边距，外边距：</p><p>margin:</p><p>　　margin:0 auto;上下为0，左右居中</p><p>6.position:</p><p>fixed—-&gt;固定在页面的某个位置，滚轮滚动，位置也不会变<br>absolute—-&gt;绝对定位，单用它，滚轮滚动时，位置会改变，要和relative一起使用<br>relative<br>fixed：</p><p>我们先看一串代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style=&quot;width: 50px;height:50px;background-color: black;color:white&quot;&gt;返回顶部&lt;/div&gt;    &lt;div style=&quot;height: 5000px;background-color: #dddddd&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314004713565-29421786.png" class="[class names]"><p>现在我们希望的是 “返回顶部” 这个div 固定在浏览器的右下角</p><pre><code>&lt;div style=&quot;width: 50px;height:50px;background-color: black;color:white;    position:fixed;bottom:20px;right:20px;&quot;    &gt;返回顶部&lt;/div&gt;</code></pre><p> 我在style中添加了</p><p>position:fixed;bottom:20px;right:20px;</p><p> 这样我们就把那个div固定在右下角了。</p><p>我们再看一个例子：有的网站，它的菜单栏是一直在浏览器的上面的，即使是滚动条滚动，头部的菜单栏也不会变，这个我们应该怎么做呢：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .pg-header{            height:48px;            background-color: black;            color: #dddddd;            position:fixed;            top:0;            right:0;            left: 0;        }        .pg-body{            background-color: #dddddd;            height:5000px;            margin-top:50px ;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;pg-header&quot;&gt;头部&lt;/div&gt;    &lt;div class=&quot;pg-body&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> 其实只需要加上上面色的代码就可以了，下面的margin-top是为了让pg-body的能够往下来一点，显示出全部内容</p><p> relative+absolute:</p><p>我现在有3个div:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style=&quot;position: relative;height:200px;width:400px;border: 1px solid red;margin:0 auto;text-align: center;&quot;&gt;div1&lt;/div&gt;    &lt;div style=&quot;position: relative;height:200px;width:400px;border: 1px solid red;margin:0 auto;text-align: center;&quot;&gt;div2&lt;/div&gt;    &lt;div style=&quot;position: relative;height:200px;width:400px;border: 1px solid red;margin:0 auto;text-align: center;&quot;&gt;div3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314011238569-1231745594.png" class="[class names]"><p>我想要在div1的左下角放一个黑色的小方框， div2的右下角放一个黑色的小方框，div3的左上角放一个黑色的小方框，应该怎么做 ：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style=&quot;position: relative;height:200px;width:400px;border: 1px solid red;margin:0 auto;text-align: center;&quot;&gt;        div1        &lt;div style=&quot;width:50px;height:50px;background-color: black;position:absolute;left:0;bottom:0&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div style=&quot;position: relative;height:200px;width:400px;border: 1px solid red;margin:0 auto;text-align: center;&quot;&gt;        div2        &lt;div style=&quot;width:50px;height:50px;background-color: black;position:absolute;right:0;bottom:0&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div style=&quot;position: relative;height:200px;width:400px;border: 1px solid red;margin:0 auto;text-align: center;&quot;&gt;        div3        &lt;div style=&quot;width:50px;height:50px;background-color: black;position:absolute;left:0;top:0&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>只要relative 和 absolute 相配合，然后设置top,left,right,bottom的值就可以了，这个值可以是正数也可以是负数</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314011833776-1143210207.png" class="[class names]"><p>还有一个场景：我们点一个按钮，然后就会跳出一个小窗口，这个时候窗口以外的东西就没有办法进行操作了，如：我点击了大模态框，之后跳出了large model，但是灰色的地方是没有办法进行操作的</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314012405870-1499502095.png" class="[class names]"><p>这就是一个典型的三层模式：本身文本是一层，灰色的遮罩是一层，弹出的框是一层。那我们怎么实现这个呢？</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div style=&quot;width:400px;height:100px;background-color: white;        position: fixed;top:50%;left: 50%;        margin-top: -50px;margin-left:-200px;        z-index:10;&quot;&gt;&lt;/div&gt;    &lt;div style=&quot;position: fixed;background-color: black;top:0;bottom:0;right:0;left: 0; opacity: 0.6;z-index: 9;&quot;&gt;&lt;/div&gt;    &lt;div style=&quot;height:5000px;background-color: green;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> 效果如图所示：下面有一个green的div，然后有一个black的div，只是设置了透明度，最上面有一个居中的白色div</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314013726824-96467572.png" class="[class names]"><p>分析：首先我们先说两个新的属性：</p><p>opcity:0.6;设置透明度，值为0-1</p><p>z-index:9，设置优先级，值越高优先级越大</p><p>我们先实现两个div，一个是绿色的，一个是黑色的。这个很简单。下面要再加上第三层。最关键的就是这上面两个属性，如果透明属性没有的话，在做两层的时候，黑色的就会把绿色彻底覆盖住，如果没有优先级属性的话，那么在做第三个div的时候就会不知道谁覆盖了谁。</p><p>这里我们还要记录的是居中方法：</p><p>position: fixed;top:50%;left: 50%;<br>margin-top: -50px;margin-left:-200px;<br> 设置50%，然后用margin返回宽高的一半，这样就能够让一个div居中显示</p><p> 7.overflow</p><p> 我们设置了一个div的宽度和高度，现在想要在这个div中放入一个图片，那图片有自己的高度和宽度。如果直接发放进去就会超出div的范围显示，那我们怎么办呢？</p><p>在style中加入overflow属性：</p><p>hidden：超出的部分隐藏<br>auto:超出的部分会给滚动条</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314015241693-1755946809.png" class="[class names]"><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314015337065-1802362552.png" class="[class names]"><p>8.hover</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        .pg-header{            position: fixed;            top:0;            right:0;            left:0;            height:48px;            background-color: #2459a2;            line-height:48px;        }        .pg-body{            margin-top:50px;        }        .w{            width:980px;            margin:0 auto;        }        .pg-header .menu{            display: inline-block;            padding:0 10px;            color:white;        }        /*当鼠标移动到当前标签的时候，以下css属性才会生效*/        .pg-header .menu:hover{            background-color: blue;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;pg-header&quot;&gt;        &lt;div class=&quot;w&quot;&gt;            &lt;a class=&quot;logo&quot;&gt;logo&lt;/a&gt;            &lt;a class=&quot;menu&quot;&gt;全部&lt;/a&gt;            &lt;a class=&quot;menu&quot;&gt;42区&lt;/a&gt;            &lt;a class=&quot;menu&quot;&gt;段子&lt;/a&gt;            &lt;a class=&quot;menu&quot;&gt;1024&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;pg-body&quot;&gt;        &lt;div class=&quot;w&quot;&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> hover当鼠标移动到超链接的时候，就会对hover的css里的属性生效</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180314020509725-543658825.png" class="[class names]"><p>9.background</p><p>background-image:url(‘image/4.jpg’)：背景是一个图片，如果这个div比图片的尺寸还要大的话，图片就会一直重复着放</p><p>　　应用场景：渐变色的背景，我们只需要一个很窄的图片，就可以利用这个属性，让整个背景都是这个渐变色的图片</p><p> background-repeat:no-repeat/repeat-x/repeat-y：改属性设置图片是否要重复，水平重复还是垂直重复</p><p>background-position:10px 10px 选取一张图上的某一个位置进行显示</p><p>　　应用场景：网站有的时候用一张图上存储了很多的图标，要用哪个图标就可以选哪个坐标</p><h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><h3 id="一、主站布局："><a href="#一、主站布局：" class="headerlink" title="一、主站布局："></a>一、主站布局：</h3><pre><code>&lt;div class=&quot;pg-header&quot;&gt;        &lt;div style=&quot;width:980px;margin:0 auto;&quot;&gt;            内容自动居中        &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;pg-content&quot;&gt;&lt;/div&gt;&lt;div class=&quot;pg-footer&quot;&gt;&lt;/div&gt;</code></pre><h3 id="二、后台管理布局"><a href="#二、后台管理布局" class="headerlink" title="二、后台管理布局"></a>二、后台管理布局</h3><p>同样都是三个部分，头部，中间内容，和尾部：</p><p>我们先看看中间的变化：<br>一类是中间内容的菜单和内容都不动，右边内容多的时候出现滚动条<br>我们用position:fixed做的话应该怎么做呢：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        body{            margin:0 auto;        }        .left{            float:left;        }        .right{            float:right;        }        .pg-header{            height:48px;            background-color: #2459a2;            color:white;        }        .pg-content .menu{            position: fixed;            top:48px;            left:0;            bottom:0;            width:200px;            background-color: #dddddd;        }        .pg-content .content{            position: fixed;            top:48px;            bottom: 0;            left:200px;            right:0;            background-color:purple;            overflow: auto;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;pg-header&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;pg-content&quot;&gt;        &lt;div class=&quot;menu left&quot;&gt;a&lt;/div&gt;        &lt;div class=&quot;content left&quot;&gt;            &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;pg-footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> 我们通过用position:fixed实现了菜单栏和内容栏的固定，然后当内容过多的时候我们就可以用overflow：auto实现添加一个滚动条，从而实现了布局</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180315005150184-1155522269.png" class="[class names]"><p>还有一类是中间内容部分如果多了，我们让左边的菜单跟随滚动条：</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180315005607953-367238078.png" class="[class names]"><pre><code> &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;style&gt;        body{            margin:0 auto;        }        .left{            float:left;        }        .right{            float:right;        }        .pg-header{            height:48px;            background-color: #2459a2;            color:white;        }        .pg-content .menu{            position: absolute;            top:48px;            left:0;            bottom:0;            width:200px;            background-color: #dddddd;        }        .pg-content .content{            position: absolute;            top:48px;            bottom: 0;            left:200px;            right:0;            min-width: 980px;            /*background-color:purple;*/            /*overflow: auto;*/        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;pg-header&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;pg-content&quot;&gt;        &lt;div class=&quot;menu left&quot;&gt;a&lt;/div&gt;        &lt;div class=&quot;content left&quot;&gt;            &lt;div style=&quot;background-color: purple&quot;&gt;                &lt;p style=&quot;margin: 0;&quot;&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;pg-footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>那和第一类的区别就在于，我们用的是position:absolute进行定位：</p><p>postion:absolute这个属性，可以在页面一开始生成的时候进行初始定位，但是随着你滚动滚动条的时候，定位就会改变，随着滚动条一起滚动，所以我们就可以利用这特点进行操作。</p><p>如果想要背景也跟着一起的话，可以在用一个div把内容包住，然后在这个div里面设置一个background-color，这样背景颜色就可以跟着内容一起增加。</p><p>如果我们要用absolute来实现第一类情况的话，我们也只要在第二类的基础上加上overflow:auto，就可以变回第一种情况了，非常的方便。</p><p>当然我们考虑一种情况，如果我们的浏览器不断的缩小，那个我们也要保证我们的内容要正常显示，这个时候就需要左右滚动条，我们就可以设置一下内容div的最小宽度min-width:980px，当小于这个宽度的时候就出现滚动条，就ok了</p><p>我们再看看头部的变化：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;fontawesome-free-5.0.8/web-fonts-with-css/css/fontawesome-all.min.css&quot;&gt;    &lt;style&gt;        body{            margin:0 auto;        }        .left{            float:left;        }        .right{            float:right;        }        .pg-header{            height:48px;            background-color: #2459a2;            color:white;            line-height: 48px;        }        .pg-header .logo{            width:200px;            background-color: cadetblue;            text-align: center;        }        .pg-header .user{            height:48px;            position: relative;            margin-right:60px;            padding:0 20px;        }        .pg-header .user:hover{            background-color: #204982;        }        .pg-header .user .a img{            height:40px;            width:40px;            margin-top: 4px;            border-radius:50%;        }        .pg-header .user .menu2{            position:absolute;            top:48px;            right:-10px;            background-color: white;            width:100px;            z-index:10;            display: none;            color:black;            text-align:center;        }        .pg-header .user .menu2 a{            display: block;            border-bottom: 1px solid black;            text-decoration:none;/*去掉超链接的下划线*/        }        .pg-header .user:hover .menu2{            display:block;        }         /* 未访问的链接 */        .pg-header .user .menu2 a:link{            color:black;        }        .pg-header .user .menu2 a:hover{            background-color: #dddddd;        }        .pg-header .icons{            padding:0 20px;        }        .pg-header .icons:hover{            background-color: #204982;        }        .pg-content .menu{            position: absolute;            top:48px;            left:0;            bottom:0;            width:200px;            background-color: #dddddd;        }        .pg-content .content{            position: absolute;            top:48px;            bottom: 0;            left:200px;            right:0;            min-width: 980px;            /*background-color:purple;*/            overflow: auto;            z-index:9;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;pg-header&quot;&gt;        &lt;div class=&quot;logo left&quot;&gt;logo图标&lt;/div&gt;        &lt;div class=&quot;user right&quot;&gt;            &lt;a class=&quot;a&quot; href=&quot;#&quot;&gt;                &lt;img src=&quot;1.jpg&quot;&gt;            &lt;/a&gt;            &lt;div class=&quot;menu2&quot;&gt;                &lt;a href=&quot;#&quot;&gt;我的资料&lt;/a&gt;                &lt;a href=&quot;#&quot;&gt;注销&lt;/a&gt;            &lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;icons right&quot;&gt;            &lt;i class=&quot;far fa-envelope&quot;&gt;&lt;/i&gt;            &lt;span&gt;5&lt;/span&gt;        &lt;/div&gt;        &lt;div class=&quot;icons right&quot;&gt;            &lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt;            &lt;span&gt;3&lt;/span&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;pg-content&quot;&gt;        &lt;div class=&quot;menu left&quot;&gt;a&lt;/div&gt;        &lt;div class=&quot;content left&quot;&gt;            &lt;div style=&quot;background-color: purple&quot;&gt;                &lt;p style=&quot;margin: 0;&quot;&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;                &lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;&lt;p&gt;afasdf&lt;/p&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;pg-footer&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> 显示的效果图就是如下效果：</p><img src="https://images2018.cnblogs.com/blog/1307091/201803/1307091-20180316003805580-347537174.png" class="[class names]"><p>需要知道的知识：</p><p>关于超链接的：</p><pre><code>a:link {color: #FF0000} /* 未访问的链接 */a:visited {color: #00FF00} /* 已访问的链接 */a:hover {color: #FF00FF} /* 鼠标移动到链接上 */a:active {color: #0000FF} /* 选定的链接 */text-decoration:none;/*去掉超链接的下划线*/</code></pre><p>关于边框的：</p><pre><code>border-radius:50%;/*把边框变成椭圆*/</code></pre><p>关于菜单栏的出现消失，不用js的做法：</p><pre><code>.pg-header .user .menu2{    display: none;}.pg-header .user:hover .menu2{    display:block;}/*这样做就能够实现，当鼠标放在头像上菜单栏自动出现，当鼠标移开的时候菜单栏自动隐藏*/ 关于菜单栏的图标的：</code></pre><p>到<a href="https://fontawesome.com/icons" target="_blank" rel="noopener">https://fontawesome.com/icons</a>下载图标包，然后导入css文件，并在网站上寻找相关的图片的html，就可以显示了：</p><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;fontawesome-free-5.0.8/web-fonts-with-css/css/fontawesome-all.min.css&quot;&gt;/*导入css文件*/&lt;i class=&quot;far fa-envelope&quot;&gt;&lt;/i&gt;/*应用图标的html*/&lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>嵌入式学习 准备篇</title>
      <link href="/2018/11/21/qian-ru-shi-xue-xi-zhun-bei-pian/"/>
      <url>/2018/11/21/qian-ru-shi-xue-xi-zhun-bei-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是个开始，工欲善其事，必先利其器。</p><p>对于刚工作了一个月的我来说，我将来要走的路还很长。</p><p>三年前的自己选择的学校和专业，决定了今天的我。今天的选择决定了将来的我。</p><p>现在的工作和我自己之前的期望值还有有很大的差距，未来的路该怎么去走?</p><p>想了些许，答案就是要让自己变得有价值，关于如何提升自己，就现在所处的环境来说，学习一种技能是迫在眉睫，结合之前所学，选择嵌入式开发是思考许久的决定。</p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncHC1fBAjbkqficlibArwzZJiaKFibljibTldP61nhibtv9CM1L8ZjAIhLcPwg/640?wx_fmt=jpeg" class="[class names]"><h2 id="回归正题"><a href="#回归正题" class="headerlink" title="回归正题"></a>回归正题</h2><p>废话不多说，既然决定了开始学习嵌入式，就给自己规划一个学习路线，有目的的去学习才会清晰自己需要什么，该做什么。要明确自己的学习路线。看下面的嵌入式知识图谱！</p><img src="https://mmbiz.qpic.cn/mmbiz_png/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncfOWowPvBw2Oq9AtD7rNtZibqUdDabt5WENzJTp2v8IYEfeicmn69eDhg/640?wx_fmt=png" class="[class names]"><p>是不是感觉一头雾水，一脸懵逼，我同样也有这样的感觉，当我第一眼看到它的时候，我甚至有点质疑自己的选择。但是万事开头难，要一点点攻破，先从基础的开始吧！比如我选择从相对简单的单片机开始。然后想学嵌入式的话其实就是比单片机复杂，其中的原理是相同的，熟悉了单片机，到时想要转学嵌入式的话，只要花时间好好学，肯定行的。</p><h2 id="单片机学习线路"><a href="#单片机学习线路" class="headerlink" title="单片机学习线路"></a>单片机学习线路</h2><p>先给自己定一个小目标，就从单片机开始吧。单片机学习起来其实不难，反而是一件比较有趣的事情，之所以新手感觉比较难是因为不知道该怎么入手，从哪里开始学起。单片机的学习无外乎两方面：</p><h3 id="一，电路-；"><a href="#一，电路-；" class="headerlink" title="一，电路 ；"></a>一，电路 ；</h3><p>先说电路，说到电路不得不提三本书。模电，数电，电路。可以说这三本书是学习电路的必经之路。学习单片机最好是要学习电路。</p><h3 id="二，编程语言。"><a href="#二，编程语言。" class="headerlink" title="二，编程语言。"></a>二，编程语言。</h3><p>接下来学编程语言，单片机的编程语言是结构化的C语言。C语言的学习也不是那么容易的，至少指针就够你迷糊一段时间的。还好大学期间学习过一学期，大概懂一点，算是入门了，学习C你可以先系统的学习一段时间，做一些练习，不用着急去将它应用到单片机上。</p><p>学习单片机需要动手，不是照着课本去死记硬背。学习单片机的第一个概念：确定好所学习的单片机具体型号。比如说，你要学习51单片机，你所确定的型号是STC89C52，这款单片机虽然比较老了，但是依然具有学习价值，淘宝有卖，还带教程。下面是我买的。</p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncwwlf4Nfd4tPBafTnDaC6PZtYRvWJwNG1qiaW6icT1n3XvuR9fAQMSbag/640?wx_fmt=jpeg" class="[class names]"><p>C语言我选择《C语言从入门到精通》.(王娣,韩旭 )。</p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5nc0omN5w4gibOuYF8MEZRQplHujMcvLicr84VzCjIVwaWDUNTsSvj0V7Lw/640?wx_fmt=jpeg" class="[class names]"><p>学习就先从简单的51单片机开始，把这块板子搞懂了，再去买块stm32的板子学习，精通后可以买块树莓派研究研究了，学习就是这样循序渐进的。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncD6iassbQCKYfxvEhEo3jsPjEUtzhznN3nwDsPib20xQLDGuJJdg6q8zQ/640?wx_fmt=png" class="[class names]"><h2 id="什么是单片机？"><a href="#什么是单片机？" class="headerlink" title="什么是单片机？"></a>什么是单片机？</h2><p>单片机（Microcontrollers）是一种集成电路芯片，是采用超大规模集成电路技术把具有数据处理能力的中央处理器CPU、随机存储器RAM、只读存储器ROM、多种I/O口和中断系统、定时器/计数器等功能（可能还包括显示驱动电路、脉宽调制电路、模拟多路转换器、A/D转换器等电路）集成到一块硅片上构成的一个小而完善的微型计算机系统，在工业控制领域广泛应用。从上世纪80年代，由当时的4位、8位单片机，发展到现在的300M的高速单片机。</p><p>不是完成某一个逻辑功能的芯片,而是把一个计算机系统集成到一个芯片上。相当于一个微型的计算机，和计算机相比，单片机只缺少了I/O设备。概括的讲：一块芯片就成了一台计算机。 下面是我STC89c52的板子原理图。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncrBNQJUXSuLGX34DKnWzXmlPd1L91CgOJZwMOElX9RLK0Hx8ib2kj0Cg/640?wx_fmt=png" class="[class names]"><h2 id="学习单片机时候一定要看书"><a href="#学习单片机时候一定要看书" class="headerlink" title="学习单片机时候一定要看书"></a>学习单片机时候一定要看书</h2><p>不能总是看书，但是学习它首先必须得看书，那这不很矛盾。因为从书中你需要大概了解单片机各个功能寄存器（比如引脚控制寄存器、定时、中断、串口相关寄存器），控制单片机的核心是用程序去控制单片机的各个功能寄存器，给寄存器赋值二进制数据0或者1，这样一来对于引脚寄存器单片机可以根据二进制数据0和1输出高低电平控制外部设备，对于内部资源寄存器，单片机也通过二进制数据0和1使用单片机内部的功能。比如单片机引脚寄存器P1，语句P1=0xfe;（MOV P1，#0FEH）。</p><p>说明现在控制单片机P1口的第一个引脚输出低电平，其他引脚输出高电平。比如中断中断允许寄存器IE，语句IE=0x81;（MOV IE，#81H） 则说明控制中断打开总开关和外部中断0的子开关。至于看书，只需大概了解单片机各管脚、各个特殊功能寄存器都是干什么的？能实现什么样的功能？这个非常重要，这也许是看书的最主要的目的。第一次，第二次你可能看不明白，但这不要紧，因为还缺少实际的感观认识。</p><p>通过接下来的实验就可以非常感观的认识，在这个过程一定要花时间，学习程序不能硬背，但是学习寄存器一定要下功夫，理解他的功能所在。推荐一本书，就这一本就足够了，书名是《例说8051》有汇编语言和C语言版本的，非常强悍的一本书，但是我用一个五一放假的时间看完了这本书，看完后，觉得自己已经是单片机高手了。书中图文并茂，内容安排紧张有序，并非市面上很多说教的技术文档式的书，什么学完概念，学指令，学完指令学接口，学完接口才知道，原来学习单片机是学天书。</p><p>根据书本的安排循序渐进的看完前两章，然后一定是实践，一定是实践啊，这是非常关键的一步，在战场上上纸上谈兵的列子很多，在学习单片机也一样，很多相关专业的研究生甚至博士生直到毕业都不清楚单片机的IO口的分布，不知道分布谈何说开发呢？更有一些所谓的单片机高手只停留在编程，以为了买了一块高级学习板，练习完了里面所有的程序，感觉自己排第二没人敢拍第一，觉得下一步不知道如何学习单片机了。殊不知，他们中的很多人到最后单片机LED的电阻加多大都不清楚更不用说单片机的引脚分布，你说，如果这样去开发那不是“草菅人命”啊。不是纸上谈兵是什么啊。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncT3ObMYJUTcvFW5CzzAMvg2TJ6lUQbZvkicM15mNoSWJBKgczKLbVKpQ/640?wx_fmt=png" class="[class names]"><h2 id="学习单片机准备什么？"><a href="#学习单片机准备什么？" class="headerlink" title="学习单片机准备什么？"></a>学习单片机准备什么？</h2><p>学习单片机看书不够，实践也要从实际出发，现在的技术太模块了，什么都可以模块，模块的到最后，技术人员都成了只会用了，祖先的留下的知识，基础的知识该知道还是一定要知道的啊。 毕竟学习单片机的最终目的是开发，是通过创造智能控制的实物，体现自己的价值。</p><p>关于实践有两种方法可以选择一种方法：购买一块51单片机的实验板，不要求功能太的，对于初学者来功能非常多的那种板子，上面有很多东西你这辈子都用不着，更有实验板为了增加功能，降低成本，实验板上到处用的是贴片元件，双面布线，越复杂就越有水平，好像他们在设计的时候就想着，学习单片机只要根据我的提示下载程序就可以了，更有甚者将下载器和集成了实验板上。很多初学者学完单片机还认为，原来单片机不是一块芯片，是老教材上经常提到的使用已经不到的单板机。</p><p>我觉得初学单片机有这几个模块就够了，剩下的得自己去开发。流水灯、数码管、键盘、蜂鸣器、串口通讯、AD等这就差不多了。如果上面我提到的这些，你能熟练应用，那可以说对于单片机方面的硬件你已经入门了，剩下的就是自己练习设计电路，不断的积累经验。设计的电路的时候必须要学习下PCB板设计软件，毕竟现在做开发要产品批量化还得电脑辅助设计啊，手工的效率太低了。但是在学习的过程中建议自己动手焊接。</p><p>在焊接前一定要了解电路连接，网上随便搜索可以找到很多电路原理图，但是都不一定都能用，所以建议备一块面包板，有了它你在焊接电路前就可以先测试下了。如果在面包板上测试成功，后来的焊接你就志在必得了，如果失败，大不了重新再找一个。只要过了第一关，后面的路就好走，万事起步难。方法二：你身边如果有单片机入门者，动手能力比较强，请他帮忙，搭个简单的单片机最下电路，哪怕是控制一个LED工作的电路。</p><p>对于他们来说，做个单片机的最小系统板是轻而易举，而对于初学者可就难多，这中间的一层窗户纸破了就什么都简单了。因为只有对硬件了解了，才能熟练运用。只有知道程序是和下载到单片机内部的，才会清楚为什么要写单片机程序，这个动力来自于哪里，来至于心里有底。</p><p>单片机编程就是与单片机对话，如果不知道对方谁，有没有再听，你还会有说话的激情吗。当然了如果没有这样的人，还是那句话，在网上多找几个最小电路电路原理图，在面包板上焊接就可以了。当然了这个也不会的，那建议你一定要买一块实验板，以后单片机的学习实验及项目测试验都用的上。 </p><img src="https://mmbiz.qpic.cn/mmbiz_png/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncxuc5P2NgN6ab7UzdwWoB8zIJ4UrYWHqNgnhIfFLCJESxIeJ0vbiaMgA/640?wx_fmt=png" class="[class names]"><h2 id="如何迈入单片机开发世界"><a href="#如何迈入单片机开发世界" class="headerlink" title="如何迈入单片机开发世界"></a>如何迈入单片机开发世界</h2><p>有了单片机实验板你就要多练习，最好是自己有台电脑，少下载几部电影，少网络游戏，把实验板和电脑连好，安装上必备的软件，下载参考程序，并修改参考程序，从最简单的交通灯实验做起，等你发现你能控制交通灯，并了解交通的软硬设计的时候你已经入门了，你会发现单片机是多么迷人的东西啊，这不是在学习知识，而是在提升自我的价值。用途那么广的交通的设计都不在话下了，你还会觉得你没有学到东西吗。还会觉得自己什么都不会吗？计算机编程、电子技术的专业知识都用上了啊。</p><p>当你编写的程序按你的意愿实现时，你比做什么事都开心，那种学习的收获感和成就感还有充实感是非常难得的。然后让数码管亮起来显示你所需要的数字。这两部分会了以后，你已经不能自拔了，你已经开始考虑你这辈子要走哪一行了。就这样学习，在写程序的时候你肯定会遇到很多问题，而这时你再去翻书找，这其中你会找你之前学过的编程的书，还有数电模电的书，你会发现原来之前学的知识还是有用的。遇到不懂再去找以前学过的书本查阅这才是 “温故而知新，可以为师矣”的大道理啊。</p><p>知识必须用于现实生活中，解决实际问题，用单片机设计个简易的家电定时器、红外遥控器什么，这样才能发挥它的作用，好好想想，上了这么多年大学，探索了那么久，犹豫徘徊，天天上课，在课堂上学到了什么？是不是为了期末60分的考试而忙碌，侥幸靠了90分，很高兴啊，在别人面前吹自己专业知识如何如何学习的好，殊不知，大学考试不像高中考试啊，那了奖学金又怎样。但是下学期开学回来一想，所学的知识已经忘记的一干二净。学到什么了？为什么要推荐学习单片机，因为单片机是工科生学的，集合计算机编程电子技术及多门控制语言为一体的学科，与其说学习是在学习单片机，不如说是在学习一个大学科。  </p><h2 id="学习单片机需要什么样的心态？"><a href="#学习单片机需要什么样的心态？" class="headerlink" title="学习单片机需要什么样的心态？"></a>学习单片机需要什么样的心态？</h2><p>1、首先要有信心，不要认为只有自己才这样，这是人性，每个人对新鲜事物都是有新鲜感的。刚开始点亮个小灯觉得很好玩，但是如果天天让你点亮个小灯，那还好玩么？但是你要想比别人成功，就要克服掉这个人性，在别人坚持不下去的时候，你要能够坚持下去，只有这样才有可能比别人做的更好，比别人更成功，所以你要有对成功的无限渴望。</p><p>2、找几个喜欢学习，同样喜欢单片机的人一起学。大学有这样一种现象，就是有的寝室所有的人都考上了研究生，有的全寝室同学都入党，有的全寝室同学一起去参加什么比赛，而有的寝室所有的同学都整天打游戏无所事事。因此应该给自己找几个学的好的人一起作伴，当大家一起，你的情绪不好的时候，别人的情绪好可以约束你的惰性，给予你鼓励，而且很多人在一起可以相互讨论。</p><p>3、没事多思考思考家里供你上学的父母，想想你自己的未来。你是想把青春就这么挥霍掉，还是想让青春绽放光彩，去改变你自己的世界。</p><p>4、抓住一切能参与实践的机会。以完成某一个项目为目的，完成项目的过程中，可以大幅提高自己的能力。项目越多，大幅提升自己能力的机会越多，战斗能力从实战中提升最快。</p><p>5、和论坛里的单片机学员一起学习。在这里，有同样水平的人相互讨论，或者加入一些技术讨论群，看看群里其他的小伙伴依然在努力学习，那你还好意思不继续学习么？</p><p>6.一旦确定要学习了，那就要和单片机谈恋爱，和技术结婚，终生伴他左右。技术已经成为我们生活的一部分，当别人以打牌为乐，而我们更喜欢追求解决一个技术问题带给我们的成就感。技术不仅仅是成为我们的谋生手段，养家糊口的本领，更是我们的朋友。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/l2UMibTzEMJtH4IPXXTWphXdPCBicOc5ncc6gDTqeAH99fVuwLU4Lbw3GY6e4icyxDbOgHNaicbNaoAiaQ3qmfP7Lpw/640?wx_fmt=png" class="[class names]"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这就是我开始学习的一些想法，革命尚未成功，同志仍需努力，以后要走的路还远，我们要有最大的决心去克服遇到的问题，一路前行，未来是美好的，毕竟努力了可能会成功，不努力是一定不会成功的！</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>琴瑟在御，莫不静好。</title>
      <link href="/2018/11/21/qin-se-zai-yu-mo-bu-jing-hao/"/>
      <url>/2018/11/21/qin-se-zai-yu-mo-bu-jing-hao/</url>
      
        <content type="html"><![CDATA[<h2 id="琴瑟在御，莫不静好。"><a href="#琴瑟在御，莫不静好。" class="headerlink" title="琴瑟在御，莫不静好。"></a>琴瑟在御，莫不静好。</h2><p>愿你免为尘杂所侵<br>愿你获得永世的安宁<br>愿你修得一颗平等心<br>不贪爱不嗔恨<br>喜悦地活在当下</p><p>愿你三冬暖，愿你春不寒<br>愿你天黑有灯，下雨有伞<br>愿你一路上，有良人相伴</p><p>琴瑟在御，莫不静好。</p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1542778424644&di=ecea28793667fec786eb5af5cc25e7b4&imgtype=0&src=http%3A%2F%2Fimgsrc.baidu.com%2Fimgad%2Fpic%2Fitem%2F8435e5dde71190ef762527fbc41b9d16fdfa6033.jpg" class="[class names]" title="[50%] [500] [title text [alt text]]">]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo中添加本地图片和使用网络图片</title>
      <link href="/2018/11/21/hexo-zhong-tian-jia-ben-di-tu-pian-he-shi-yong-wang-luo-tu-pian/"/>
      <url>/2018/11/21/hexo-zhong-tian-jia-ben-di-tu-pian-he-shi-yong-wang-luo-tu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="First-相对引用"><a href="#First-相对引用" class="headerlink" title="First 相对引用"></a>First 相对引用</h2><p>由于首页和主页相对图片位置不一致，网站首页和内页很可能仅有一处能正常加载。</p><p>1 调整程序配置文件_config.yml 里的post_asset_folder:这个选项设置为True</p><p>2 在source下创建/images文件夹，先把图片xx.jpg/png复制到这个文件夹</p><p>3 最后在xxxx.md中想引入图片时，只需要在xxxx.md中按照markdown的格式引入图片：</p><pre class=" language-bash"><code class="language-bash">1<span class="token operator">!</span><span class="token punctuation">[</span>想输入的提示名字，可不输入<span class="token punctuation">]</span><span class="token punctuation">(</span>/images/xx.jpg<span class="token punctuation">)</span></code></pre><h2 id="Second-图床"><a href="#Second-图床" class="headerlink" title="Second 图床"></a>Second 图床</h2><p>如SMMS图床无需注册<br>以下是测试：<br><img src="https://i.loli.net/2018/02/09/5a7d6a402e15e.jpg" class="[class names]" title="[50%] [50] [title text [alt text]]"><br>请备份Delete Link,必要时访问此链接删除图片。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/20/hello-world/"/>
      <url>/2018/11/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
